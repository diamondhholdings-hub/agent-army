# Milestone v1.0: Sales Agent MVP

**Status:** ✅ SHIPPED 2026-02-22
**Phases:** 1–8 (including decimal phases 4.1, 4.2)
**Total Plans:** 49

## Overview

Agent Army v1.0 delivers a complete AI sales organization platform where a Sales Agent autonomously executes enterprise sales methodology at top-1% level. The build progressed from infrastructure foundation through agent orchestration, knowledge base, conversational capabilities, deal management, real-time meeting attendance, learning & feedback, QBS methodology, autonomous intelligence, and gap closure — each phase delivering a complete, verifiable capability that unblocked the next. The Sales Agent validated across all phases becomes the template for the remaining 7 agent roles (v2).

## Phases

### Phase 1: Infrastructure Foundation

**Goal:** A multi-tenant platform exists where tenant-isolated services can be deployed, accessed securely, and monitored -- the bedrock for everything that follows
**Depends on:** Nothing (first phase)
**Plans:** 3 plans

Plans:
- [x] 01-01: Multi-tenant database and tenant provisioning (Wave 1)
- [x] 01-02: API gateway, authentication, and LLM integration (Wave 2)
- [x] 01-03: Deployment pipeline, monitoring, and environment management (Wave 2)

**Details:** Multi-tenant PostgreSQL with schema-per-tenant isolation, RLS policies, tenant context propagation via contextvars, JWT + API key authentication, LiteLLM Router for provider abstraction (Claude Sonnet 4 + GPT-4o fallback), Redis with tenant key prefixing, Docker + Cloud Run deployment pipeline, Prometheus metrics, Sentry error tracking, Google Secret Manager per-tenant secrets.

---

### Phase 2: Agent Orchestration

**Goal:** Agents can be registered, coordinated through a supervisor topology, and communicate via events with validated handoffs -- preventing the "bag of agents" anti-pattern
**Depends on:** Phase 1
**Plans:** 6 plans

Plans:
- [x] 02-01: Event bus infrastructure (Redis Streams event schemas, tenant-scoped bus, consumer with retry, DLQ)
- [x] 02-02: Agent registry and base agent (BaseAgent abstract class, AgentRegistry with capability discovery)
- [x] 02-03: Handoff validation protocol (structural Pydantic validators, LLM semantic validation, configurable strictness)
- [x] 02-04: Three-tier context management (session store, long-term memory, working context compiler)
- [x] 02-05: Supervisor orchestration (hybrid router, task decomposition, backup failure handling, LLM synthesis)
- [x] 02-06: Observability, cost tracking, and integration wiring (Langfuse, Prometheus, main.py wiring)

**Details:** SupervisorOrchestrator with hybrid rule+LLM routing, HandoffProtocol with structural+semantic validation, TenantEventBus with tenant-scoped Redis Streams, three-tier context (LangGraph session, pgvector long-term, tiktoken working), Langfuse tracing with per-tenant per-agent cost tracking.

---

### Phase 3: Knowledge Base

**Goal:** The platform has a rich, tenant-scoped knowledge foundation that agents can query -- product data, sales methodologies, regional nuances, and conversation history are all retrievable with high relevance
**Depends on:** Phases 1, 2
**Plans:** 7 plans

Plans:
- [x] 03-01: Qdrant vector DB and embedding foundation
- [x] 03-02: Document ingestion pipeline
- [x] 03-03: End-to-end ingestion orchestration
- [x] 03-04: ESW product knowledge data
- [x] 03-05: Sales methodology and regional nuances
- [x] 03-06: Conversation history storage
- [x] 03-07: Agentic RAG pipeline

**Details:** Qdrant with payload-based multitenancy, hybrid dense+sparse search (OpenAI embeddings + BM25 RRF fusion), ESW product knowledge (Skyvera monetization/charging/billing), MEDDIC/BANT/SPIN methodology frameworks, APAC/EMEA/Americas regional nuances, ConversationStore with semantic search, AgenticRAGPipeline with QueryDecomposer + MultiSourceRetriever + ResponseSynthesizer.

---

### Phase 4: Sales Agent Core

**Goal:** The Sales Agent can conduct text-based sales interactions -- sending contextual emails and chats, adapting to customer personas, executing qualification frameworks, and knowing when to escalate to a human
**Depends on:** Phases 2, 3
**Plans:** 5 plans

Plans:
- [x] 04-01: GSuite integration services (Gmail and Google Chat async wrappers with auth caching)
- [x] 04-02: Sales schemas and persona-adapted prompt system with Chris Voss methodology
- [x] 04-03: Conversation state persistence and qualification signal extraction with instructor
- [x] 04-04: SalesAgent class, next-action engine, and escalation manager
- [x] 04-05: API endpoints, agent registration, and integration tests

**Details:** Gmail + Google Chat integration with async wrappers, BANT+MEDDIC extraction via instructor in single LLM call, Chris Voss methodology embedded in prompts, persona adaptation (IC/Manager/C-Suite), conversation state persistence to PostgreSQL, NextActionEngine (hybrid rule+LLM), EscalationManager with 4 triggers.

---

### Phase 4.1: Agent Learning & Performance Feedback (INSERTED)

**Goal:** The Sales Agent learns from its interactions and improves over time through outcome tracking, confidence calibration, human feedback loops, and performance analytics
**Depends on:** Phase 4
**Plans:** 3 plans

Plans:
- [x] 04.1-01: Outcome tracking data models, Pydantic schemas, OutcomeTracker service, and migration
- [x] 04.1-02: FeedbackCollector, CalibrationEngine, CoachingPatternExtractor services
- [x] 04.1-03: AnalyticsService, scheduler, API endpoints, SSE streaming, main.py wiring, and integration tests

**Details:** OutcomeTracker with signal detection (24h email, 168h meeting, 720h deal progression), FeedbackCollector with dual-source rating (inline -1/0/1, dashboard 1-5), CalibrationEngine with Brier score and 10% max adjustment, CoachingPatternExtractor using statistical correlations, three-role analytics dashboards (rep/manager/executive), SSE streaming with Redis pub/sub fallback.

---

### Phase 4.2: QBS Methodology Integration (INSERTED)

**Goal:** The Sales Agent leverages Question Based Selling (QBS) methodology throughout all sales stages -- using pain funnel questions, impact questions, solution questions, and confirmation questions
**Depends on:** Phase 4.1
**Plans:** 4 plans

Plans:
- [x] 04.2-01: QBS Pydantic schemas, prompt templates, and unit tests
- [x] 04.2-02: QBS Question Engine, Pain Depth Tracker, Account Expansion Detector
- [x] 04.2-03: Agent integration, prompt wiring, learning integration, and integration tests
- [x] 04.2-04: Gap closure: wire QBS components into SalesAgent in main.py

**Details:** QBSQuestionEngine with 4 question types (pain funnel, impact, solution, confirmation), PainDepthTracker with forward-only depth progression, AccountExpansionDetector for multi-threaded relationship building. QBS methodology prompt always in system prompt; dynamic guidance is additive layer.

---

### Phase 5: Deal Management

**Goal:** The Sales Agent manages the full deal lifecycle -- identifying opportunities from conversations, maintaining strategic account plans and tactical opportunity plans, mapping political structures, and keeping CRM in sync
**Depends on:** Phase 4
**Plans:** 6 plans

Plans:
- [x] 05-01: Deal management data models, schemas, repository, and migration
- [x] 05-02: Opportunity detection, political mapping, and plan manager
- [x] 05-03: CRM adapter, Notion connector, and sync engine
- [x] 05-04: Evidence-based stage progression engine
- [x] 05-05: API endpoints, post-conversation hooks, main.py wiring, and integration tests
- [x] 05-06: Gap closure: wire PostConversationHook into sales conversation endpoints

**Details:** OpportunityDetector (>0.80 confidence threshold), PoliticalMapper with 3-layer scoring (title heuristics + conversation + human override), account/opportunity plans with bounded list growth, CRM sync engine with PostgreSQL + Notion adapters, StageProgressionEngine with evidence-based thresholds (no auto-progression past NEGOTIATION), PostConversationHook wired to all 3 sales endpoints.

---

### Phase 6: Meeting Capabilities

**Goal:** The Sales Agent attends Google Meet meetings with an avatar representation, participates in real-time conversation, and produces meeting minutes distributed to stakeholders
**Depends on:** Phase 4
**Plans:** 6 plans

Plans:
- [x] 06-01: Meeting data foundation (schemas, models, migration, repository, Calendar service)
- [x] 06-02: Pre-meeting pipeline (CalendarMonitor and BriefingGenerator)
- [x] 06-03: Recall.ai bot management and real-time service wrappers (STT, TTS, Avatar)
- [x] 06-04: Real-time pipeline (TurnDetector, SilenceChecker, RealtimePipeline, Output Media webapp)
- [x] 06-05: Post-meeting pipeline (MinutesGenerator with map-reduce, MinutesDistributor)
- [x] 06-06: API endpoints, WebSocket, main.py wiring, and integration tests

**Details:** CalendarMonitor with 2-hour briefing lead time, BriefingGenerator with 3 formats, BotManager + Recall.ai integration, DeepgramSTT + ElevenLabsTTS + HeyGenAvatar, RealtimePipeline with 1000ms latency budget, MinutesGenerator with map-reduce extraction, MinutesDistributor with manual external sharing. 11 API endpoints + WebSocket + webhook.

---

### Phase 7: Intelligence & Autonomy

**Goal:** The Sales Agent operates with autonomous intelligence -- consolidating data across all channels, recognizing patterns, pursuing revenue goals self-directedly, adapting to geographic norms, and being clonable per sales rep
**Depends on:** Phases 4, 5, 6
**Plans:** 6 plans

Plans:
- [x] 07-01: Intelligence data foundation (schemas, models, repository, and migration)
- [x] 07-02: Geographic adapter and agent cloning/persona system
- [x] 07-03: Cross-channel data consolidation (EntityLinker, ContextSummarizer, CustomerViewService)
- [x] 07-04: Pattern recognition (detectors, PatternRecognitionEngine, InsightGenerator)
- [x] 07-05: Autonomy engine (GuardrailChecker, GoalTracker, AutonomyEngine, ProactiveScheduler)
- [x] 07-06: API endpoints, main.py wiring, prompt integration, and integration tests

**Details:** CustomerViewService consolidating 4 channels (email/chat/meeting/CRM), PatternRecognitionEngine detecting buying signals/risks/engagement/churn, GuardrailChecker with 3 tiers (autonomous/approval_required/hard_stops), GoalTracker with 4 metric types, ProactiveScheduler with 5 background tasks, GeographicAdapter for APAC/EMEA/Americas, AgentCloneManager with persona differentiation. Persona prompt injected after methodology, before critical rules.

---

### Phase 8: Meeting Real-Time Completion (GAP CLOSURE)

**Goal:** Complete Phase 6 meeting capabilities by wiring real-time conversation pipeline, deploying avatar webapp, and enabling proactive meeting detection
**Depends on:** Phases 6, 7
**Plans:** 3 plans

Plans:
- [x] 08-01: RealtimePipeline factory and bot lifecycle wiring
- [x] 08-02: Output Media webapp deployment and configuration
- [x] 08-03: CalendarMonitor background task and integration tests

**Details:** BotManager._create_pipeline_for_meeting() factory wired to in_call_recording webhook, pipeline stored as app.state.pipeline_{meeting_id}, delattr cleanup on call_ended. vercel.json deployment config with esbuild bundle (849KB). asyncio.create_task wrapping run_poll_loop with POLL_INTERVAL_SECONDS=900, graceful CancelledError shutdown. 7 integration tests. 1,123 total tests passing.

---

## Milestone Summary

**Decimal Phases Inserted:**

- Phase 4.1: Agent Learning & Performance Feedback — inserted after Phase 4 to add learning capability before deal management complexity. Rationale: agent should learn from text interactions before adding deal complexity.
- Phase 4.2: QBS Methodology Integration — inserted after Phase 4.1 for Question Based Selling throughout all sales stages. Rationale: QBS completes the methodology stack (BANT + MEDDIC + Chris Voss + QBS).
- Phase 8: Meeting Real-Time Completion — gap closure phase after Phase 7 audit found 3 critical wiring gaps in Phase 6 real-time conversation. Rationale: realtimePipeline was implemented but not wired.

**Key Decisions:**

- Multi-tenant from day 1 (cannot be retrofitted per research)
- Async deal workflows (Phase 4-5) before real-time meetings (Phase 6)
- Fail-open pattern throughout (LLM errors return fallback, not 500)
- Single LLM call for all qualification signals (anti-pattern: no per-field calls)
- Pipeline factory pattern for real-time: create on bot join, destroy on bot leave
- Methodology prompt always in system prompt; QBS/persona are additive layers
- No auto-progression past NEGOTIATION (close decisions are human-only)
- Guardrail tier system: autonomous < approval_required < hard_stops

**Issues Resolved:**

- RealtimePipeline orphaned (existed but not wired) — fixed by Phase 8 pipeline factory
- CalendarMonitor created but not started — fixed by Phase 8 asyncio.create_task
- Output Media webapp code complete but no deployment config — fixed by Phase 8 vercel.json
- QBS verification incorrectly reported as gaps_found — confirmed fully operational by integration checker
- PostgreSQL NOSUPERUSER required for RLS FORCE — resolved in Phase 1

**Issues Deferred:**

- GCP deployment human verification (infrastructure code ready, manual Cloud Run setup required)
- CalendarMonitor bot-join trigger (logs intent, doesn't call join API — manual trigger via REST works)
- Deal context in briefings (rule-based fallback acceptable for v1)
- Avatar render manual test (requires live Vercel deployment + HeyGen credentials)

**Technical Debt Incurred:**

- 7 tech debt items totaling ~11.5 hours (see v1-MILESTONE-AUDIT.md for details)
- UUID string normalisation gap in pipeline key lookup (low risk)
- WebSocket integration test uses minimal FastAPI app (test fragility only)

---

_For current project status, see .planning/ROADMAP.md_
