---
phase: 14-customer-success-agent
plan: 05
type: execute
wave: 4
depends_on: ["14-03"]
files_modified:
  - src/app/agents/sales/agent.py
  - src/app/main.py
autonomous: true

must_haves:
  truths:
    - "Sales Agent handles handle_expansion_opportunity task type — registered in handlers dict"
    - "Sales Agent handle_expansion_opportunity creates Gmail draft for rep with expansion details"
    - "app.state.customer_success is CustomerSuccessAgent instance after startup"
    - "app.state.csm_scheduler is CSMScheduler instance after startup"
    - "CSM startup block is fail-tolerant — app starts even if CSM init fails"
    - "CSMScheduler is stopped in lifespan shutdown section"
    - "CustomerSuccessAgent receives sales_agent reference for expansion dispatch"
  artifacts:
    - path: "src/app/agents/sales/agent.py"
      provides: "handle_expansion_opportunity handler registered in Sales Agent"
      contains: "_handle_expansion_opportunity"
    - path: "src/app/main.py"
      provides: "Phase 14 CSM startup block after Phase 13 TAM block"
      contains: "customer_success"
  key_links:
    - from: "src/app/main.py"
      to: "CustomerSuccessAgent"
      via: "Phase 14 startup try/except block"
      pattern: "from src.app.agents.customer_success"
    - from: "src/app/agents/customer_success/agent.py"
      to: "src/app/agents/sales/agent.py"
      via: "sales_agent.execute({'type': 'handle_expansion_opportunity', ...})"
      pattern: "handle_expansion_opportunity"
    - from: "src/app/main.py"
      to: "app.state.csm_scheduler.stop()"
      via: "lifespan shutdown section"
      pattern: "csm_scheduler.*stop"
---

<objective>
Wire the CSM agent into the running application: add the expansion opportunity handler to the Sales Agent (completing the first bidirectional agent-to-agent handoff), and wire CustomerSuccessAgent + CSMScheduler into main.py lifespan.

Purpose: Without this plan, the CSM agent exists but is never started and the expansion dispatch has no receiver. This plan makes the system live and bidirectional.
Output: Sales Agent updated with handle_expansion_opportunity handler; main.py Phase 14 startup block.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/14-customer-success-agent/14-CONTEXT.md
@.planning/phases/14-customer-success-agent/14-03-SUMMARY.md
@src/app/agents/sales/agent.py
@src/app/main.py
@src/app/agents/technical_account_manager/scheduler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add handle_expansion_opportunity handler to Sales Agent</name>
  <files>
    src/app/agents/sales/agent.py
  </files>
  <action>
Edit src/app/agents/sales/agent.py to add the expansion opportunity handler. This is the receiver for CSM→Sales reverse dispatch — the first bidirectional agent-to-agent handoff in the system.

**Step 1:** Find the handlers dict in the Sales Agent (around line 166 based on grep — near dispatch_tam_health_check). Add new entry:
```python
"handle_expansion_opportunity": self._handle_expansion_opportunity,
```

**Step 2:** Add the handler method `_handle_expansion_opportunity(self, task, context)`:
```python
async def _handle_expansion_opportunity(
    self, task: dict[str, Any], context: dict[str, Any]
) -> dict[str, Any]:
    """Handle expansion opportunity dispatched by CSM agent.

    Receives structured expansion data from CSM, creates a Gmail draft
    for the rep with the recommended talk track and ARR impact.
    NEVER calls send_email — draft only.
    """
    try:
        account_id = task.get("account_id", "")
        opportunity_type = task.get("opportunity_type", "unknown")
        evidence = task.get("evidence", "")
        estimated_arr_impact = task.get("estimated_arr_impact")
        recommended_talk_track = task.get("recommended_talk_track", "")

        # Build Gmail draft for rep review
        subject = f"[CSM Expansion] {account_id} — {opportunity_type} opportunity"
        arr_str = f"${estimated_arr_impact:,.0f}" if estimated_arr_impact else "TBD"
        body_html = (
            f"<h2>Expansion Opportunity: {opportunity_type.title()}</h2>"
            f"<p><strong>Account:</strong> {account_id}</p>"
            f"<p><strong>Estimated ARR Impact:</strong> {arr_str}</p>"
            f"<p><strong>Evidence:</strong> {evidence}</p>"
            f"<h3>Recommended Talk Track</h3>"
            f"<p>{recommended_talk_track}</p>"
            f"<p><em>Identified by Customer Success agent. Review and reach out when ready.</em></p>"
        )

        draft_id = None
        gmail_service = getattr(self, "_gmail_service", None)
        if gmail_service is not None:
            try:
                from src.app.services.gsuite.models import EmailMessage
                # Use a placeholder rep_email; actual to: address filled by rep
                draft_email = EmailMessage(
                    to="",  # rep fills in recipient
                    subject=subject,
                    body_html=body_html,
                )
                draft_result = await gmail_service.create_draft(draft_email)
                draft_id = (
                    draft_result.draft_id if hasattr(draft_result, "draft_id")
                    else draft_result.get("draft_id", "") if isinstance(draft_result, dict)
                    else None
                )
            except Exception as draft_err:
                self._log.warning(
                    "expansion_opportunity_draft_failed",
                    account_id=account_id,
                    error=str(draft_err),
                )

        return {
            "task_type": "handle_expansion_opportunity",
            "account_id": account_id,
            "opportunity_type": opportunity_type,
            "draft_id": draft_id,
            "confidence": "high",
        }

    except Exception as exc:
        self._log.warning(
            "handle_expansion_opportunity_failed",
            error=str(exc),
            error_type=type(exc).__name__,
        )
        return {
            "task_type": "handle_expansion_opportunity",
            "error": str(exc),
            "confidence": "low",
            "partial": True,
        }
```

Place this method near the other dispatch handlers (after _handle_dispatch_tam_health_check). Follow TAM handler placement pattern.

IMPORTANT: Do NOT change any existing Sales Agent handlers or logic. Surgical addition only.
  </action>
  <verify>
python -c "
from src.app.agents.sales.agent import SalesAgentSupervisor
# Verify handler is registered (check source, not runtime — we can't instantiate without deps)
import inspect
source = inspect.getsource(SalesAgentSupervisor)
assert 'handle_expansion_opportunity' in source
assert '_handle_expansion_opportunity' in source
print('handle_expansion_opportunity registered in Sales Agent OK')
"
  </verify>
  <done>Sales Agent source contains handle_expansion_opportunity in handlers dict and _handle_expansion_opportunity method. Method creates Gmail draft with expansion details and follows fail-open pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Wire CustomerSuccessAgent and CSMScheduler into main.py lifespan</name>
  <files>
    src/app/main.py
  </files>
  <action>
Edit src/app/main.py to add Phase 14 CSM startup block. Place it AFTER the Phase 13 TAM block (after line ~382 where TAMScheduler is stored) and BEFORE the Phase 5 Deal Management block.

**Step 1 — Find insertion point:** Search for "Phase 5: Deal Management" or "Phase 13" end marker. Insert the CSM block between them.

**Step 2 — Add Phase 14 startup block:**
```python
# ── Phase 14: Customer Success Agent ──────────────────────────────────
# Builds on Phase 13 (TAM) — CSM is the commercial layer over TAM's technical layer.
# CSM receives sales_agent reference for bidirectional expansion dispatch.
# Fail-tolerant -- CSM unavailability does not prevent app startup.

try:
    from src.app.agents.customer_success.agent import CustomerSuccessAgent
    from src.app.agents.customer_success.health_scorer import CSMHealthScorer
    from src.app.agents.customer_success.scheduler import CSMScheduler
    from src.app.agents.customer_success.notion_adapter import NotionCSMAdapter

    csm_health_scorer = CSMHealthScorer()
    csm_notion_adapter = NotionCSMAdapter(
        notion_client=getattr(app.state, "notion_client", None)
        or locals().get("notion_client"),
    ) if (getattr(app.state, "notion_client", None) or locals().get("notion_client")) else None

    # Get sales_agent reference for bidirectional expansion dispatch
    sales_agent_ref = getattr(app.state, "sales_agent", None)

    csm_agent = CustomerSuccessAgent(
        registration=None,  # no AgentRegistration needed for direct dispatch
        llm_service=getattr(app.state, "llm_service", None)
        or locals().get("llm_service"),
        notion_csm=csm_notion_adapter,
        gmail_service=getattr(app.state, "gmail_service", None)
        or locals().get("gmail_service"),
        chat_service=getattr(app.state, "chat_service", None)
        or locals().get("chat_service"),
        event_bus=getattr(app.state, "event_bus", None)
        or locals().get("event_bus"),
        health_scorer=csm_health_scorer,
        sales_agent=sales_agent_ref,
    )
    app.state.customer_success = csm_agent

    csm_scheduler = CSMScheduler(
        csm_agent=csm_agent,
        notion_csm=csm_notion_adapter,
    )
    csm_scheduler_started = csm_scheduler.start()
    if csm_scheduler_started:
        app.state.csm_scheduler = csm_scheduler
        log.info("phase14.csm_scheduler_started")
    else:
        app.state.csm_scheduler = None
        log.warning("phase14.csm_scheduler_not_started", reason="APScheduler unavailable or start failed")

    log.info("phase14.customer_success_agent_initialized")
except Exception as exc:
    log.warning("phase14.customer_success_agent_init_failed", error=str(exc))
    app.state.customer_success = None
    app.state.csm_scheduler = None
```

Note: CustomerSuccessAgent constructor may need `registration` to be optional (check if BaseAgent requires it — if so, use the same create_*_registration() factory pattern as TAM; look at how TAMAgent handles this in main.py and mirror it exactly).

**Step 3 — Add shutdown cleanup:** Find the shutdown section (near line ~710 where tam_scheduler_ref.stop() is called). Add AFTER the TAM scheduler stop:
```python
csm_scheduler_ref = getattr(app.state, "csm_scheduler", None)
if csm_scheduler_ref:
    csm_scheduler_ref.stop()
```
  </action>
  <verify>
python -c "
import ast, sys
with open('src/app/main.py', 'r') as f:
    source = f.read()
assert 'customer_success' in source
assert 'csm_scheduler' in source
assert 'phase14.customer_success_agent_initialized' in source
assert 'csm_scheduler_ref' in source
# Validate syntax
ast.parse(source)
print('main.py Phase 14 block verified OK')
"
  </verify>
  <done>main.py has Phase 14 CSM startup block after Phase 13 TAM block. app.state.customer_success and app.state.csm_scheduler are set. Shutdown block stops CSMScheduler. File parses as valid Python.</done>
</task>

</tasks>

<verification>
python -c "
import ast
with open('src/app/main.py') as f:
    source = f.read()
ast.parse(source)
assert 'handle_expansion_opportunity' in open('src/app/agents/sales/agent.py').read()
assert 'customer_success' in source and 'csm_scheduler' in source
print('Plan 14-05 verification PASSED')
"
</verification>

<success_criteria>
- Sales Agent handlers dict includes handle_expansion_opportunity
- _handle_expansion_opportunity creates Gmail draft and follows fail-open
- main.py has Phase 14 block between Phase 13 and Phase 5 sections
- app.state.customer_success and app.state.csm_scheduler assigned in startup
- Shutdown section stops csm_scheduler
- main.py is valid Python (ast.parse passes)
</success_criteria>

<output>
After completion, create `.planning/phases/14-customer-success-agent/14-05-SUMMARY.md`
</output>
