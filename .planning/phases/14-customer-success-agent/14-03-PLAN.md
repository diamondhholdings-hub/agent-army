---
phase: 14-customer-success-agent
plan: 03
type: execute
wave: 3
depends_on: ["14-01", "14-02"]
files_modified:
  - src/app/agents/customer_success/agent.py
  - src/app/agents/customer_success/scheduler.py
autonomous: true

must_haves:
  truths:
    - "CustomerSuccessAgent routes 4 task types: health_scan, generate_qbr, check_expansion, track_feature_adoption"
    - "Unknown task type raises ValueError (matching TAM pattern, not BA fail-open)"
    - "Each handler follows fail-open pattern returning {error, confidence: low, partial: True} on LLM/service error"
    - "health_scan handler uses CSMHealthScorer (no LLM) and triggers 4-channel alert when should_alert=True"
    - "check_expansion handler dispatches ExpansionOpportunity to Sales Agent via self._sales_agent.execute()"
    - "CSM never calls send_email — all communications use gmail_service.create_draft()"
    - "CSMScheduler has 3 cron jobs: daily scan (7am), quarterly QBR (day=1, month=1,4,7,10), daily contract check (8am)"
    - "CSMScheduler.start() returns False gracefully if APScheduler not installed"
  artifacts:
    - path: "src/app/agents/customer_success/agent.py"
      provides: "CustomerSuccessAgent with 4 task handlers"
      contains: "class CustomerSuccessAgent"
    - path: "src/app/agents/customer_success/scheduler.py"
      provides: "CSMScheduler with 3 APScheduler cron jobs"
      contains: "class CSMScheduler"
  key_links:
    - from: "src/app/agents/customer_success/agent.py"
      to: "CSMHealthScorer.score()"
      via: "self._health_scorer.score(signals, account_id)"
      pattern: "self._health_scorer\\.score"
    - from: "src/app/agents/customer_success/agent.py"
      to: "Sales Agent via expansion dispatch"
      via: "self._sales_agent.execute({'task_type': 'handle_expansion_opportunity', ...})"
      pattern: "_sales_agent.*execute"
    - from: "src/app/agents/customer_success/agent.py"
      to: "gmail_service.create_draft()"
      via: "churn alert and QBR notification drafts"
      pattern: "create_draft"
    - from: "src/app/agents/customer_success/scheduler.py"
      to: "CustomerSuccessAgent.execute()"
      via: "daily cron at 7am"
      pattern: "CronTrigger.*hour=7"
---

<objective>
Build the CustomerSuccessAgent (4-handler task router with fail-open semantics) and CSMScheduler (3-job APScheduler wrapper). This is the core agent class that wires all CSM capabilities into a single processable unit.

Purpose: The agent is the central router. The scheduler provides the autonomous daily/quarterly job execution that makes the CSM proactive rather than reactive.
Output: agent.py with CustomerSuccessAgent, scheduler.py with CSMScheduler.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/14-customer-success-agent/14-CONTEXT.md
@.planning/phases/14-customer-success-agent/14-RESEARCH.md
@.planning/phases/14-customer-success-agent/14-01-SUMMARY.md
@.planning/phases/14-customer-success-agent/14-02-SUMMARY.md
@src/app/agents/technical_account_manager/agent.py
@src/app/agents/technical_account_manager/scheduler.py
@src/app/agents/customer_success/schemas.py
@src/app/agents/customer_success/health_scorer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CustomerSuccessAgent with 4 capability handlers</name>
  <files>
    src/app/agents/customer_success/agent.py
  </files>
  <action>
Create src/app/agents/customer_success/agent.py. Mirror TAMAgent structure exactly: BaseAgent subclass, same constructor pattern, same fail-open handler semantics, same ValueError for unknown task type.

**CustomerSuccessAgent class constructor:**
```python
def __init__(
    self,
    registration: AgentRegistration,
    llm_service: object,
    notion_csm: object | None = None,
    gmail_service: object | None = None,
    chat_service: object | None = None,
    event_bus: object | None = None,
    health_scorer: object | None = None,
    sales_agent: object | None = None,  # for expansion dispatch (reverse handoff)
) -> None:
```
Store all as self._* attributes. Use structlog logger bound to agent_id.

**execute() method:**
```python
async def execute(self, task: dict[str, Any], context: dict[str, Any]) -> dict[str, Any]:
    task_type = task.get("type", "")
    handlers = {
        "health_scan": self._handle_health_scan,
        "generate_qbr": self._handle_generate_qbr,
        "check_expansion": self._handle_check_expansion,
        "track_feature_adoption": self._handle_track_feature_adoption,
    }
    handler = handlers.get(task_type)
    if handler is None:
        raise ValueError(f"Unknown task type: {task_type!r}. Supported: {', '.join(handlers.keys())}")
    return await handler(task, context)
```

**_handle_health_scan(task, context):** (mirrors TAMAgent._handle_health_scan)
1. Check health_scorer is configured (return error dict if None)
2. Get account_id from task; if provided fetch from notion_csm.get_account(), else notion_csm.query_all_accounts()
3. For each account: build CSMHealthSignals from account data (feature_adoption_rate, usage_trend etc. from Notion properties; default sensible values if fields missing)
4. Call self._health_scorer.score(signals, account_id) — pure Python, no LLM
5. If score.should_alert: call _dispatch_churn_alerts() (rate-limited max 5 per scan)
6. Update notion_csm.update_health_score() if notion_csm is configured
7. Return dict with task_type, health_scores list, confidence="high"
8. Outer try/except returns {"task_type": "health_scan", "error": ..., "confidence": "low", "partial": True}

**_handle_generate_qbr(task, context):**
1. Get account_id, period (default to current quarter label e.g. "Q1 2026"), trigger from task
2. Fetch account data from notion_csm
3. Build prompt via build_qbr_prompt()
4. Call llm_service.completion() at temperature=0.4
5. Parse JSON response (use _extract_json_from_response() static method — copy from TAMAgent)
6. Construct QBRContent from parsed response
7. Create Notion QBR page via notion_csm.create_qbr_page(qbr, account_name)
8. Create Gmail DRAFT notification for rep (NEVER send_email): "QBR ready for review: {period}"
9. Return dict with task_type, qbr_page_id, draft_id, confidence="high"
10. Fail-open on LLM/Notion error

**_handle_check_expansion(task, context):**
1. Get account_id from task
2. Fetch account data from notion_csm
3. Build prompt via build_expansion_prompt()
4. Call llm_service.completion() at temperature=0.4
5. Parse JSON response to get list of opportunities
6. For each opportunity with confidence != "low":
   a. Create ExpansionOpportunity Pydantic model
   b. Save to notion_csm.create_expansion_record(opportunity)
   c. Dispatch to Sales Agent: self._sales_agent.execute({"type": "handle_expansion_opportunity", "account_id": ..., "opportunity_type": ..., "evidence": ..., "estimated_arr_impact": ..., "recommended_talk_track": ...}, context) — use try/except per opportunity, log warning on failure
7. Create Gmail DRAFT summary for rep listing all opportunities
8. Return dict with task_type, opportunities_found count, dispatched_to_sales count, draft_id
9. If self._sales_agent is None: skip dispatch, log warning, continue (fail-open)
10. Fail-open on error

**_handle_track_feature_adoption(task, context):**
1. Get account_id from task
2. Fetch account data from notion_csm
3. Build prompt via build_feature_adoption_prompt()
4. Call llm_service.completion() at temperature=0.4
5. Parse JSON to get FeatureAdoptionReport fields
6. Create FeatureAdoptionReport Pydantic model
7. Create Gmail DRAFT with adoption recommendations for rep
8. Return dict with task_type, adoption_rate, underutilized_count, draft_id, confidence="high"
9. Fail-open on error

**_dispatch_churn_alerts(account_id, health_score, context, account) private method:**
Same 4-channel pattern as TAMAgent._dispatch_escalation_notifications():
1. Notion: update health score via notion_csm.update_health_score()
2. Event bus: publish AGENT_HEALTH event with alert_type="csm_churn_alert"
3. Email DRAFT (NEVER send_email): "[CSM ALERT] Account {account_id} churn risk: {churn_risk_level}"
4. Chat alert via chat_service.send_message()
Returns CSMAlertResult.

**_extract_json_from_response static method:** Copy from TAMAgent exactly.

Add module-level docstring, __all__ = ["CustomerSuccessAgent"].
Update src/app/agents/customer_success/__init__.py to properly export CustomerSuccessAgent.
  </action>
  <verify>
python -c "
from src.app.agents.customer_success.agent import CustomerSuccessAgent
from src.app.agents.base import AgentRegistration
import asyncio
reg = AgentRegistration(agent_id='csm-test', name='CustomerSuccess', version='1.0', capabilities=[])
agent = CustomerSuccessAgent(registration=reg, llm_service=object())
# Test ValueError for unknown task
async def test():
    try:
        await agent.execute({'type': 'unknown_type'}, {})
        assert False, 'Should have raised ValueError'
    except ValueError as e:
        assert 'unknown_type' in str(e).lower() or 'Unknown' in str(e)
        print('ValueError raised correctly')
asyncio.run(test())
"
  </verify>
  <done>CustomerSuccessAgent instantiates with all constructor args. Unknown task type raises ValueError. 4 handlers registered. Module-level import works.</done>
</task>

<task type="auto">
  <name>Task 2: Create CSMScheduler with 3 cron jobs</name>
  <files>
    src/app/agents/customer_success/scheduler.py
  </files>
  <action>
Create src/app/agents/customer_success/scheduler.py. Mirror TAMScheduler exactly, adding a third quarterly QBR job.

```python
class CSMScheduler:
    def __init__(
        self,
        csm_agent: object,
        notion_csm: object | None = None,
    ) -> None:
        self._csm_agent = csm_agent
        self._notion_csm = notion_csm
        self._scheduler = None
        self._started = False
```

**start() -> bool:**
- Try import AsyncIOScheduler, CronTrigger
- If ImportError: log warning, return False
- Add 3 jobs:
  1. `_daily_health_scan`: CronTrigger(hour=7, minute=0), id="csm_daily_health_scan", misfire_grace_time=3600
  2. `_daily_contract_check`: CronTrigger(hour=8, minute=0), id="csm_daily_contract_check", misfire_grace_time=3600
  3. `_quarterly_qbr_generation`: CronTrigger(month="1,4,7,10", day=1, hour=4, minute=0), id="csm_quarterly_qbr", misfire_grace_time=7200
- Start scheduler, set self._started = True, log info with all 3 job names
- Return True

**_daily_health_scan() async:**
- Log trigger
- If notion_csm is None: log warning, return
- accounts = await self._notion_csm.query_all_accounts() — try/except
- For each account: dispatch {"type": "health_scan", "account_id": account.get("id", "")} to self._csm_agent.execute(task, context={})
- Log complete with success/failed counts

**_daily_contract_check() async:**
- Log trigger
- Purpose: flag accounts where days_to_renewal <= 60 and health is AMBER/RED
- If notion_csm is None: log warning, return
- accounts = await self._notion_csm.query_all_accounts()
- For each account: check "Contract End Date" property; compute days_to_renewal; if <= 60, dispatch health_scan for that account specifically
- Log accounts flagged count

**_quarterly_qbr_generation() async:**
- Log trigger
- If notion_csm is None: log warning, return
- accounts = await self._notion_csm.query_all_accounts()
- Compute current quarter label (e.g., "Q1 2026") from datetime.now()
- For each account: dispatch {"type": "generate_qbr", "account_id": ..., "period": quarter_label, "trigger": "quarterly"}
- Log complete with generated count

**stop() -> None:** Shutdown scheduler if started.

Add __all__ = ["CSMScheduler"]
  </action>
  <verify>
python -c "
from src.app.agents.customer_success.scheduler import CSMScheduler
sched = CSMScheduler(csm_agent=object(), notion_csm=None)
result = sched.start()
print(f'CSMScheduler.start() returned: {result}')
if result:
    sched.stop()
    print('CSMScheduler stopped OK')
print('CSMScheduler import OK')
"
  </verify>
  <done>CSMScheduler instantiates and start() either returns True (APScheduler available, 3 jobs registered) or False (APScheduler missing, graceful degradation). stop() works without error.</done>
</task>

</tasks>

<verification>
python -c "
from src.app.agents.customer_success.agent import CustomerSuccessAgent
from src.app.agents.customer_success.scheduler import CSMScheduler
from src.app.agents.base import AgentRegistration
reg = AgentRegistration(agent_id='csm-test', name='CustomerSuccess', version='1.0', capabilities=[])
agent = CustomerSuccessAgent(registration=reg, llm_service=object())
sched = CSMScheduler(csm_agent=agent)
print('CustomerSuccessAgent and CSMScheduler initialized OK')
print('Plan 14-03 verification PASSED')
"
</verification>

<success_criteria>
- CustomerSuccessAgent routes 4 task types (health_scan, generate_qbr, check_expansion, track_feature_adoption)
- Unknown task type raises ValueError
- check_expansion dispatches to self._sales_agent.execute() (skips gracefully if sales_agent=None)
- All handlers follow fail-open (outer try/except returns error dict)
- CSMScheduler has exactly 3 cron jobs: daily scan (7am), daily contract check (8am), quarterly QBR (month=1,4,7,10 day=1)
- CSMScheduler.start() returns False if APScheduler not installed
</success_criteria>

<output>
After completion, create `.planning/phases/14-customer-success-agent/14-03-SUMMARY.md`
</output>
