---
phase: 14-customer-success-agent
plan: 07
type: execute
wave: 5
depends_on: ["14-05", "14-06"]
files_modified:
  - tests/test_csm_wiring.py
  - tests/test_csm_expansion_dispatch.py
autonomous: true

must_haves:
  truths:
    - "app.state.customer_success is set when CustomerSuccessAgent initializes successfully"
    - "app.state.csm_scheduler is set when CSMScheduler starts successfully"
    - "Sales Agent handle_expansion_opportunity handler processes expansion task and returns draft_id"
    - "CSM check_expansion handler produces task with type=handle_expansion_opportunity dispatched to Sales Agent"
    - "Round-trip CSM→Sales expansion dispatch returns success result"
    - "CSM agent fails gracefully (no exception) when sales_agent reference is None"
  artifacts:
    - path: "tests/test_csm_wiring.py"
      provides: "main.py lifespan CSM wiring tests"
      contains: "class TestCSMWiring"
    - path: "tests/test_csm_expansion_dispatch.py"
      provides: "Bidirectional CSM→Sales expansion dispatch tests"
      contains: "class TestCSMExpansionDispatch"
  key_links:
    - from: "tests/test_csm_expansion_dispatch.py"
      to: "CustomerSuccessAgent._handle_check_expansion"
      via: "calls sales_agent.execute with handle_expansion_opportunity"
      pattern: "handle_expansion_opportunity"
    - from: "tests/test_csm_wiring.py"
      to: "src/app/main.py"
      via: "app.state.customer_success assignment check"
      pattern: "customer_success"
---

<objective>
Write the final integration tests: CSM agent wiring in main.py (app.state checks) and the bidirectional CSM→Sales expansion dispatch round-trip. This validates the architectural milestone of the first reverse-direction agent handoff.

Purpose: The expansion dispatch is architecturally novel — it's the first time a downstream agent (CSM) calls back up to the Sales Agent. These tests prove the full circuit works end-to-end.
Output: test_csm_wiring.py and test_csm_expansion_dispatch.py with full round-trip coverage.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/14-customer-success-agent/14-05-SUMMARY.md
@.planning/phases/14-customer-success-agent/14-06-SUMMARY.md
@src/app/agents/customer_success/agent.py
@src/app/agents/sales/agent.py
@src/app/main.py
@tests/test_tam_handoff.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write CSM app wiring tests</name>
  <files>
    tests/test_csm_wiring.py
  </files>
  <action>
Create tests/test_csm_wiring.py. Mirror test_tam_handoff.py structure for the wiring/state checks. Follow the same patterns used in that file for mocking app.state.

**TestCSMWiring class:**

1. **test_csm_agent_attributes_set_correctly** — Instantiate CustomerSuccessAgent with mock deps; verify self._health_scorer, self._notion_csm, self._sales_agent attributes are set correctly from constructor args.

2. **test_csm_agent_handles_none_sales_agent** — CustomerSuccessAgent(sales_agent=None); call execute({"type": "check_expansion", "account_id": "test"}, {}); should return dict without raising AttributeError (fail-open when sales_agent=None).

3. **test_csm_scheduler_has_three_jobs** — Instantiate CSMScheduler; mock APScheduler; verify start() attempts to add 3 jobs (mock scheduler.add_job call count == 3). If APScheduler unavailable, verify start() returns False without raising.

4. **test_csm_scheduler_stops_cleanly** — start() then stop(); no exception raised.

5. **test_main_py_has_phase14_block** — Read src/app/main.py source; assert "phase14" in source and "customer_success" in source and "csm_scheduler" in source.

6. **test_main_py_shutdown_stops_csm_scheduler** — Read src/app/main.py source; assert "csm_scheduler_ref" in source and ".stop()" appears after "csm_scheduler_ref" assignment.

7. **test_sales_agent_handler_registered** — Read src/app/agents/sales/agent.py source (or inspect handlers dict); assert "handle_expansion_opportunity" present.

Run: pytest tests/test_csm_wiring.py -v
  </action>
  <verify>
cd /Users/RAZER/Documents/projects/sales\ army && python -m pytest tests/test_csm_wiring.py -v 2>&1 | tail -15
  </verify>
  <done>All 7 wiring tests pass. Source inspection tests confirm Phase 14 block in main.py and handle_expansion_opportunity in Sales Agent.</done>
</task>

<task type="auto">
  <name>Task 2: Write CSM→Sales expansion dispatch round-trip tests</name>
  <files>
    tests/test_csm_expansion_dispatch.py
  </files>
  <action>
Create tests/test_csm_expansion_dispatch.py. This is the architectural validation test — proves the bidirectional handoff works end-to-end. Mirror test_tam_handoff.py round-trip test structure.

**TestCSMExpansionDispatch class:**

Setup:
```python
@pytest.fixture
def mock_gmail():
    gmail = AsyncMock()
    gmail.create_draft.return_value = type("Draft", (), {"draft_id": "draft-expand-001"})()
    return gmail

@pytest.fixture
def mock_sales_agent():
    sa = AsyncMock()
    sa.execute.return_value = {
        "task_type": "handle_expansion_opportunity",
        "account_id": "acct-001",
        "opportunity_type": "seats",
        "draft_id": "draft-sales-001",
        "confidence": "high",
    }
    return sa
```

Tests:

1. **test_expansion_opportunity_task_type** — ExpansionOpportunity model validates with opportunity_type="seats"; model.opportunity_type == "seats"

2. **test_csm_check_expansion_dispatches_correct_task_type** — Create CustomerSuccessAgent with mock LLM returning expansion JSON and mock sales_agent; run check_expansion; assert mock_sales_agent.execute.called; call_args task dict has type="handle_expansion_opportunity"

3. **test_csm_check_expansion_passes_account_id_to_sales** — Same setup; assert task passed to sales_agent.execute has account_id="acct-001"

4. **test_csm_check_expansion_passes_opportunity_type** — Assert task passed to sales_agent has opportunity_type field set from LLM response

5. **test_sales_agent_expansion_handler_creates_draft** — Directly call SalesAgent._handle_expansion_opportunity (or via execute with mock deps); assert gmail_service.create_draft.called

6. **test_sales_agent_expansion_handler_fail_open** — SalesAgent expansion handler with gmail_service that raises Exception; result has confidence="low" and "error" key, not raises

7. **test_csm_to_sales_round_trip** — Full round-trip: CSM agent receives check_expansion task → dispatches to mock Sales Agent → returns combined result; assert expansion dispatched count > 0 in result

8. **test_expansion_opportunity_invalid_type_raises** — ExpansionOpportunity(opportunity_type="enterprise") raises ValidationError

Run: pytest tests/test_csm_expansion_dispatch.py -v
  </action>
  <verify>
cd /Users/RAZER/Documents/projects/sales\ army && python -m pytest tests/test_csm_expansion_dispatch.py -v 2>&1 | tail -15
  </verify>
  <done>All 8 expansion dispatch tests pass. Round-trip test confirms CSM→Sales handoff produces correct task type. Sales Agent handler fail-open confirmed. Invalid opportunity_type rejected by Pydantic.</done>
</task>

</tasks>

<verification>
cd /Users/RAZER/Documents/projects/sales\ army && python -m pytest tests/test_csm_wiring.py tests/test_csm_expansion_dispatch.py tests/test_csm_handlers.py tests/test_csm_schemas.py tests/test_csm_health_scorer.py tests/test_csm_prompt_builders.py tests/test_csm_notion_adapter.py -v 2>&1 | tail -15
</verification>

<success_criteria>
- test_csm_wiring.py: 7 tests pass including source inspection of main.py and Sales Agent
- test_csm_expansion_dispatch.py: 8 tests pass including full round-trip CSM→Sales
- Full CSM test suite: all 7 test files (37+ tests) pass
- No test exercises real Notion API or real Gmail API (all mocked)
- test_csm_to_sales_round_trip confirms expansion dispatch produces handle_expansion_opportunity task
</success_criteria>

<output>
After completion, create `.planning/phases/14-customer-success-agent/14-07-SUMMARY.md`
</output>
