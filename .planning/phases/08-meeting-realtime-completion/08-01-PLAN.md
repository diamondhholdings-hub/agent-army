---
phase: 08-meeting-realtime-completion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/meetings/bot/manager.py
  - src/app/main.py
  - src/app/config.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "RealtimePipeline instances are created when bot enters in_call_recording state"
    - "Pipeline is stored as app.state.pipeline_{meeting_id} and discoverable by WebSocket handler"
    - "Pipeline is cleaned up (removed from app.state) when call_ended event fires"
    - "BotManager receives all API keys and services needed to construct pipelines"
  artifacts:
    - path: "src/app/meetings/bot/manager.py"
      provides: "Pipeline factory method and lifecycle management in BotManager"
      contains: "_create_pipeline_for_meeting"
    - path: "src/app/main.py"
      provides: "Updated BotManager instantiation passing API keys, llm_service, and app_state"
      contains: "deepgram_api_key"
    - path: "src/app/config.py"
      provides: "MEETING_BOT_NAME, COMPANY_NAME, RECALL_AI_WEBHOOK_TOKEN settings"
      contains: "MEETING_BOT_NAME"
  key_links:
    - from: "src/app/main.py"
      to: "src/app/meetings/bot/manager.py"
      via: "BotManager constructor receives API keys, llm_service, app_state"
      pattern: "BotManager\\(.*deepgram_api_key"
    - from: "src/app/meetings/bot/manager.py"
      to: "src/app/meetings/realtime/pipeline.py"
      via: "handle_bot_event creates RealtimePipeline on in_call_recording"
      pattern: "RealtimePipeline\\("
    - from: "src/app/meetings/bot/manager.py"
      to: "app.state.pipeline_{meeting_id}"
      via: "setattr on in_call_recording, delattr on call_ended"
      pattern: "setattr.*pipeline_"
---

<objective>
Wire RealtimePipeline instantiation into the bot lifecycle so that when a Recall.ai bot enters a meeting (in_call_recording event), a fully configured pipeline is created and stored on app.state where the WebSocket handler expects it.

Purpose: Close Gap 1 from the v1 milestone audit -- the WebSocket endpoint at meetings.py:642-646 reads app.state.pipeline_{meeting_id} but nothing creates it, making real-time conversation non-functional.

Output: Updated BotManager with pipeline factory, updated main.py with proper BotManager initialization, missing config settings added.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/app/meetings/bot/manager.py
@src/app/meetings/realtime/pipeline.py
@src/app/main.py
@src/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add missing config settings and update BotManager with pipeline factory</name>
  <files>
    src/app/config.py
    src/app/meetings/bot/manager.py
  </files>
  <action>
**Step 1: Add missing settings to src/app/config.py**

Add three settings to the Settings class (after line 74, after MEETING_BOT_WEBAPP_URL):
```python
MEETING_BOT_NAME: str = "Sales Agent"  # Bot display name in meetings
COMPANY_NAME: str = ""  # Company name for entrance greeting
RECALL_AI_WEBHOOK_TOKEN: str = ""  # Optional webhook validation token
```

These are referenced by BotManager._send_entrance_greeting via getattr with defaults, and by the webhook handler. Adding them to Settings makes them configurable via .env.

**Step 2: Update BotManager in src/app/meetings/bot/manager.py**

2a. Update constructor signature (lines 61-71). Add new parameters for pipeline creation:
```python
def __init__(
    self,
    recall_client: RecallClient,
    repository: MeetingRepository,
    settings: object,
    tts_client: ElevenLabsTTS | None = None,
    # Pipeline factory dependencies (Phase 8 gap closure)
    deepgram_api_key: str = "",
    elevenlabs_api_key: str = "",
    elevenlabs_voice_id: str = "",
    heygen_api_key: str = "",
    heygen_avatar_id: str = "",
    llm_service: Any = None,
    app_state: Any = None,
) -> None:
    self._recall = recall_client
    self._repository = repository
    self._settings = settings
    self._tts = tts_client
    # Pipeline factory state
    self._deepgram_api_key = deepgram_api_key
    self._elevenlabs_api_key = elevenlabs_api_key
    self._elevenlabs_voice_id = elevenlabs_voice_id
    self._heygen_api_key = heygen_api_key
    self._heygen_avatar_id = heygen_avatar_id
    self._llm_service = llm_service
    self._app_state = app_state
    self._active_pipelines: dict[str, Any] = {}
```

Add `from typing import Any` to the existing TYPE_CHECKING imports at the top (or to the regular imports since it's used at runtime for type hints).

2b. Add pipeline factory method after the existing `_build_output_media_url` method (after line 403):
```python
async def _create_pipeline_for_meeting(
    self, meeting: Meeting, tenant_id: str
) -> Any | None:
    """Create a RealtimePipeline for a meeting that just started recording.

    Instantiates all real-time components (STT, TTS, Avatar, SilenceChecker)
    using stored API keys, then builds the pipeline with meeting context.

    Returns None if any required API key is missing (graceful degradation).
    """
    if not all([self._deepgram_api_key, self._elevenlabs_api_key, self._llm_service]):
        logger.warning(
            "pipeline.creation_skipped",
            meeting_id=str(meeting.id),
            reason="missing_api_keys_or_llm_service",
        )
        return None

    try:
        from src.app.meetings.realtime.stt import DeepgramSTT
        from src.app.meetings.realtime.tts import ElevenLabsTTS
        from src.app.meetings.realtime.avatar import HeyGenAvatar
        from src.app.meetings.realtime.silence_checker import SilenceChecker
        from src.app.meetings.realtime.turn_detector import TurnDetector
        from src.app.meetings.realtime.pipeline import RealtimePipeline

        stt_client = DeepgramSTT(api_key=self._deepgram_api_key)
        tts_client = ElevenLabsTTS(
            api_key=self._elevenlabs_api_key,
            voice_id=self._elevenlabs_voice_id,
        )
        avatar_client = HeyGenAvatar(
            api_key=self._heygen_api_key,
            avatar_id=self._heygen_avatar_id,
        ) if self._heygen_api_key else None

        turn_detector = TurnDetector()
        # Build participant roles from meeting participants
        from src.app.meetings.schemas import ParticipantRole
        participant_roles: dict[str, ParticipantRole] = {}
        if hasattr(meeting, "participants") and meeting.participants:
            for p in meeting.participants:
                participant_roles[p.email] = p.role

        silence_checker = SilenceChecker(
            turn_detector=turn_detector,
            participant_roles=participant_roles,
        )

        # Build meeting context dict for pipeline
        meeting_context = {
            "meeting_id": str(meeting.id),
            "title": meeting.title,
            "tenant_id": tenant_id,
            "participants": [
                {"name": p.name, "email": p.email, "role": p.role.value}
                for p in (meeting.participants or [])
            ],
        }

        pipeline = RealtimePipeline(
            stt_client=stt_client,
            tts_client=tts_client,
            avatar_client=avatar_client or MagicMock(),  # Avoid: use a no-op stub instead
            silence_checker=silence_checker,
            llm_service=self._llm_service,
            meeting_context=meeting_context,
        )

        logger.info(
            "pipeline.created",
            meeting_id=str(meeting.id),
            tenant_id=tenant_id,
            has_avatar=avatar_client is not None,
        )
        return pipeline

    except Exception:
        logger.warning(
            "pipeline.creation_failed",
            meeting_id=str(meeting.id),
            exc_info=True,
        )
        return None
```

IMPORTANT: Do NOT use MagicMock for the avatar fallback. Instead, if heygen_api_key is empty, still create HeyGenAvatar with empty key -- it will fail gracefully at runtime when speak() is called. OR create a minimal NoOpAvatar stub inline:
```python
class _NoOpAvatar:
    async def speak(self, *a, **kw): pass
    async def react(self, *a, **kw): pass
    async def stop(self): pass

avatar_client = HeyGenAvatar(...) if self._heygen_api_key else _NoOpAvatar()
```

2c. Update `handle_bot_event` method. In the `in_call_recording` branch (after line 247, after `_send_entrance_greeting`), add pipeline creation:
```python
# Create real-time pipeline for this meeting
pipeline = await self._create_pipeline_for_meeting(meeting, tenant_id)
if pipeline is not None:
    self._active_pipelines[str(meeting.id)] = pipeline
    # Store on app.state where WebSocket handler expects it
    if self._app_state is not None:
        setattr(self._app_state, f"pipeline_{meeting.id}", pipeline)
    logger.info(
        "pipeline.stored_on_app_state",
        meeting_id=str(meeting.id),
        attr_name=f"pipeline_{meeting.id}",
    )
```

In the `call_ended` branch (after line 255, after the status update), add cleanup:
```python
# Clean up real-time pipeline
meeting_id_str = str(meeting.id)
pipeline = self._active_pipelines.pop(meeting_id_str, None)
if pipeline is not None:
    try:
        if hasattr(pipeline, "shutdown"):
            await pipeline.shutdown()
    except Exception:
        logger.warning(
            "pipeline.shutdown_error",
            meeting_id=meeting_id_str,
            exc_info=True,
        )
    # Remove from app.state
    if self._app_state is not None:
        try:
            delattr(self._app_state, f"pipeline_{meeting.id}")
        except AttributeError:
            pass
    logger.info("pipeline.cleaned_up", meeting_id=meeting_id_str)
```

2d. Fix `_find_meeting_by_bot_id`: Currently returns None always (line 423). Update to use repository lookup:
```python
async def _find_meeting_by_bot_id(self, bot_id: str) -> Meeting | None:
    """Find meeting by its Recall.ai bot ID."""
    logger.debug("bot.find_by_bot_id", bot_id=bot_id)
    try:
        meeting = await self._repository.get_meeting_by_bot_id(bot_id)
        return meeting
    except Exception:
        logger.warning("bot.find_by_bot_id_failed", bot_id=bot_id, exc_info=True)
        return None
```

Check if MeetingRepository has `get_meeting_by_bot_id`. If not, it may need to be added (check the repository first). If it only has `update_meeting_bot_id`, the lookup may need to iterate. In that case, add a simple `get_meeting_by_bot_id(bot_id: str) -> Meeting | None` to MeetingRepository that queries WHERE bot_id = :bot_id.
  </action>
  <verify>
    python -c "from src.app.meetings.bot.manager import BotManager; print('BotManager imports OK')"
    python -c "from src.app.config import get_settings; s = get_settings(); print(f'MEETING_BOT_NAME={s.MEETING_BOT_NAME}')"
    grep -n "_create_pipeline_for_meeting" src/app/meetings/bot/manager.py
    grep -n "pipeline_" src/app/meetings/bot/manager.py | head -10
  </verify>
  <done>
    BotManager has _create_pipeline_for_meeting factory method. handle_bot_event creates pipeline on in_call_recording and stores on app.state. handle_bot_event cleans up pipeline on call_ended. Config has MEETING_BOT_NAME, COMPANY_NAME, RECALL_AI_WEBHOOK_TOKEN. _find_meeting_by_bot_id uses repository lookup instead of returning None.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update main.py BotManager instantiation to pass pipeline dependencies</name>
  <files>
    src/app/main.py
    .env.example
  </files>
  <action>
**Step 1: Update BotManager construction in main.py**

In the Phase 6 section (lines 319-324), update BotManager instantiation to pass all pipeline factory dependencies:

Current code:
```python
bot_manager = BotManager(
    recall_client=recall_client,
    repository=meeting_repo,
    settings=settings,
)
```

Replace with:
```python
bot_manager = BotManager(
    recall_client=recall_client,
    repository=meeting_repo,
    settings=settings,
    tts_client=None,  # TTS for entrance greeting; created lazily in pipeline
    deepgram_api_key=settings.DEEPGRAM_API_KEY,
    elevenlabs_api_key=settings.ELEVENLABS_API_KEY,
    elevenlabs_voice_id=settings.ELEVENLABS_VOICE_ID,
    heygen_api_key=settings.HEYGEN_API_KEY,
    heygen_avatar_id=settings.HEYGEN_AVATAR_ID,
    llm_service=llm_service,
    app_state=app.state,
)
```

Note: `llm_service` is already available at this point (line 302: `llm_service = getattr(app.state, "llm_service", None)`).

Also consider creating a TTS client for the entrance greeting. Add BEFORE the BotManager construction:
```python
# TTS client for entrance greeting (best-effort)
_tts_client = None
if settings.ELEVENLABS_API_KEY:
    try:
        from src.app.meetings.realtime.tts import ElevenLabsTTS
        _tts_client = ElevenLabsTTS(
            api_key=settings.ELEVENLABS_API_KEY,
            voice_id=settings.ELEVENLABS_VOICE_ID,
        )
    except Exception:
        log.warning("phase6.tts_client_init_failed", exc_info=True)
```

Then pass `tts_client=_tts_client` instead of `tts_client=None`.

**Step 2: Update .env.example**

Add the following entries after the existing Meeting Capabilities section (after line 48 or wherever the .env.example ends):

```
# Meeting Capabilities (Phase 6)
RECALL_AI_API_KEY=
RECALL_AI_REGION=us-west-2
DEEPGRAM_API_KEY=
ELEVENLABS_API_KEY=
ELEVENLABS_VOICE_ID=
HEYGEN_API_KEY=
HEYGEN_AVATAR_ID=
MEETING_BOT_WEBAPP_URL=  # URL where Output Media webapp is deployed (e.g., https://your-app.vercel.app)
MEETING_BOT_NAME=Sales Agent
COMPANY_NAME=
RECALL_AI_WEBHOOK_TOKEN=  # Optional: validates incoming Recall.ai webhooks
```

Only add entries that are NOT already present in .env.example. Check existing content first and append only new ones.

**Step 3: Verify the wiring**

After changes, confirm:
- BotManager receives app.state reference
- BotManager receives all 5 API keys
- BotManager receives llm_service
- TTS client passed for entrance greeting
  </action>
  <verify>
    grep -n "deepgram_api_key" src/app/main.py
    grep -n "app_state" src/app/main.py | grep -i bot
    grep -n "MEETING_BOT_NAME" .env.example
    python -c "from src.app.main import create_app; print('main.py imports OK')"
  </verify>
  <done>
    main.py creates BotManager with all pipeline dependencies (5 API keys, llm_service, app.state reference, TTS client). .env.example documents all meeting-related environment variables including MEETING_BOT_NAME, COMPANY_NAME, and RECALL_AI_WEBHOOK_TOKEN.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.app.meetings.bot.manager import BotManager; print('OK')"` -- BotManager module loads
2. `python -c "from src.app.config import get_settings; s = get_settings(); assert hasattr(s, 'MEETING_BOT_NAME')"` -- Config has new settings
3. `grep -c "pipeline_" src/app/meetings/bot/manager.py` -- Multiple references to pipeline storage
4. `grep "setattr.*pipeline_" src/app/meetings/bot/manager.py` -- Pipeline stored on app.state
5. `grep "delattr.*pipeline_" src/app/meetings/bot/manager.py` -- Pipeline cleaned up
6. `grep "deepgram_api_key" src/app/main.py` -- BotManager receives API keys
7. `python -m pytest tests/test_meeting_foundation.py tests/test_meeting_integration.py -x --timeout=30` -- Existing tests still pass
</verification>

<success_criteria>
- BotManager._create_pipeline_for_meeting() creates a fully configured RealtimePipeline
- handle_bot_event stores pipeline as app.state.pipeline_{meeting_id} on in_call_recording
- handle_bot_event removes pipeline from app.state on call_ended
- main.py passes all 5 API keys, llm_service, and app.state to BotManager
- Config has MEETING_BOT_NAME, COMPANY_NAME, RECALL_AI_WEBHOOK_TOKEN
- All existing meeting tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-meeting-realtime-completion/08-01-SUMMARY.md`
</output>
