---
phase: 08-meeting-realtime-completion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/meetings/bot/manager.py
  - src/app/meetings/repository.py
  - src/app/main.py
  - src/app/config.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "RealtimePipeline instances are created when bot enters in_call_recording state"
    - "Pipeline is stored as app.state.pipeline_{meeting_id} and discoverable by WebSocket handler"
    - "Pipeline is cleaned up (removed from app.state) when call_ended event fires"
    - "BotManager receives all API keys and services needed to construct pipelines"
    - "MeetingRepository.get_meeting_by_bot_id returns a Meeting for cross-tenant bot_id lookup"
  artifacts:
    - path: "src/app/meetings/bot/manager.py"
      provides: "Pipeline factory method and lifecycle management in BotManager"
      contains: "_create_pipeline_for_meeting"
    - path: "src/app/meetings/repository.py"
      provides: "Cross-tenant bot_id lookup method"
      contains: "get_meeting_by_bot_id"
    - path: "src/app/main.py"
      provides: "Updated BotManager instantiation passing API keys, llm_service, and app_state"
      contains: "deepgram_api_key"
    - path: "src/app/config.py"
      provides: "MEETING_BOT_NAME, COMPANY_NAME, RECALL_AI_WEBHOOK_TOKEN settings"
      contains: "MEETING_BOT_NAME"
  key_links:
    - from: "src/app/main.py"
      to: "src/app/meetings/bot/manager.py"
      via: "BotManager constructor receives API keys, llm_service, app_state"
      pattern: "BotManager\\(.*deepgram_api_key"
    - from: "src/app/meetings/bot/manager.py"
      to: "src/app/meetings/realtime/pipeline.py"
      via: "handle_bot_event creates RealtimePipeline on in_call_recording"
      pattern: "RealtimePipeline\\("
    - from: "src/app/meetings/bot/manager.py"
      to: "app.state.pipeline_{meeting_id}"
      via: "setattr on in_call_recording, delattr on call_ended"
      pattern: "setattr.*pipeline_"
    - from: "src/app/meetings/bot/manager.py"
      to: "src/app/meetings/repository.py"
      via: "_find_meeting_by_bot_id calls repository.get_meeting_by_bot_id"
      pattern: "get_meeting_by_bot_id"
---

<objective>
Wire RealtimePipeline instantiation into the bot lifecycle so that when a Recall.ai bot enters a meeting (in_call_recording event), a fully configured pipeline is created and stored on app.state where the WebSocket handler expects it.

Purpose: Close Gap 1 from the v1 milestone audit -- the WebSocket endpoint at meetings.py:642-646 reads app.state.pipeline_{meeting_id} but nothing creates it, making real-time conversation non-functional.

Output: Updated BotManager with pipeline factory, updated main.py with proper BotManager initialization, missing config settings added, cross-tenant get_meeting_by_bot_id repository method.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/app/meetings/bot/manager.py
@src/app/meetings/realtime/pipeline.py
@src/app/meetings/repository.py
@src/app/main.py
@src/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add missing config settings and update BotManager with pipeline factory</name>
  <files>
    src/app/config.py
    src/app/meetings/bot/manager.py
  </files>
  <action>
**Step 1: Add missing settings to src/app/config.py**

Add three settings to the Settings class (after line 74, after MEETING_BOT_WEBAPP_URL):
```python
MEETING_BOT_NAME: str = "Sales Agent"  # Bot display name in meetings
COMPANY_NAME: str = ""  # Company name for entrance greeting
RECALL_AI_WEBHOOK_TOKEN: str = ""  # Optional webhook validation token
```

These are referenced by BotManager._send_entrance_greeting via getattr with defaults, and by the webhook handler. Adding them to Settings makes them configurable via .env.

**Step 2: Update BotManager in src/app/meetings/bot/manager.py**

2a. Update constructor signature (lines 61-71). Add new parameters for pipeline creation:
```python
def __init__(
    self,
    recall_client: RecallClient,
    repository: MeetingRepository,
    settings: object,
    tts_client: ElevenLabsTTS | None = None,
    # Pipeline factory dependencies (Phase 8 gap closure)
    deepgram_api_key: str = "",
    elevenlabs_api_key: str = "",
    elevenlabs_voice_id: str = "",
    heygen_api_key: str = "",
    heygen_avatar_id: str = "",
    llm_service: Any = None,
    app_state: Any = None,
) -> None:
    self._recall = recall_client
    self._repository = repository
    self._settings = settings
    self._tts = tts_client
    # Pipeline factory state
    self._deepgram_api_key = deepgram_api_key
    self._elevenlabs_api_key = elevenlabs_api_key
    self._elevenlabs_voice_id = elevenlabs_voice_id
    self._heygen_api_key = heygen_api_key
    self._heygen_avatar_id = heygen_avatar_id
    self._llm_service = llm_service
    self._app_state = app_state
    self._active_pipelines: dict[str, Any] = {}
```

Add `from typing import Any` to the existing TYPE_CHECKING imports at the top (or to the regular imports since it's used at runtime for type hints).

2b. Add a no-op avatar stub class BEFORE the BotManager class definition (at module level):
```python
class _NoOpAvatar:
    """Stub avatar when HeyGen API key is not configured."""
    async def speak(self, *a: Any, **kw: Any) -> None: pass
    async def react(self, *a: Any, **kw: Any) -> None: pass
    async def stop(self) -> None: pass
```

2c. Add pipeline factory method after the existing `_build_output_media_url` method (after line 403):
```python
async def _create_pipeline_for_meeting(
    self, meeting: Meeting, tenant_id: str
) -> Any | None:
    """Create a RealtimePipeline for a meeting that just started recording.

    Instantiates all real-time components (STT, TTS, Avatar, SilenceChecker)
    using stored API keys, then builds the pipeline with meeting context.

    Returns None if any required API key is missing (graceful degradation).
    """
    if not all([self._deepgram_api_key, self._elevenlabs_api_key, self._llm_service]):
        logger.warning(
            "pipeline.creation_skipped",
            meeting_id=str(meeting.id),
            reason="missing_api_keys_or_llm_service",
        )
        return None

    try:
        from src.app.meetings.realtime.stt import DeepgramSTT
        from src.app.meetings.realtime.tts import ElevenLabsTTS
        from src.app.meetings.realtime.avatar import HeyGenAvatar
        from src.app.meetings.realtime.silence_checker import SilenceChecker
        from src.app.meetings.realtime.turn_detector import TurnDetector
        from src.app.meetings.realtime.pipeline import RealtimePipeline

        stt_client = DeepgramSTT(api_key=self._deepgram_api_key)
        tts_client = ElevenLabsTTS(
            api_key=self._elevenlabs_api_key,
            voice_id=self._elevenlabs_voice_id,
        )
        # Use _NoOpAvatar stub when HeyGen key is not configured
        avatar_client = HeyGenAvatar(
            api_key=self._heygen_api_key,
            avatar_id=self._heygen_avatar_id,
        ) if self._heygen_api_key else _NoOpAvatar()

        turn_detector = TurnDetector()
        # Build participant roles from meeting participants
        from src.app.meetings.schemas import ParticipantRole
        participant_roles: dict[str, ParticipantRole] = {}
        if hasattr(meeting, "participants") and meeting.participants:
            for p in meeting.participants:
                participant_roles[p.email] = p.role

        silence_checker = SilenceChecker(
            turn_detector=turn_detector,
            participant_roles=participant_roles,
        )

        # Build meeting context dict for pipeline
        meeting_context = {
            "meeting_id": str(meeting.id),
            "title": meeting.title,
            "tenant_id": tenant_id,
            "participants": [
                {"name": p.name, "email": p.email, "role": p.role.value}
                for p in (meeting.participants or [])
            ],
        }

        pipeline = RealtimePipeline(
            stt_client=stt_client,
            tts_client=tts_client,
            avatar_client=avatar_client,
            silence_checker=silence_checker,
            llm_service=self._llm_service,
            meeting_context=meeting_context,
        )

        logger.info(
            "pipeline.created",
            meeting_id=str(meeting.id),
            tenant_id=tenant_id,
            has_avatar=self._heygen_api_key != "",
        )
        return pipeline

    except Exception:
        logger.warning(
            "pipeline.creation_failed",
            meeting_id=str(meeting.id),
            exc_info=True,
        )
        return None
```

2d. Update `handle_bot_event` method. In the `in_call_recording` branch (after line 247, after `_send_entrance_greeting`), add pipeline creation:
```python
# Create real-time pipeline for this meeting
pipeline = await self._create_pipeline_for_meeting(meeting, tenant_id)
if pipeline is not None:
    self._active_pipelines[str(meeting.id)] = pipeline
    # Store on app.state where WebSocket handler expects it
    # Note: meeting.id is a uuid.UUID; str(uuid.UUID) produces the standard
    # hyphenated format "xxxxxxxx-xxxx-..." which matches what
    # _build_output_media_url passes as the meeting_id query param and what
    # the WebSocket endpoint receives as its path parameter.
    # (Roundtrip correctness verified by 08-03 test 7.)
    if self._app_state is not None:
        setattr(self._app_state, f"pipeline_{meeting.id}", pipeline)
    logger.info(
        "pipeline.stored_on_app_state",
        meeting_id=str(meeting.id),
        attr_name=f"pipeline_{meeting.id}",
    )
```

In the `call_ended` branch (after line 255, after the status update), add cleanup:
```python
# Clean up real-time pipeline
meeting_id_str = str(meeting.id)
pipeline = self._active_pipelines.pop(meeting_id_str, None)
if pipeline is not None:
    try:
        if hasattr(pipeline, "shutdown"):
            await pipeline.shutdown()
    except Exception:
        logger.warning(
            "pipeline.shutdown_error",
            meeting_id=meeting_id_str,
            exc_info=True,
        )
    # Remove from app.state
    if self._app_state is not None:
        try:
            delattr(self._app_state, f"pipeline_{meeting.id}")
        except AttributeError:
            pass
    logger.info("pipeline.cleaned_up", meeting_id=meeting_id_str)
```

2e. Fix `_find_meeting_by_bot_id`: Currently returns None always (line 423). Update to use repository lookup:
```python
async def _find_meeting_by_bot_id(self, bot_id: str) -> Meeting | None:
    """Find meeting by its Recall.ai bot ID."""
    logger.debug("bot.find_by_bot_id", bot_id=bot_id)
    try:
        meeting = await self._repository.get_meeting_by_bot_id(bot_id)
        return meeting
    except Exception:
        logger.warning("bot.find_by_bot_id_failed", bot_id=bot_id, exc_info=True)
        return None
```

This depends on Task 3 adding `get_meeting_by_bot_id` to MeetingRepository.
  </action>
  <verify>
    python -c "from src.app.meetings.bot.manager import BotManager; print('BotManager imports OK')"
    python -c "from src.app.config import get_settings; s = get_settings(); print(f'MEETING_BOT_NAME={s.MEETING_BOT_NAME}')"
    grep -n "_create_pipeline_for_meeting" src/app/meetings/bot/manager.py
    grep -n "pipeline_" src/app/meetings/bot/manager.py | head -10
    grep -n "_NoOpAvatar" src/app/meetings/bot/manager.py
  </verify>
  <done>
    BotManager has _create_pipeline_for_meeting factory method using _NoOpAvatar stub (not MagicMock) for avatar fallback. handle_bot_event creates pipeline on in_call_recording and stores on app.state with a comment documenting UUID string format roundtrip. handle_bot_event cleans up pipeline on call_ended. Config has MEETING_BOT_NAME, COMPANY_NAME, RECALL_AI_WEBHOOK_TOKEN. _find_meeting_by_bot_id uses repository lookup instead of returning None.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update main.py BotManager instantiation to pass pipeline dependencies</name>
  <files>
    src/app/main.py
    .env.example
  </files>
  <action>
**Step 1: Update BotManager construction in main.py**

In the Phase 6 section (lines 319-324), update BotManager instantiation to pass all pipeline factory dependencies:

Current code:
```python
bot_manager = BotManager(
    recall_client=recall_client,
    repository=meeting_repo,
    settings=settings,
)
```

Replace with:
```python
bot_manager = BotManager(
    recall_client=recall_client,
    repository=meeting_repo,
    settings=settings,
    tts_client=None,  # TTS for entrance greeting; created lazily in pipeline
    deepgram_api_key=settings.DEEPGRAM_API_KEY,
    elevenlabs_api_key=settings.ELEVENLABS_API_KEY,
    elevenlabs_voice_id=settings.ELEVENLABS_VOICE_ID,
    heygen_api_key=settings.HEYGEN_API_KEY,
    heygen_avatar_id=settings.HEYGEN_AVATAR_ID,
    llm_service=llm_service,
    app_state=app.state,
)
```

Note: `llm_service` is already available at this point (line 302: `llm_service = getattr(app.state, "llm_service", None)`).

Also consider creating a TTS client for the entrance greeting. Add BEFORE the BotManager construction:
```python
# TTS client for entrance greeting (best-effort)
_tts_client = None
if settings.ELEVENLABS_API_KEY:
    try:
        from src.app.meetings.realtime.tts import ElevenLabsTTS
        _tts_client = ElevenLabsTTS(
            api_key=settings.ELEVENLABS_API_KEY,
            voice_id=settings.ELEVENLABS_VOICE_ID,
        )
    except Exception:
        log.warning("phase6.tts_client_init_failed", exc_info=True)
```

Then pass `tts_client=_tts_client` instead of `tts_client=None`.

**Step 2: Update .env.example**

Add the following entries after the existing Meeting Capabilities section (after line 48 or wherever the .env.example ends):

```
# Meeting Capabilities (Phase 6)
RECALL_AI_API_KEY=
RECALL_AI_REGION=us-west-2
DEEPGRAM_API_KEY=
ELEVENLABS_API_KEY=
ELEVENLABS_VOICE_ID=
HEYGEN_API_KEY=
HEYGEN_AVATAR_ID=
MEETING_BOT_WEBAPP_URL=  # URL where Output Media webapp is deployed (e.g., https://your-app.vercel.app)
MEETING_BOT_NAME=Sales Agent
COMPANY_NAME=
RECALL_AI_WEBHOOK_TOKEN=  # Optional: validates incoming Recall.ai webhooks
```

Only add entries that are NOT already present in .env.example. Check existing content first and append only new ones.

**Step 3: Verify the wiring**

After changes, confirm:
- BotManager receives app.state reference
- BotManager receives all 5 API keys
- BotManager receives llm_service
- TTS client passed for entrance greeting
  </action>
  <verify>
    grep -n "deepgram_api_key" src/app/main.py
    grep -n "app_state" src/app/main.py | grep -i bot
    grep -n "MEETING_BOT_NAME" .env.example
    python -c "from src.app.main import create_app; print('main.py imports OK')"
  </verify>
  <done>
    main.py creates BotManager with all pipeline dependencies (5 API keys, llm_service, app.state reference, TTS client). .env.example documents all meeting-related environment variables including MEETING_BOT_NAME, COMPANY_NAME, and RECALL_AI_WEBHOOK_TOKEN.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add get_meeting_by_bot_id to MeetingRepository</name>
  <files>
    src/app/meetings/repository.py
  </files>
  <action>
Add a new method `get_meeting_by_bot_id` to the MeetingRepository class. This is a **cross-tenant** query because at webhook time we only know the bot_id -- not the tenant_id.

Place it after the existing `get_meeting_by_event_id` method (around line 207). Follow the exact same session_factory pattern used by the other methods:

```python
async def get_meeting_by_bot_id(self, bot_id: str) -> Meeting | None:
    """Get a meeting by its Recall.ai bot ID (cross-tenant lookup).

    Unlike other repository methods, this does NOT filter by tenant_id
    because the Recall.ai webhook only provides the bot_id -- the tenant
    is not known until the meeting is found.

    Args:
        bot_id: Recall.ai bot UUID string.

    Returns:
        Meeting if found, None otherwise.
    """
    async for session in self._session_factory():
        stmt = select(MeetingModel).where(
            MeetingModel.bot_id == bot_id,
        )
        result = await session.execute(stmt)
        model = result.scalar_one_or_none()
        if model is None:
            return None
        return _model_to_meeting(model)
```

Key design decisions:
- No tenant_id filter: bot_id is globally unique (assigned by Recall.ai) so cross-tenant query is safe.
- Single result expected: Each bot_id maps to exactly one meeting (Recall creates one bot per meeting join).
- Uses scalar_one_or_none: Will raise if somehow multiple meetings have the same bot_id (data integrity check).
  </action>
  <verify>
    python -c "from src.app.meetings.repository import MeetingRepository; assert hasattr(MeetingRepository, 'get_meeting_by_bot_id'); print('get_meeting_by_bot_id exists')"
    grep -n "get_meeting_by_bot_id" src/app/meetings/repository.py
    grep -n "bot_id" src/app/meetings/repository.py
  </verify>
  <done>
    MeetingRepository has get_meeting_by_bot_id(bot_id: str) method that performs a cross-tenant query (no tenant_id filter) matching on MeetingModel.bot_id column. Method follows the existing session_factory pattern and returns Meeting | None.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.app.meetings.bot.manager import BotManager; print('OK')"` -- BotManager module loads
2. `python -c "from src.app.config import get_settings; s = get_settings(); assert hasattr(s, 'MEETING_BOT_NAME')"` -- Config has new settings
3. `grep -c "pipeline_" src/app/meetings/bot/manager.py` -- Multiple references to pipeline storage
4. `grep "setattr.*pipeline_" src/app/meetings/bot/manager.py` -- Pipeline stored on app.state
5. `grep "delattr.*pipeline_" src/app/meetings/bot/manager.py` -- Pipeline cleaned up
6. `grep "deepgram_api_key" src/app/main.py` -- BotManager receives API keys
7. `python -c "from src.app.meetings.repository import MeetingRepository; assert hasattr(MeetingRepository, 'get_meeting_by_bot_id')"` -- Repository has cross-tenant lookup
8. `grep "_NoOpAvatar" src/app/meetings/bot/manager.py` -- No-op avatar stub used (not MagicMock)
9. `python -m pytest tests/test_meeting_foundation.py tests/test_meeting_integration.py -x --timeout=30` -- Existing tests still pass
</verification>

<success_criteria>
- BotManager._create_pipeline_for_meeting() creates a fully configured RealtimePipeline using _NoOpAvatar (not MagicMock) as avatar fallback
- handle_bot_event stores pipeline as app.state.pipeline_{meeting_id} on in_call_recording
- handle_bot_event removes pipeline from app.state on call_ended
- main.py passes all 5 API keys, llm_service, and app.state to BotManager
- Config has MEETING_BOT_NAME, COMPANY_NAME, RECALL_AI_WEBHOOK_TOKEN
- MeetingRepository.get_meeting_by_bot_id performs cross-tenant bot_id lookup
- UUID string format roundtrip is documented (comment in code, verified by 08-03 test 7)
- All existing meeting tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-meeting-realtime-completion/08-01-SUMMARY.md`
</output>
