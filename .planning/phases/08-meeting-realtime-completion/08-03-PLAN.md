---
phase: 08-meeting-realtime-completion
plan: 03
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - src/app/main.py
  - src/app/meetings/calendar/monitor.py
  - tests/test_meeting_realtime_wiring.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "CalendarMonitor background task is started in main.py lifespan and polls every 15 minutes"
    - "CalendarMonitor task is cancelled gracefully during app shutdown"
    - "Integration test verifies: bot join event -> pipeline creation -> app.state storage -> WebSocket finds pipeline -> cleanup on leave"
    - "POLL_INTERVAL_SECONDS is 900 (15 minutes per roadmap)"
  artifacts:
    - path: "src/app/main.py"
      provides: "CalendarMonitor background task startup and shutdown"
      contains: "calendar_monitor_task"
    - path: "src/app/meetings/calendar/monitor.py"
      provides: "Updated POLL_INTERVAL_SECONDS to 900"
      contains: "POLL_INTERVAL_SECONDS = 900"
    - path: "tests/test_meeting_realtime_wiring.py"
      provides: "Integration tests for pipeline lifecycle and calendar monitor"
      exports: ["test_pipeline_created_on_bot_join", "test_pipeline_cleaned_on_call_ended", "test_websocket_finds_pipeline"]
  key_links:
    - from: "src/app/main.py"
      to: "src/app/meetings/calendar/monitor.py"
      via: "asyncio.create_task(calendar_monitor.run_poll_loop(...))"
      pattern: "create_task.*run_poll_loop"
    - from: "src/app/main.py shutdown"
      to: "calendar_monitor_task"
      via: "task.cancel() in shutdown section"
      pattern: "calendar_monitor_task.*cancel"
    - from: "tests/test_meeting_realtime_wiring.py"
      to: "src/app/meetings/bot/manager.py"
      via: "Tests BotManager.handle_bot_event pipeline lifecycle"
      pattern: "handle_bot_event.*in_call_recording"
---

<objective>
Start CalendarMonitor as a background task in main.py and write integration tests verifying the complete real-time pipeline lifecycle (bot join -> pipeline creation -> WebSocket discovery -> cleanup).

Purpose: Close Gap 3 (CalendarMonitor never started) and provide integration test coverage for Gap 1 fix. The roadmap success criteria require: CalendarMonitor polls every 15 minutes, and integration test verifies end-to-end flow.

Output: Background task wiring in main.py, updated poll interval, comprehensive integration tests.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-meeting-realtime-completion/08-01-SUMMARY.md
@src/app/main.py
@src/app/meetings/calendar/monitor.py
@src/app/meetings/bot/manager.py
@tests/test_meeting_integration.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Start CalendarMonitor background task and update poll interval</name>
  <files>
    src/app/meetings/calendar/monitor.py
    src/app/main.py
  </files>
  <action>
**Step 1: Update POLL_INTERVAL_SECONDS in src/app/meetings/calendar/monitor.py**

Change line 43 from:
```python
POLL_INTERVAL_SECONDS = 60
```
to:
```python
POLL_INTERVAL_SECONDS = 900  # 15 minutes per roadmap
```

**Step 2: Start CalendarMonitor background task in src/app/main.py**

In the Phase 6 section, AFTER the calendar_monitor is stored on app.state (after line 369 `log.info("phase6.calendar_monitor_ready")`), add:

```python
# Start calendar monitoring background task
import asyncio as _asyncio_p6

if calendar_monitor and settings.GOOGLE_DELEGATED_USER_EMAIL:
    try:
        _monitor_task = _asyncio_p6.create_task(
            calendar_monitor.run_poll_loop(
                agent_email=settings.GOOGLE_DELEGATED_USER_EMAIL,
                tenant_id="system",
            ),
            name="calendar_monitor_poll",
        )
        app.state.calendar_monitor_task = _monitor_task
        log.info(
            "phase6.calendar_monitor_started",
            agent_email=settings.GOOGLE_DELEGATED_USER_EMAIL,
            poll_interval_seconds=900,
        )
    except Exception:
        log.warning("phase6.calendar_monitor_start_failed", exc_info=True)
        app.state.calendar_monitor_task = None
else:
    app.state.calendar_monitor_task = None
```

Note: `asyncio` may already be imported at the top of main.py. Check first -- if it's already imported, use `asyncio.create_task` directly instead of the aliased import. The alias `_asyncio_p6` is to avoid conflicts with any existing local variable naming.

**Step 3: Add CalendarMonitor task cleanup to shutdown section**

In the Shutdown section (around line 480), AFTER the Phase 4.1 scheduler cleanup and BEFORE the Phase 7 intelligence scheduler cleanup, add:

```python
# Clean up Phase 6 calendar monitor task
calendar_monitor_task = getattr(app.state, "calendar_monitor_task", None)
if calendar_monitor_task and not calendar_monitor_task.done():
    # Signal the monitor to stop its loop
    _cm = getattr(app.state, "calendar_monitor", None)
    if _cm is not None:
        _cm.stop()
    calendar_monitor_task.cancel()
    try:
        await calendar_monitor_task
    except asyncio.CancelledError:
        pass
    log.info("phase6.calendar_monitor_stopped")
```

Also clean up any active pipelines stored by BotManager:
```python
# Clean up active real-time pipelines
bot_mgr = getattr(app.state, "bot_manager", None)
if bot_mgr is not None:
    for mid, pipeline in getattr(bot_mgr, "_active_pipelines", {}).items():
        try:
            if hasattr(pipeline, "shutdown"):
                await pipeline.shutdown()
        except Exception:
            log.warning("phase6.pipeline_cleanup_error", meeting_id=mid, exc_info=True)
```

Make sure `asyncio` is available in the shutdown section (it should be since it's used elsewhere in main.py, but verify the import).
  </action>
  <verify>
    grep -n "calendar_monitor_task" src/app/main.py
    grep -n "run_poll_loop" src/app/main.py
    grep -n "calendar_monitor_task.*cancel" src/app/main.py
    grep "POLL_INTERVAL_SECONDS = 900" src/app/meetings/calendar/monitor.py
    python -c "from src.app.main import create_app; print('main.py imports OK')"
  </verify>
  <done>
    CalendarMonitor.run_poll_loop() is started as an asyncio background task in main.py lifespan. POLL_INTERVAL_SECONDS updated from 60 to 900 (15 min). Shutdown section cancels the monitor task gracefully (calls .stop() then .cancel()). Active pipelines cleaned up on shutdown.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write integration tests for pipeline lifecycle and calendar monitor wiring</name>
  <files>
    tests/test_meeting_realtime_wiring.py
  </files>
  <action>
Create tests/test_meeting_realtime_wiring.py with integration tests covering the Phase 8 gap closures. Follow the existing test patterns from tests/test_meeting_integration.py (uses InMemoryMeetingRepository, FastAPI TestClient, mocked external services).

**Test structure:**

```python
"""Integration tests for Phase 8 meeting real-time gap closures.

Tests the end-to-end pipeline lifecycle: bot join -> pipeline creation ->
WebSocket handler finds pipeline -> transcript handling -> cleanup on leave.

Also tests CalendarMonitor background task wiring.
"""

from __future__ import annotations

import asyncio
import uuid
from datetime import datetime, timedelta, timezone
from typing import Any
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from src.app.meetings.bot.manager import BotManager
from src.app.meetings.schemas import (
    Meeting,
    MeetingStatus,
    Participant,
    ParticipantRole,
)
```

**Test cases to implement:**

1. **test_bot_manager_creates_pipeline_on_in_call_recording**
   - Create a BotManager with mock repository, mock recall_client, API keys, mock llm_service, and a mock app_state (SimpleNamespace)
   - Mock `_find_meeting_by_bot_id` to return a Meeting object
   - Call `handle_bot_event(bot_id="bot-1", event_type="status_change", event_data={"code": "in_call_recording"})`
   - Assert: `app_state.pipeline_{meeting_id}` attribute exists and is not None
   - Assert: BotManager._active_pipelines has an entry for the meeting_id

2. **test_bot_manager_cleans_pipeline_on_call_ended**
   - Same setup as test 1, but first trigger in_call_recording (creates pipeline)
   - Then call `handle_bot_event(bot_id="bot-1", event_type="status_change", event_data={"code": "call_ended"})`
   - Assert: `app_state.pipeline_{meeting_id}` attribute does NOT exist (raises AttributeError)
   - Assert: BotManager._active_pipelines is empty

3. **test_pipeline_creation_skipped_without_api_keys**
   - Create BotManager with empty API keys (deepgram_api_key="")
   - Mock `_find_meeting_by_bot_id` to return a Meeting
   - Call handle_bot_event with in_call_recording
   - Assert: app_state does NOT have pipeline_ attribute (pipeline creation was skipped)
   - Assert: _active_pipelines is empty

4. **test_pipeline_has_correct_meeting_context**
   - Create BotManager with API keys, trigger in_call_recording
   - Retrieve the pipeline from _active_pipelines
   - Assert: pipeline._meeting_context contains correct meeting_id, title, participants

5. **test_calendar_monitor_poll_interval_is_900**
   - `from src.app.meetings.calendar.monitor import POLL_INTERVAL_SECONDS`
   - Assert: POLL_INTERVAL_SECONDS == 900

6. **test_calendar_monitor_run_poll_loop_calls_process**
   - Create CalendarMonitor with mocked services
   - Mock process_upcoming_meetings to be a no-op
   - Start run_poll_loop in a task, sleep briefly, then call .stop()
   - Assert: process_upcoming_meetings was called at least once

7. **test_websocket_finds_pipeline_on_app_state**
   - Create a minimal FastAPI app with the meetings WebSocket endpoint
   - Set app.state.pipeline_{meeting_id} to a mock pipeline
   - Connect via WebSocket, send a transcript message
   - Assert: mock pipeline.handle_stt_transcript was called

**Implementation notes:**
- Use `types.SimpleNamespace()` for mock app_state
- Use `unittest.mock.patch.object` to mock BotManager._find_meeting_by_bot_id
- For pipeline creation, patch the real-time component imports (DeepgramSTT, ElevenLabsTTS, etc.) with MagicMock classes since we don't have real API keys
- For WebSocket test, use FastAPI TestClient `.websocket_connect()`
- Create a helper function `_make_meeting()` that returns a Meeting with standard test data
- All tests should be marked with `@pytest.mark.asyncio` where using async

Pattern for mocking pipeline component imports:
```python
@patch("src.app.meetings.bot.manager.DeepgramSTT", create=True)
@patch("src.app.meetings.bot.manager.ElevenLabsTTS", create=True)
...
```

Wait -- the imports in _create_pipeline_for_meeting are inside the method (lazy imports). So patch them at their actual module paths:
```python
@patch("src.app.meetings.realtime.stt.DeepgramSTT")
@patch("src.app.meetings.realtime.tts.ElevenLabsTTS")
@patch("src.app.meetings.realtime.avatar.HeyGenAvatar")
@patch("src.app.meetings.realtime.pipeline.RealtimePipeline")
```

Actually, since the method uses `from src.app.meetings.realtime.stt import DeepgramSTT` inside the method body, the patch target should be the module where it's defined. But since it's a local import, the cleanest approach is to just let the real classes instantiate (they don't make network calls in __init__). Only mock the external API calls. OR just patch the entire _create_pipeline_for_meeting to return a mock pipeline for most tests, and have one test that verifies the real factory.

Recommended: For tests 1-3, patch `_create_pipeline_for_meeting` to return a MagicMock pipeline. For test 4, let it run but patch the component constructors. This keeps tests fast and focused.
  </action>
  <verify>
    python -m pytest tests/test_meeting_realtime_wiring.py -v --timeout=30
    python -m pytest tests/test_meeting_realtime_wiring.py -v --timeout=30 -k "pipeline" --tb=short
    python -m pytest tests/ -x --timeout=60 -q
  </verify>
  <done>
    Integration tests verify: (1) pipeline created on in_call_recording, (2) pipeline cleaned up on call_ended, (3) pipeline skipped without API keys, (4) pipeline has correct meeting context, (5) POLL_INTERVAL_SECONDS is 900, (6) run_poll_loop calls process_upcoming_meetings, (7) WebSocket finds pipeline on app.state. All existing tests continue to pass.
  </done>
</task>

</tasks>

<verification>
1. `grep "POLL_INTERVAL_SECONDS = 900" src/app/meetings/calendar/monitor.py` -- Interval updated
2. `grep "run_poll_loop" src/app/main.py` -- Background task started
3. `grep "calendar_monitor_task.*cancel" src/app/main.py` -- Graceful shutdown
4. `python -m pytest tests/test_meeting_realtime_wiring.py -v --timeout=30` -- All new tests pass
5. `python -m pytest tests/ -x --timeout=120 -q` -- Full suite passes (1116+ tests)
6. `python -c "from src.app.main import create_app; print('OK')"` -- App creates without error
</verification>

<success_criteria>
- CalendarMonitor.run_poll_loop() started as asyncio background task in main.py
- POLL_INTERVAL_SECONDS is 900 (15 minutes)
- Shutdown cancels calendar_monitor_task and cleans up active pipelines
- Integration tests pass covering: pipeline lifecycle (create/cleanup), WebSocket discovery, calendar monitor interval
- All existing 1116+ tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-meeting-realtime-completion/08-03-SUMMARY.md`
</output>
