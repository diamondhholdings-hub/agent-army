---
phase: 10-solution-architect-agent
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/app/agents/solution_architect/agent.py
  - src/app/agents/solution_architect/capabilities.py
  - src/app/agents/solution_architect/__init__.py
autonomous: true

must_haves:
  truths:
    - "SolutionArchitectAgent handles map_requirements task type and returns TechnicalRequirementsDoc-shaped output"
    - "SolutionArchitectAgent handles generate_architecture task type and returns ArchitectureNarrative-shaped output"
    - "SolutionArchitectAgent handles scope_poc task type and returns POCPlan-shaped output"
    - "SolutionArchitectAgent handles respond_objection task type and returns ObjectionResponse-shaped output"
    - "SolutionArchitectAgent handles technical_handoff task type and returns TechnicalAnswerPayload-shaped output"
    - "Unknown task types raise ValueError with supported types listed"
  artifacts:
    - path: "src/app/agents/solution_architect/agent.py"
      provides: "SolutionArchitectAgent class with 5 handler methods"
      contains: "class SolutionArchitectAgent(BaseAgent)"
    - path: "src/app/agents/solution_architect/capabilities.py"
      provides: "5 AgentCapability declarations and registration factory"
      exports: ["SA_CAPABILITIES", "create_sa_registration"]
    - path: "src/app/agents/solution_architect/__init__.py"
      provides: "Public API for solution_architect package"
      exports: ["SolutionArchitectAgent", "create_sa_registration"]
  key_links:
    - from: "src/app/agents/solution_architect/agent.py"
      to: "src/app/agents/base.py"
      via: "BaseAgent inheritance"
      pattern: "class SolutionArchitectAgent\\(BaseAgent\\)"
    - from: "src/app/agents/solution_architect/agent.py"
      to: "src/app/agents/solution_architect/schemas.py"
      via: "import output models for type validation"
      pattern: "from src.app.agents.solution_architect.schemas import"
    - from: "src/app/agents/solution_architect/agent.py"
      to: "src/app/agents/solution_architect/prompts.py"
      via: "import prompt builders for LLM calls"
      pattern: "from src.app.agents.solution_architect.prompts import"
    - from: "src/app/agents/solution_architect/agent.py"
      to: "src/app/services/llm.py"
      via: "LLM service for content generation"
      pattern: "self._llm_service"
---

<objective>
Implement the SolutionArchitectAgent class with all 5 capability handlers, the capability declarations for registry, and the package __init__.py.

Purpose: This is the core agent that delivers all SA-01 through SA-05 requirements. Each handler follows the established pattern: compile context via RAG, call LLM with structured prompts, parse response into typed output, and return results with fail-open error handling.
Output: Working SolutionArchitectAgent class, 5 AgentCapability declarations, and clean package exports.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-solution-architect-agent/10-RESEARCH.md
@.planning/phases/10-solution-architect-agent/10-01-SUMMARY.md

# Existing patterns to clone
@src/app/agents/base.py
@src/app/agents/sales/agent.py
@src/app/agents/sales/capabilities.py
@src/app/agents/sales/__init__.py
@src/app/agents/solution_architect/schemas.py
@src/app/agents/solution_architect/prompts.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SolutionArchitectAgent class</name>
  <files>src/app/agents/solution_architect/agent.py</files>
  <action>
    Create `src/app/agents/solution_architect/agent.py` following the SalesAgent pattern in `src/app/agents/sales/agent.py`. The SA agent is simpler -- it does not need GSuite services, state repository, qualification, escalation, or QBS. It needs only: LLM service and RAG pipeline.

    **Class: SolutionArchitectAgent(BaseAgent)**

    Constructor `__init__(self, registration, llm_service, rag_pipeline)`:
    - Call `super().__init__(registration)`
    - Store `self._llm_service = llm_service`
    - Store `self._rag_pipeline = rag_pipeline`
    - Create logger via `structlog.get_logger(__name__)`

    **`execute(self, task: dict[str, Any], context: dict[str, Any]) -> dict[str, Any]`:**
    Route by `task.get("type", "")` to handler dict:
    ```python
    handlers = {
        "map_requirements": self._handle_map_requirements,
        "generate_architecture": self._handle_generate_architecture,
        "scope_poc": self._handle_scope_poc,
        "respond_objection": self._handle_respond_objection,
        "technical_handoff": self._handle_technical_handoff,
    }
    ```
    Unknown type raises `ValueError` listing supported types (same pattern as SalesAgent.execute).

    **Each handler follows this pattern:**
    1. Extract inputs from `task` dict and `context` dict (tenant_id)
    2. RAG query with appropriate content_type filter (wrap in try/except, fail-open with empty context)
    3. Build prompt via the corresponding prompt builder from prompts.py
    4. Call `self._llm_service.completion(messages=..., model="default", temperature=0.0, max_tokens=2048)`
    5. Parse JSON response into the corresponding Pydantic model (wrap in try/except)
    6. Return `.model_dump()` of the parsed model
    7. On any LLM or parse error: return a fallback dict with `{"error": str(exc), "confidence": "low", "partial": True}` -- this is the fail-open pattern

    **Handler specifics:**

    `_handle_map_requirements(task, context)` (SA-01):
    - Input: task["transcript"], task.get("deal_context", {})
    - RAG filter: `content_type in ["product", "methodology"]` (use existing product/methodology knowledge)
    - Prompt: `build_requirements_extraction_prompt(transcript, deal_context, rag_text)`
    - Output: TechnicalRequirementsDoc.model_dump()

    `_handle_generate_architecture(task, context)` (SA-02):
    - Input: task["tech_stack"], task.get("requirements", []), task.get("deal_context", {})
    - RAG filter: `content_type == "architecture_template"`
    - Prompt: `build_architecture_narrative_prompt(tech_stack, requirements_json, rag_text)`
    - Output: ArchitectureNarrative.model_dump()

    `_handle_scope_poc(task, context)` (SA-03):
    - Input: task.get("requirements", []), task.get("deal_stage", ""), task.get("timeline_preference", "flexible")
    - RAG filter: `content_type == "poc_template"`
    - Prompt: `build_poc_scoping_prompt(requirements_json, deal_stage, timeline, rag_text)`
    - Output: POCPlan.model_dump()

    `_handle_respond_objection(task, context)` (SA-04):
    - Input: task["objection"], task.get("competitor"), task.get("deal_context", {})
    - RAG filter: `content_type in ["competitor_analysis", "product"]` (competitor data + product knowledge)
    - Prompt: `build_objection_response_prompt(objection, competitor, deal_context, rag_text)`
    - Output: ObjectionResponse.model_dump()

    `_handle_technical_handoff(task, context)` (SA-05):
    - Input: task["question"], task.get("deal_id", ""), task.get("prospect_tech_stack"), task.get("context_chunks", [])
    - RAG filter: broad -- `content_type in ["product", "methodology", "competitor_analysis", "architecture_template"]`
    - Prompt: `build_technical_handoff_prompt(question, deal_context_from_task, rag_text)`
    - Output: TechnicalAnswerPayload.model_dump()

    **RAG query helper** `_query_rag(self, query: str, tenant_id: str, content_types: list[str]) -> str`:
    - Call `self._rag_pipeline.run(query=query, tenant_id=tenant_id)` if rag_pipeline is not None
    - Extract text from RAG response (handle both dict and object response formats)
    - On error or None pipeline: return "" (fail-open)
    - Note: The existing RAG pipeline does not natively support content_type filtering in its `run()` method. For now, pass the query as-is and include the desired content types in the query string as hints (e.g., prepend "[architecture_template] " to query). This is pragmatic -- content_type filtering can be added to the RAG pipeline later without changing the SA agent interface.

    **JSON parse helper** `_parse_llm_json(self, content: str, model_class: type) -> BaseModel`:
    - Strip markdown code fences if present
    - `json.loads(content)` -> `model_class(**parsed)`
    - On JSONDecodeError: try extracting JSON between first `{` and last `}`
    - On ValidationError: log and re-raise

    Add proper module docstring. Use `from __future__ import annotations`.
  </action>
  <verify>
    Run: `python -c "from src.app.agents.solution_architect.agent import SolutionArchitectAgent; print('Import OK')"`
    Run: `python -c "
from src.app.agents.solution_architect.agent import SolutionArchitectAgent
from src.app.agents.base import AgentRegistration, AgentCapability
reg = AgentRegistration(agent_id='sa', name='SA', description='test', capabilities=[AgentCapability(name='test', description='test')])
agent = SolutionArchitectAgent(registration=reg, llm_service=None, rag_pipeline=None)
try:
    import asyncio
    asyncio.run(agent.execute({'type': 'unknown'}, {}))
except ValueError as e:
    assert 'map_requirements' in str(e)
    print('ValueError correctly lists supported types')
"`
  </verify>
  <done>
    SolutionArchitectAgent is importable. It extends BaseAgent. The execute() method routes to 5 handlers by task type. Unknown task types raise ValueError listing all supported types. Each handler follows the fail-open pattern (LLM errors return partial results, not exceptions).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create capabilities and package init</name>
  <files>
    src/app/agents/solution_architect/capabilities.py
    src/app/agents/solution_architect/__init__.py
  </files>
  <action>
    **Create `src/app/agents/solution_architect/capabilities.py`:**
    Follow the exact pattern of `src/app/agents/sales/capabilities.py`.

    Define `SA_CAPABILITIES: list[AgentCapability]` with 5 entries:
    ```python
    SA_CAPABILITIES: list[AgentCapability] = [
        AgentCapability(
            name="map_requirements",
            description="Extract and categorize technical requirements from meeting transcripts and sales conversations",
        ),
        AgentCapability(
            name="generate_architecture",
            description="Generate integration architecture narrative tailored to prospect technical stack",
        ),
        AgentCapability(
            name="scope_poc",
            description="Scope a proof-of-concept engagement with deliverables, timeline, resource estimates, and success criteria",
        ),
        AgentCapability(
            name="respond_objection",
            description="Respond to technical objections with evidence-based differentiation using product knowledge and competitor data",
        ),
        AgentCapability(
            name="technical_handoff",
            description="Handle technical questions handed off from Sales Agent and return structured answers",
        ),
    ]
    ```

    Define `create_sa_registration() -> AgentRegistration`:
    ```python
    def create_sa_registration() -> AgentRegistration:
        return AgentRegistration(
            agent_id="solution_architect",
            name="Solution Architect",
            description=(
                "Technical pre-sales agent that maps requirements from sales conversations, "
                "generates architecture narratives, scopes POCs, handles technical objections, "
                "and responds to technical questions handed off from the Sales Agent"
            ),
            capabilities=SA_CAPABILITIES,
            backup_agent_id=None,
            tags=["technical", "architecture", "poc", "pre-sales", "objection-handling"],
            max_concurrent_tasks=3,
        )
    ```

    Add module docstring and `__all__`.

    **Update `src/app/agents/solution_architect/__init__.py`:**
    Follow the exact pattern of `src/app/agents/sales/__init__.py`. Import and re-export:
    - From agent.py: SolutionArchitectAgent
    - From capabilities.py: SA_CAPABILITIES, create_sa_registration
    - From schemas.py: All 11 schema classes

    Add module docstring and `__all__` list with all exports.
  </action>
  <verify>
    Run: `python -c "from src.app.agents.solution_architect import SolutionArchitectAgent, create_sa_registration, SA_CAPABILITIES; reg = create_sa_registration(); print('agent_id:', reg.agent_id); print('capabilities:', len(reg.capabilities)); print('tags:', reg.tags)"`
    Run: `python -c "from src.app.agents.solution_architect import TechnicalRequirementsDoc, ArchitectureNarrative, POCPlan, ObjectionResponse, TechnicalQuestionPayload, TechnicalAnswerPayload; print('All schemas re-exported OK')"`
  </verify>
  <done>
    `create_sa_registration()` returns an AgentRegistration with agent_id="solution_architect", 5 capabilities, and relevant tags. All 11 schema classes and the agent class are importable from the package __init__.py. The package API mirrors the Sales Agent package structure.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.app.agents.solution_architect import SolutionArchitectAgent"` -- no import errors
2. `python -c "from src.app.agents.solution_architect import create_sa_registration; r = create_sa_registration(); assert r.agent_id == 'solution_architect'; assert len(r.capabilities) == 5"` -- registration correct
3. `python -c "from src.app.agents.solution_architect.agent import SolutionArchitectAgent; from src.app.agents.base import AgentRegistration, AgentCapability; r = AgentRegistration(agent_id='t', name='t', description='t', capabilities=[]); a = SolutionArchitectAgent(registration=r, llm_service=None, rag_pipeline=None); print('Agent instantiates with None services (dev mode)')"`
4. Existing tests still pass: `python -m pytest tests/ -x -q --timeout=30`
</verification>

<success_criteria>
- SolutionArchitectAgent extends BaseAgent and implements execute() with 5 task type handlers
- Each handler follows fail-open pattern (returns partial results on error, never raises to caller)
- create_sa_registration() returns valid AgentRegistration with 5 capabilities
- Package __init__.py re-exports all public types
- Agent instantiates cleanly with None services (dev mode compatibility)
</success_criteria>

<output>
After completion, create `.planning/phases/10-solution-architect-agent/10-02-SUMMARY.md`
</output>
