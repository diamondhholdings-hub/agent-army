---
phase: 05-deal-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/deals/__init__.py
  - src/app/deals/models.py
  - src/app/deals/schemas.py
  - src/app/deals/repository.py
  - alembic/versions/add_deal_management_tables.py
autonomous: true

must_haves:
  truths:
    - "Account, Opportunity, Stakeholder, AccountPlan, and OpportunityPlan SQLAlchemy models exist with TenantBase and follow established conventions"
    - "Pydantic schemas define the full plan structures (AccountPlanData, OpportunityPlanData) per CONTEXT.md locked decisions"
    - "DealRepository provides async CRUD for all five entities using the session_factory callable pattern"
    - "Alembic migration creates all deal tables with RLS policies and indexes in tenant schema"
    - "Political mapping schemas support multiple roles per stakeholder and three 0-10 quantitative scores"
  artifacts:
    - path: "src/app/deals/models.py"
      provides: "SQLAlchemy models for Account, Opportunity, Stakeholder, AccountPlan, OpportunityPlan"
      contains: "class OpportunityModel(TenantBase)"
    - path: "src/app/deals/schemas.py"
      provides: "Pydantic schemas for plans, political map, opportunity signals, CRM payloads"
      contains: "class AccountPlanData(BaseModel)"
    - path: "src/app/deals/repository.py"
      provides: "DealRepository with CRUD for all deal entities"
      contains: "class DealRepository"
    - path: "alembic/versions/add_deal_management_tables.py"
      provides: "Alembic migration for all deal management tables"
      contains: "def upgrade()"
  key_links:
    - from: "src/app/deals/models.py"
      to: "src/app/core/database.py"
      via: "TenantBase import"
      pattern: "from src.app.core.database import TenantBase"
    - from: "src/app/deals/repository.py"
      to: "src/app/deals/models.py"
      via: "Model imports for CRUD operations"
      pattern: "from src.app.deals.models import"
---

<objective>
Create the foundational data layer for deal management: SQLAlchemy models, Pydantic schemas, async repository, and database migration.

Purpose: Every other Phase 5 plan depends on these models and schemas. This plan establishes the persistence layer that opportunity detection, political mapping, CRM sync, and stage progression all write to and read from.

Output: Five new SQLAlchemy models (AccountModel, OpportunityModel, StakeholderModel, AccountPlanModel, OpportunityPlanModel), comprehensive Pydantic schemas (including AccountPlanData and OpportunityPlanData with all sections from CONTEXT.md), DealRepository with session_factory pattern, and an Alembic migration with RLS.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-deal-management/05-RESEARCH.md
@.planning/phases/05-deal-management/05-CONTEXT.md

# Existing patterns to follow:
@src/app/core/database.py
@src/app/models/sales.py
@src/app/agents/sales/schemas.py
@src/app/agents/sales/state_repository.py
@alembic/versions/add_sales_conversation_state.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: SQLAlchemy models and Pydantic schemas for deal management</name>
  <files>
    src/app/deals/__init__.py
    src/app/deals/models.py
    src/app/deals/schemas.py
  </files>
  <action>
Create `src/app/deals/` package with `__init__.py`, `models.py`, and `schemas.py`.

**models.py** -- Five SQLAlchemy models using TenantBase (follow src/app/models/sales.py pattern exactly):

1. **AccountModel** (tablename: "accounts", schema: "tenant"):
   - id: UUID primary key with gen_random_uuid()
   - tenant_id: UUID, not null
   - account_name: String(300), not null
   - industry: String(100), nullable
   - company_size: String(50), nullable (e.g., "1-50", "51-200", "201-1000", "1000+")
   - website: String(500), nullable
   - region: String(50), nullable (APAC, EMEA, Americas)
   - metadata_json: JSON, default {}
   - created_at: DateTime(timezone=True), server_default=func.now()
   - updated_at: DateTime(timezone=True), onupdate=func.now(), nullable
   - UniqueConstraint("tenant_id", "account_name") -- one account per name per tenant
   - Index on (tenant_id, account_name)

2. **OpportunityModel** (tablename: "opportunities", schema: "tenant"):
   - id: UUID primary key
   - tenant_id: UUID, not null
   - account_id: UUID (FK to accounts.id), not null
   - external_id: String(200), nullable -- Notion page ID, Salesforce ID, etc.
   - name: String(300), not null
   - product_line: String(200), nullable
   - deal_stage: String(50), default "prospecting"
   - estimated_value: Float, nullable
   - probability: Float, default 0.1
   - close_date: DateTime(timezone=True), nullable
   - detection_confidence: Float, default 0.0
   - source: String(50), default "agent_detected" -- "agent_detected", "manual", "imported"
   - qualification_snapshot: JSON, default {} -- snapshot of BANT/MEDDIC at time of creation
   - metadata_json: JSON, default {}
   - created_at, updated_at, synced_at (DateTime, nullable for synced_at)
   - Index on (tenant_id, deal_stage)
   - Index on (tenant_id, account_id)

3. **StakeholderModel** (tablename: "stakeholders", schema: "tenant"):
   - id: UUID primary key
   - tenant_id: UUID, not null
   - account_id: UUID (FK to accounts.id), not null
   - contact_name: String(200), not null
   - contact_email: String(255), nullable
   - title: String(200), nullable
   - roles: JSON, default [] -- list of role strings (multiple roles allowed per CONTEXT.md)
   - decision_power: Integer, default 5 (0-10 score)
   - influence_level: Integer, default 5 (0-10 score)
   - relationship_strength: Integer, default 3 (0-10 score)
   - score_sources: JSON, default {} -- {"decision_power": "heuristic", ...} tracks score origin
   - score_evidence: JSON, default {} -- {"decision_power": "VP title suggests...", ...}
   - interaction_count: Integer, default 0
   - last_interaction: DateTime(timezone=True), nullable
   - notes: Text, nullable
   - metadata_json: JSON, default {}
   - created_at, updated_at
   - UniqueConstraint("tenant_id", "account_id", "contact_email") -- one stakeholder per email per account per tenant

4. **AccountPlanModel** (tablename: "account_plans", schema: "tenant"):
   - id: UUID primary key
   - tenant_id: UUID, not null
   - account_id: UUID (FK to accounts.id), not null, unique per tenant
   - plan_data: JSON, default {} -- stores AccountPlanData as JSON
   - version: Integer, default 1 -- increments on each update
   - created_at, updated_at
   - UniqueConstraint("tenant_id", "account_id")

5. **OpportunityPlanModel** (tablename: "opportunity_plans", schema: "tenant"):
   - id: UUID primary key
   - tenant_id: UUID, not null
   - opportunity_id: UUID (FK to opportunities.id), not null, unique per tenant
   - plan_data: JSON, default {} -- stores OpportunityPlanData as JSON
   - version: Integer, default 1
   - created_at, updated_at
   - UniqueConstraint("tenant_id", "opportunity_id")

**schemas.py** -- Pydantic models (follow src/app/agents/sales/schemas.py pattern):

Enums:
- StakeholderRole(str, Enum): DECISION_MAKER, INFLUENCER, CHAMPION, BLOCKER, USER, GATEKEEPER
- ScoreSource(str, Enum): HEURISTIC, CONVERSATION_SIGNAL, HUMAN_OVERRIDE
- OpportunitySource(str, Enum): AGENT_DETECTED, MANUAL, IMPORTED
- FieldOwnership(str, Enum): AGENT_OWNED, HUMAN_OWNED, SHARED

Stakeholder schemas:
- StakeholderScores(BaseModel): decision_power (int 0-10), influence_level (int 0-10), relationship_strength (int 0-10)
- StakeholderCreate(BaseModel): contact_name, contact_email, title, roles (list[StakeholderRole]), scores (StakeholderScores), score_sources (dict[str, ScoreSource])
- StakeholderRead(BaseModel): id, account_id, all fields from Create + interaction_count, last_interaction, notes, created_at, updated_at

Account plan data sections (CONTEXT.md locked):
- CompanyProfile(BaseModel): industry, company_size, tech_stack (list[str]), business_model, strategic_initiatives (list[str])
- InteractionSummary(BaseModel): date (datetime), channel (str), summary (str), sentiment (str)
- RelationshipHistory(BaseModel): key_events (list[str], max 50 items), interaction_summaries (list[InteractionSummary], max 20), overall_sentiment (str), wins (list[str]), losses (list[str])
- StrategicPositioning(BaseModel): competitive_landscape (str), whitespace_opportunities (list[str]), strategic_fit (str)
- AccountPlanData(BaseModel): company_profile, relationship_history, strategic_positioning, active_opportunity_ids (list[str])

Opportunity plan data sections (CONTEXT.md locked):
- CoreDealInfo(BaseModel): product_line, estimated_value (float|None), close_date (datetime|None), probability (float), stage (str), source (str)
- QualificationTracking(BaseModel): bant_snapshot (dict), meddic_snapshot (dict), overall_confidence (float), last_assessed (datetime|None)
- StakeholderSummary(BaseModel): stakeholder_id (str), name (str), roles (list[str]), decision_power (int), influence_level (int), key_insight (str)
- ActionItem(BaseModel): description (str), owner (str), due_date (datetime|None), status (str, default "open"), created_at (datetime)
- OpportunityPlanData(BaseModel): core_deal, qualification_tracking, stakeholder_map (list[StakeholderSummary]), action_items (list[ActionItem], max 30)

CRM-related schemas:
- OpportunityCreate(BaseModel): account_id, name, product_line, deal_stage, estimated_value, close_date, detection_confidence, source, qualification_snapshot
- OpportunityUpdate(BaseModel): all fields optional
- OpportunityRead(BaseModel): all fields + id, external_id, synced_at, created_at, updated_at
- OpportunityFilter(BaseModel): tenant_id, account_id (optional), deal_stage (optional), source (optional)
- ContactCreate(BaseModel): maps to StakeholderCreate for CRM
- ContactUpdate(BaseModel): optional fields
- ActivityCreate(BaseModel): type (str), subject (str), description (str), related_opportunity_id (optional), related_contact_id (optional), timestamp (datetime)
- ChangeRecord(BaseModel): entity_type (str), entity_id (str), external_id (str|None), changed_fields (dict), timestamp (datetime), source (str)
- SyncResult(BaseModel): pushed (int), pulled (int), conflicts (int), errors (list[str])
- FieldOwnershipConfig(BaseModel): agent_owned_fields (list[str]), human_owned_fields (list[str]), shared_fields (list[str])

Opportunity detection schemas:
- OpportunitySignals(BaseModel): deal_potential_confidence (float 0-1), product_line (str|None), estimated_value (float|None), estimated_timeline (str|None), pain_points (list[str]), budget_signals (list[str]), is_new_opportunity (bool), matching_opportunity_id (str|None), reasoning (str)

Do NOT import or use DealStage from agents.sales.schemas -- reuse it by importing it. Do NOT duplicate the DealStage enum.

**__init__.py** -- Empty init file to make deals a package.
  </action>
  <verify>
    python -c "from src.app.deals.models import AccountModel, OpportunityModel, StakeholderModel, AccountPlanModel, OpportunityPlanModel; print('Models OK')"
    python -c "from src.app.deals.schemas import AccountPlanData, OpportunityPlanData, OpportunitySignals, StakeholderScores, StakeholderRole; print('Schemas OK')"
  </verify>
  <done>All 5 SQLAlchemy models import cleanly with TenantBase, all Pydantic schemas validate with proper field constraints, DealStage is imported (not duplicated) from agents.sales.schemas</done>
</task>

<task type="auto">
  <name>Task 2: DealRepository and Alembic migration</name>
  <files>
    src/app/deals/repository.py
    alembic/versions/add_deal_management_tables.py
  </files>
  <action>
**repository.py** -- Async CRUD following ConversationStateRepository pattern exactly:

```python
class DealRepository:
    def __init__(self, session_factory: Callable[..., AsyncGenerator[AsyncSession, None]]) -> None:
        self._session_factory = session_factory
```

Methods (all take tenant_id as first arg):
- create_account(tenant_id, data: AccountCreate) -> AccountRead
- get_account(tenant_id, account_id) -> AccountRead | None
- get_account_by_name(tenant_id, account_name) -> AccountRead | None
- list_accounts(tenant_id) -> list[AccountRead]
- create_opportunity(tenant_id, data: OpportunityCreate) -> OpportunityRead
- get_opportunity(tenant_id, opportunity_id) -> OpportunityRead | None
- find_matching_opportunity(tenant_id, account_id, product_line, timeline_months) -> OpportunityRead | None -- for dedup (Pitfall 3 from RESEARCH.md)
- list_opportunities(tenant_id, filters: OpportunityFilter) -> list[OpportunityRead]
- update_opportunity(tenant_id, opportunity_id, data: OpportunityUpdate) -> OpportunityRead
- create_stakeholder(tenant_id, data: StakeholderCreate, account_id) -> StakeholderRead
- get_stakeholder(tenant_id, stakeholder_id) -> StakeholderRead | None
- list_stakeholders(tenant_id, account_id) -> list[StakeholderRead]
- update_stakeholder_scores(tenant_id, stakeholder_id, scores: StakeholderScores, sources: dict, evidence: dict) -> StakeholderRead
- upsert_account_plan(tenant_id, account_id, plan_data: AccountPlanData) -> version (int)
- get_account_plan(tenant_id, account_id) -> AccountPlanData | None
- upsert_opportunity_plan(tenant_id, opportunity_id, plan_data: OpportunityPlanData) -> version (int)
- get_opportunity_plan(tenant_id, opportunity_id) -> OpportunityPlanData | None

Add helper functions _model_to_account, _model_to_opportunity, _model_to_stakeholder for serialization. Plan data is serialized/deserialized via Pydantic model_dump(mode="json") / model_validate().

Also add AccountCreate and AccountRead schemas to schemas.py if not already defined:
- AccountCreate(BaseModel): account_name, industry, company_size, website, region
- AccountRead(BaseModel): id, tenant_id, account_name, industry, company_size, website, region, created_at, updated_at

**add_deal_management_tables.py** -- Alembic migration following add_sales_conversation_state.py pattern EXACTLY:

- revision: "005_deal_management"
- down_revision: "004_conversation_states" -- chain after the latest tenant migration
- Get schema from context.get_x_argument(as_dictionary=True)
- Create 5 tables: accounts, opportunities, stakeholders, account_plans, opportunity_plans
- Enable RLS + FORCE RLS on each table
- Create tenant_isolation policy on each table
- Create indexes:
  - accounts: (tenant_id, account_name)
  - opportunities: (tenant_id, deal_stage), (tenant_id, account_id)
  - stakeholders: (tenant_id, account_id)
  - account_plans: (tenant_id, account_id)
  - opportunity_plans: (tenant_id, opportunity_id)
- downgrade(): Drop policies then drop tables in reverse order

NOTE: Do NOT add ForeignKey constraints in the migration since these are tenant-schema tables with RLS. Use application-level referential integrity via the repository. Keep it consistent with the existing add_sales_conversation_state.py migration which does NOT use FK constraints.
  </action>
  <verify>
    python -c "from src.app.deals.repository import DealRepository; print('Repository OK')"
    python -c "from alembic.versions.add_deal_management_tables import upgrade, downgrade; print('Migration OK')"
    cd /Users/RAZER/Documents/projects/sales\ army && python -m pytest tests/ -x -q --timeout=30 2>&1 | tail -5
  </verify>
  <done>DealRepository provides full CRUD for all 5 deal entities, Alembic migration creates all tables with RLS and indexes, all existing tests still pass</done>
</task>

</tasks>

<verification>
1. All 5 SQLAlchemy models inherit from TenantBase and have schema="tenant"
2. All Pydantic schemas validate with proper field constraints (0-10 for scores, 0-1 for confidence)
3. DealRepository session_factory pattern matches ConversationStateRepository
4. Alembic migration has RLS policies for every table
5. DealStage enum is imported from agents.sales.schemas (not duplicated)
6. Existing test suite passes unchanged
</verification>

<success_criteria>
- `python -c "from src.app.deals.models import *"` succeeds
- `python -c "from src.app.deals.schemas import *"` succeeds
- `python -c "from src.app.deals.repository import DealRepository"` succeeds
- Existing tests: all 465 pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-deal-management/05-01-SUMMARY.md`
</output>
