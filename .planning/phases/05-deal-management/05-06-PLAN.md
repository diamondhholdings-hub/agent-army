---
phase: 05-deal-management
plan: 06
type: execute
wave: 1
depends_on: ["05-05"]
files_modified:
  - src/app/api/v1/sales.py
  - tests/test_deal_hooks.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Post-conversation hook fires after every sales email send"
    - "Post-conversation hook fires after every sales chat send"
    - "Post-conversation hook fires after every customer reply processing"
    - "Hook failure does not block the sales endpoint response (fire-and-forget)"
    - "Deal stages progress automatically when qualification thresholds are met"
  artifacts:
    - path: "src/app/api/v1/sales.py"
      provides: "Hook invocation in send_email, send_chat, and process_reply endpoints"
      contains: "deal_hook"
    - path: "tests/test_deal_hooks.py"
      provides: "Integration tests verifying hook is called from sales endpoints"
  key_links:
    - from: "src/app/api/v1/sales.py"
      to: "src/app/deals/hooks.py"
      via: "request.app.state.deal_hook.run()"
      pattern: "deal_hook\\.run"
    - from: "src/app/api/v1/sales.py"
      to: "src/app/agents/sales/agent.py"
      via: "agent.invoke() then hook.run()"
      pattern: "await agent\\.invoke.*deal_hook"
---

<objective>
Wire PostConversationHook into sales conversation endpoints to close the critical gap where Phase 5 deal management infrastructure exists but is never triggered.

Purpose: The entire Phase 5 system (opportunity detection, political mapping, plan maintenance, stage progression) is structurally complete but functionally inactive because PostConversationHook.run() is never called from the sales API. This single integration point activates all deal management automation.

Output: Modified sales.py with hook calls in all 3 conversation endpoints, plus integration tests proving the wiring works.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-deal-management/05-05-SUMMARY.md
@.planning/phases/05-deal-management/05-VERIFICATION.md

Source files to modify:
@src/app/api/v1/sales.py
@src/app/deals/hooks.py
@tests/test_deal_hooks.py

Reference for app.state pattern:
@src/app/api/v1/deals.py (see _get_deal_repository using request.app.state)
@src/app/main.py (see Phase 5 init block storing app.state.deal_hook)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire PostConversationHook into sales API endpoints</name>
  <files>src/app/api/v1/sales.py</files>
  <action>
Modify src/app/api/v1/sales.py to call PostConversationHook.run() after agent.invoke() in three endpoints: send_email, send_chat, and process_reply.

Specific changes:

1. Add `Request` to the FastAPI import on line 13:
   Change: `from fastapi import APIRouter, Depends, HTTPException, Query, status`
   To: `from fastapi import APIRouter, Depends, HTTPException, Query, Request, status`

2. Add `import structlog` at the top of the file (after existing imports, before router definition):
   `logger = structlog.get_logger(__name__)`

3. Add a helper function after `_get_state_repository()` (around line 177):
   ```python
   async def _fire_deal_hook(
       request: Request,
       tenant_id: str,
       conversation_text: str,
       conversation_state: Any,
   ) -> None:
       """Fire post-conversation deal management hook (fire-and-forget).

       Retrieves PostConversationHook from app.state and runs it.
       Errors are logged but never raised -- the sales endpoint response
       must not be blocked by deal management failures.

       Args:
           request: FastAPI request for app.state access.
           tenant_id: Tenant UUID string.
           conversation_text: The conversation text to analyze.
           conversation_state: Current ConversationState for the contact.
       """
       deal_hook = getattr(request.app.state, "deal_hook", None)
       if deal_hook is None:
           return
       try:
           await deal_hook.run(
               tenant_id=tenant_id,
               conversation_text=conversation_text,
               conversation_state=conversation_state,
           )
       except Exception as exc:
           logger.warning("deal_hook.fire_failed", error=str(exc))
   ```

4. Modify `send_email` endpoint (POST /sales/send-email):
   - Add `request: Request` parameter to the function signature (before `body`):
     `async def send_email(request: Request, body: SendEmailRequest, ...)`
   - After `result = await agent.invoke(task, context)` and before `return SendEmailResponse(**result)`,
     retrieve conversation state and fire hook:
     ```python
     # Fire deal management hook (fire-and-forget)
     state_repo = getattr(agent, "_state_repository", None)
     if state_repo:
         conv_state = await state_repo.get_state(tenant.tenant_id, body.account_id, body.contact_id)
         if conv_state:
             await _fire_deal_hook(request, tenant.tenant_id, body.description, conv_state)
     ```

5. Modify `send_chat` endpoint (POST /sales/send-chat):
   - Add `request: Request` parameter to the function signature (before `body`):
     `async def send_chat(request: Request, body: SendChatRequest, ...)`
   - After `result = await agent.invoke(task, context)` and before `return SendChatResponse(**result)`,
     add the same hook firing pattern:
     ```python
     # Fire deal management hook (fire-and-forget)
     state_repo = getattr(agent, "_state_repository", None)
     if state_repo:
         conv_state = await state_repo.get_state(tenant.tenant_id, body.account_id, body.contact_id)
         if conv_state:
             await _fire_deal_hook(request, tenant.tenant_id, body.description, conv_state)
     ```

6. Modify `process_reply` endpoint (POST /sales/process-reply):
   - Add `request: Request` parameter to the function signature (before `body`):
     `async def process_reply(request: Request, body: ProcessReplyRequest, ...)`
   - After `result = await agent.invoke(task, context)` and before `return ProcessReplyResponse(**result)`,
     fire hook with the reply_text (which is the actual conversation content):
     ```python
     # Fire deal management hook (fire-and-forget)
     state_repo = getattr(agent, "_state_repository", None)
     if state_repo:
         conv_state = await state_repo.get_state(tenant.tenant_id, body.account_id, body.contact_id)
         if conv_state:
             await _fire_deal_hook(request, tenant.tenant_id, body.reply_text, conv_state)
     ```

IMPORTANT design decisions:
- Use `request: Request` parameter (matching deals.py pattern from _get_deal_repository) to access app.state -- do NOT use global app import.
- The _fire_deal_hook helper wraps ALL errors in try/except and logs warnings. This is the fire-and-forget pattern established in PostConversationHook itself (hooks.py line 99-303).
- conversation_text is `body.description` for send_email/send_chat (the task description that includes context about what to communicate) and `body.reply_text` for process_reply (the actual customer reply text that contains deal signals).
- ConversationState is loaded AFTER agent.invoke() returns so the hook sees the updated state (post-qualification-extraction, post-interaction-count-increment).
- The hook is called AFTER agent.invoke() completes and BEFORE the response is returned. This keeps it synchronous within the request lifecycle but fire-and-forget in error handling. A future optimization could move this to a background task, but synchronous-with-error-swallowing is simpler and sufficient for v1.
  </action>
  <verify>
Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "from src.app.api.v1.sales import router; print('Import OK')"` to confirm no import errors.

Run: `cd "/Users/RAZER/Documents/projects/sales army" && grep -n 'deal_hook' src/app/api/v1/sales.py` to confirm deal_hook appears in the file (should show 6+ lines: helper function + 3 endpoint invocations).

Run: `cd "/Users/RAZER/Documents/projects/sales army" && grep -n 'Request' src/app/api/v1/sales.py` to confirm Request is imported and used in endpoint signatures.
  </verify>
  <done>
- `send_email`, `send_chat`, and `process_reply` all call `_fire_deal_hook` after agent.invoke()
- `Request` is imported from fastapi and added to all 3 endpoint signatures
- `_fire_deal_hook` helper handles None deal_hook (graceful skip) and exceptions (log warning, never raise)
- `structlog` logger is present for hook failure logging
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for hook wiring in sales endpoints</name>
  <files>tests/test_deal_hooks.py</files>
  <action>
Add 3 new test classes to the EXISTING tests/test_deal_hooks.py file (append after the existing TestHookStageProgression class at the end of the file).

These tests verify that the sales.py endpoints actually call _fire_deal_hook, which in turn calls deal_hook.run(). They use the httpx AsyncClient + app override pattern from test_deal_api.py.

Add these imports at the top of the file (merge with existing imports):
```python
import pytest_asyncio
from httpx import ASGITransport, AsyncClient
```

Add these 3 test classes at the end of the file:

```python
# ── Sales Endpoint Hook Wiring Tests ────────────────────────────────────────


class TestSendEmailFiresHook:
    """Verify POST /sales/send-email calls PostConversationHook."""

    @pytest.mark.asyncio
    async def test_send_email_fires_deal_hook(self) -> None:
        """After agent.invoke(), deal_hook.run() is called with tenant_id,
        conversation_text, and conversation_state."""
        from src.app.main import create_app

        app = create_app()

        # Mock the agent and its state repository
        mock_agent = MagicMock()
        mock_agent.invoke = AsyncMock(return_value={
            "status": "sent",
            "message_id": "msg-123",
            "thread_id": "thread-456",
            "escalation": None,
        })
        mock_state = _make_conversation_state()
        mock_state_repo = MagicMock()
        mock_state_repo.get_state = AsyncMock(return_value=mock_state)
        mock_agent._state_repository = mock_state_repo

        # Mock the deal hook
        mock_hook = MagicMock()
        mock_hook.run = AsyncMock(return_value=HookResult())

        # Wire mocks into app.state
        mock_registration = MagicMock()
        mock_registration._agent_instance = mock_agent

        with patch("src.app.api.v1.sales._get_sales_agent", return_value=mock_agent):
            app.state.deal_hook = mock_hook

            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url="http://test") as client:
                resp = await client.post(
                    "/api/v1/sales/send-email",
                    json={
                        "account_id": ACCOUNT_ID,
                        "contact_id": str(uuid.uuid4()),
                        "contact_email": "test@example.com",
                        "description": "Follow up on pricing discussion",
                    },
                    headers={"Authorization": "Bearer test-token", "X-Tenant-ID": TENANT_ID},
                )

            # The hook should have been called
            # Note: Auth middleware may reject the request in unit test context,
            # so we verify the wiring exists by checking the source directly
            # if the endpoint is reachable. For structural verification:
            from src.app.api.v1 import sales as sales_module
            source = sales_module.__file__
            import inspect
            src_code = inspect.getsource(sales_module.send_email)
            assert "_fire_deal_hook" in src_code, (
                "send_email endpoint must call _fire_deal_hook"
            )


class TestSendChatFiresHook:
    """Verify POST /sales/send-chat calls PostConversationHook."""

    @pytest.mark.asyncio
    async def test_send_chat_fires_deal_hook(self) -> None:
        """send_chat endpoint source contains _fire_deal_hook call."""
        import inspect
        from src.app.api.v1 import sales as sales_module
        src_code = inspect.getsource(sales_module.send_chat)
        assert "_fire_deal_hook" in src_code, (
            "send_chat endpoint must call _fire_deal_hook"
        )


class TestProcessReplyFiresHook:
    """Verify POST /sales/process-reply calls PostConversationHook."""

    @pytest.mark.asyncio
    async def test_process_reply_fires_deal_hook(self) -> None:
        """process_reply endpoint source contains _fire_deal_hook call."""
        import inspect
        from src.app.api.v1 import sales as sales_module
        src_code = inspect.getsource(sales_module.process_reply)
        assert "_fire_deal_hook" in src_code, (
            "process_reply endpoint must call _fire_deal_hook"
        )


class TestFireDealHookHelper:
    """Tests for the _fire_deal_hook helper function itself."""

    @pytest.mark.asyncio
    async def test_fire_deal_hook_calls_hook_run(self) -> None:
        """_fire_deal_hook invokes deal_hook.run() with correct args."""
        from src.app.api.v1.sales import _fire_deal_hook

        mock_request = MagicMock()
        mock_hook = MagicMock()
        mock_hook.run = AsyncMock(return_value=HookResult())
        mock_request.app.state.deal_hook = mock_hook

        state = _make_conversation_state()
        await _fire_deal_hook(mock_request, TENANT_ID, "test conversation", state)

        mock_hook.run.assert_called_once_with(
            tenant_id=TENANT_ID,
            conversation_text="test conversation",
            conversation_state=state,
        )

    @pytest.mark.asyncio
    async def test_fire_deal_hook_skips_when_no_hook(self) -> None:
        """_fire_deal_hook returns silently when deal_hook is None."""
        from src.app.api.v1.sales import _fire_deal_hook

        mock_request = MagicMock()
        mock_request.app.state.deal_hook = None

        state = _make_conversation_state()
        # Should NOT raise
        await _fire_deal_hook(mock_request, TENANT_ID, "test", state)

    @pytest.mark.asyncio
    async def test_fire_deal_hook_swallows_errors(self) -> None:
        """_fire_deal_hook catches exceptions from hook.run() and does not raise."""
        from src.app.api.v1.sales import _fire_deal_hook

        mock_request = MagicMock()
        mock_hook = MagicMock()
        mock_hook.run = AsyncMock(side_effect=RuntimeError("Database exploded"))
        mock_request.app.state.deal_hook = mock_hook

        state = _make_conversation_state()
        # Should NOT raise despite hook failure
        await _fire_deal_hook(mock_request, TENANT_ID, "test", state)

    @pytest.mark.asyncio
    async def test_fire_deal_hook_no_attr(self) -> None:
        """_fire_deal_hook handles missing deal_hook attribute gracefully."""
        from src.app.api.v1.sales import _fire_deal_hook

        mock_request = MagicMock(spec=[])
        # MagicMock with empty spec has no attributes
        # But we use getattr with default, so this should just return None
        mock_request_real = MagicMock()
        del mock_request_real.app.state.deal_hook  # Remove the attr

        state = _make_conversation_state()
        # getattr returns None -> should skip
        await _fire_deal_hook(mock_request_real, TENANT_ID, "test", state)
```

IMPORTANT:
- These tests reuse the existing fixtures (_make_conversation_state, TENANT_ID, ACCOUNT_ID) already defined at the top of test_deal_hooks.py
- The structural tests (source code inspection) are used because full HTTP integration tests would require mocking the auth middleware and tenant resolution, which is complex and already covered by test_deal_api.py patterns
- The _fire_deal_hook helper tests are direct unit tests that verify the actual function behavior: calls hook.run(), skips when None, swallows errors
- Total: 7 new tests (1 endpoint wiring structural + 2 more structural + 4 helper unit tests)
  </action>
  <verify>
Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -m pytest tests/test_deal_hooks.py -v --tb=short` to confirm all tests pass (5 existing + 7 new = 12 total).

Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -m pytest tests/ -x --tb=short -q` to confirm no regressions across the full test suite (should be 611 tests: 604 existing + 7 new).
  </verify>
  <done>
- 7 new tests added to tests/test_deal_hooks.py
- 3 structural tests confirm _fire_deal_hook appears in send_email, send_chat, process_reply source
- 4 unit tests for _fire_deal_hook: calls hook.run(), skips when None, swallows errors, handles missing attr
- All existing 604 tests still pass
- Total test count is 611
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Structural verification**: `grep -c 'deal_hook' src/app/api/v1/sales.py` returns 6+ (helper function definition + 3 endpoint calls + import/docstring references)

2. **Import verification**: `python -c "from src.app.api.v1.sales import _fire_deal_hook; print('Helper exists')"` succeeds

3. **Test verification**: `python -m pytest tests/test_deal_hooks.py -v` shows 12 passing tests (5 existing + 7 new)

4. **Full suite**: `python -m pytest tests/ -x -q` shows 611 passing tests with no failures

5. **Gap closure confirmation**: `grep -n 'deal_hook' src/app/api/v1/sales.py` shows invocations in send_email, send_chat, and process_reply -- the exact gap identified in VERIFICATION.md
</verification>

<success_criteria>
- PostConversationHook.run() is invoked from all 3 conversation endpoints (send_email, send_chat, process_reply)
- Hook invocation follows fire-and-forget pattern: errors logged but never raised
- Hook receives correct arguments: tenant_id, conversation_text, conversation_state (post-update)
- All 611 tests pass (604 existing + 7 new)
- VERIFICATION.md gap "PostConversationHook not called from sales conversation flow" is closed
- Phase 5 Success Criterion 5 ("Deal stages progress automatically based on qualification signals") is now achievable
</success_criteria>

<output>
After completion, create `.planning/phases/05-deal-management/05-06-SUMMARY.md`
</output>
