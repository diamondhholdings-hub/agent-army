---
phase: 05-deal-management
plan: 05
type: execute
wave: 3
depends_on: ["05-01", "05-02", "05-03", "05-04"]
files_modified:
  - src/app/deals/hooks.py
  - src/app/api/v1/deals.py
  - src/app/api/v1/router.py
  - src/app/main.py
  - tests/test_deal_api.py
  - tests/test_deal_hooks.py
autonomous: true

must_haves:
  truths:
    - "Deal management API provides CRUD endpoints for accounts, opportunities, stakeholders, plans, and pipeline view"
    - "Post-conversation hooks wire opportunity detection, political mapping, plan updates, and stage progression into the SalesAgent flow"
    - "DealRepository, CRM adapters, and all deal services are initialized in main.py lifespan and stored on app.state"
    - "Integration tests verify end-to-end deal lifecycle without real database or LLM calls"
    - "Router includes deals endpoints in the v1 API"
  artifacts:
    - path: "src/app/deals/hooks.py"
      provides: "PostConversationHook wiring detection+political+plans+progression"
      contains: "class PostConversationHook"
    - path: "src/app/api/v1/deals.py"
      provides: "REST API endpoints for deal management"
      contains: "router = APIRouter"
    - path: "src/app/api/v1/router.py"
      provides: "Updated router including deals"
      contains: "deals"
    - path: "src/app/main.py"
      provides: "Deal management initialization in lifespan"
      contains: "deal"
    - path: "tests/test_deal_api.py"
      provides: "Integration tests for deal management API"
    - path: "tests/test_deal_hooks.py"
      provides: "Integration tests for post-conversation hooks"
  key_links:
    - from: "src/app/deals/hooks.py"
      to: "src/app/deals/detection.py"
      via: "OpportunityDetector for post-conversation signal extraction"
      pattern: "OpportunityDetector"
    - from: "src/app/deals/hooks.py"
      to: "src/app/deals/progression.py"
      via: "StageProgressionEngine for auto-advancement"
      pattern: "StageProgressionEngine"
    - from: "src/app/api/v1/deals.py"
      to: "src/app/deals/repository.py"
      via: "DealRepository for CRUD operations"
      pattern: "DealRepository"
    - from: "src/app/api/v1/router.py"
      to: "src/app/api/v1/deals.py"
      via: "router.include_router"
      pattern: "include_router.*deals"
---

<objective>
Wire the entire deal management system together: post-conversation hooks for automated detection/mapping/progression, REST API endpoints for external access, main.py initialization, and integration tests proving end-to-end functionality.

Purpose: This is the integration plan that connects all Phase 5 components into a working system. Without this wiring, the individual services (detection, political mapping, CRM sync, progression) exist but are not used. This plan makes deal management operational within the Sales Agent.

Output: PostConversationHook orchestrator, 12+ API endpoints, main.py wiring, and integration tests.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-deal-management/05-RESEARCH.md
@.planning/phases/05-deal-management/05-CONTEXT.md
@.planning/phases/05-deal-management/05-01-SUMMARY.md
@.planning/phases/05-deal-management/05-02-SUMMARY.md
@.planning/phases/05-deal-management/05-03-SUMMARY.md
@.planning/phases/05-deal-management/05-04-SUMMARY.md

# Integration patterns to follow:
@src/app/main.py
@src/app/api/v1/router.py
@src/app/api/v1/sales.py
@src/app/api/v1/learning.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: PostConversationHook and API endpoints</name>
  <files>
    src/app/deals/hooks.py
    src/app/api/v1/deals.py
  </files>
  <action>
**hooks.py** -- PostConversationHook orchestrating all deal management after a conversation:

```python
class PostConversationHook:
    """Runs after every sales conversation to detect opportunities,
    update political maps, refresh plans, and evaluate stage progression.

    This hook is fire-and-forget -- errors are logged but do not block
    the agent's conversation response.
    """

    def __init__(
        self,
        detector: OpportunityDetector,
        political_mapper: PoliticalMapper,
        plan_manager: PlanManager,
        progression_engine: StageProgressionEngine,
        repository: DealRepository,
    ) -> None:
        ...
```

Methods:
- `async run(tenant_id: str, conversation_text: str, conversation_state: ConversationState) -> HookResult`
  - Orchestrates all post-conversation operations:
    1. **Opportunity Detection**: Run detector.detect_signals() with existing opportunities from repository
       - If should_create_opportunity: create via repository.create_opportunity() + create opportunity plan
       - If should_update_opportunity: update via repository.update_opportunity()
    2. **Political Mapping**: For each stakeholder mentioned in conversation:
       - Score from title if new stakeholder
       - Refine from conversation if existing stakeholder
       - Detect roles from conversation
       - Save/update via repository
    3. **Plan Updates**:
       - Update account plan via plan_manager.create_or_update_account_plan()
       - Update opportunity plan(s) via plan_manager.create_or_update_opportunity_plan()
    4. **Stage Progression**: Run progression_engine.evaluate_progression()
       - If progression recommended, update opportunity deal_stage
  - Wrap entire flow in try/except: log errors but never raise (fire-and-forget)
  - Return HookResult(BaseModel) with: opportunities_created (int), opportunities_updated (int), stakeholders_updated (int), plans_updated (int), stage_progressions (list[str])

- `async _ensure_account(tenant_id: str, account_id: str, account_name: str) -> AccountRead`
  - Get or create account for the conversation's account_id

Define HookResult(BaseModel) in hooks.py (small, local to hooks).

**api/v1/deals.py** -- REST API endpoints following sales.py pattern:

```python
router = APIRouter(prefix="/deals", tags=["deals"])
```

Dependency injection helper:
```python
def _get_deal_repository(request: Request) -> DealRepository:
    repo = getattr(request.app.state, "deal_repository", None)
    if repo is None:
        raise HTTPException(503, "Deal management not initialized")
    return repo
```

Endpoints:

Accounts:
- POST /deals/accounts -- create account (body: AccountCreate)
- GET /deals/accounts -- list accounts for tenant
- GET /deals/accounts/{account_id} -- get single account

Opportunities:
- POST /deals/opportunities -- create opportunity (body: OpportunityCreate)
- GET /deals/opportunities -- list opportunities with optional filters (stage, account_id, source)
- GET /deals/opportunities/{opportunity_id} -- get single opportunity
- PATCH /deals/opportunities/{opportunity_id} -- update opportunity (body: OpportunityUpdate)

Stakeholders:
- GET /deals/accounts/{account_id}/stakeholders -- list stakeholders for account
- POST /deals/accounts/{account_id}/stakeholders -- create stakeholder (body: StakeholderCreate)
- PATCH /deals/stakeholders/{stakeholder_id}/scores -- update stakeholder scores

Plans:
- GET /deals/accounts/{account_id}/plan -- get account plan
- GET /deals/opportunities/{opportunity_id}/plan -- get opportunity plan

Pipeline:
- GET /deals/pipeline -- pipeline view: list all opportunities grouped by stage with counts and total values

All endpoints require auth (Depends(get_current_user)) and tenant context (Depends(get_tenant)). Follow the exact pattern from src/app/api/v1/sales.py for request/response schemas and error handling.

Response schemas (define inline or at top of deals.py):
- AccountResponse(BaseModel): maps AccountRead fields
- OpportunityResponse(BaseModel): maps OpportunityRead fields, serializes datetimes to ISO strings
- StakeholderResponse(BaseModel): maps StakeholderRead fields
- PipelineResponse(BaseModel): stages (dict[str, list[OpportunityResponse]]), stage_counts (dict[str, int]), total_value (float)
  </action>
  <verify>
    python -c "from src.app.deals.hooks import PostConversationHook, HookResult; print('Hooks OK')"
    python -c "from src.app.api.v1.deals import router; print(f'Deals API OK, {len(router.routes)} routes')"
  </verify>
  <done>PostConversationHook orchestrates all deal management operations after conversations, API provides 12+ endpoints for deals CRUD and pipeline view</done>
</task>

<task type="auto">
  <name>Task 2: main.py wiring, router update, and integration tests</name>
  <files>
    src/app/api/v1/router.py
    src/app/main.py
    tests/test_deal_api.py
    tests/test_deal_hooks.py
  </files>
  <action>
**router.py** -- Add deals router:
```python
from src.app.api.v1 import auth, deals, health, learning, llm, sales, tenants
# ... existing includes ...
router.include_router(deals.router)
```

**main.py** -- Add Phase 5 initialization block in lifespan (after Phase 4.1 learning init, follow same try/except pattern):

```python
# ── Phase 5: Deal Management Module Initialization ──────────────
try:
    from src.app.deals.repository import DealRepository
    from src.app.deals.detection import OpportunityDetector
    from src.app.deals.political import PoliticalMapper
    from src.app.deals.plans import PlanManager
    from src.app.deals.progression import StageProgressionEngine
    from src.app.deals.hooks import PostConversationHook
    from src.app.deals.crm.postgres import PostgresAdapter
    from src.app.deals.crm.sync import SyncEngine
    from src.app.deals.crm.field_mapping import DEFAULT_FIELD_OWNERSHIP

    deal_repository = DealRepository(session_factory=get_tenant_session)
    app.state.deal_repository = deal_repository

    detector = OpportunityDetector()
    political_mapper = PoliticalMapper()
    plan_manager = PlanManager(repository=deal_repository)
    progression_engine = StageProgressionEngine()

    app.state.deal_hook = PostConversationHook(
        detector=detector,
        political_mapper=political_mapper,
        plan_manager=plan_manager,
        progression_engine=progression_engine,
        repository=deal_repository,
    )

    # CRM sync engine (external adapter configured per tenant later)
    app.state.sync_engine = SyncEngine(
        primary=PostgresAdapter(repository=deal_repository, tenant_id=""),
        external=None,  # Configured per-tenant when Notion token is set
        field_ownership=DEFAULT_FIELD_OWNERSHIP,
    )

    log.info("phase5.deal_management_initialized")
except Exception:
    log.warning("phase5.deal_management_init_failed", exc_info=True)
    app.state.deal_repository = None
    app.state.deal_hook = None
    app.state.sync_engine = None
```

**tests/test_deal_api.py** -- Integration tests for deal management API (follow existing test patterns):

Use InMemoryDealRepository test double (define at top of test file) that stores data in dicts:
```python
class InMemoryDealRepository:
    def __init__(self):
        self._accounts = {}
        self._opportunities = {}
        self._stakeholders = {}
        self._account_plans = {}
        self._opportunity_plans = {}
    # Implement same methods as DealRepository but using dicts
```

Tests (using httpx AsyncClient with app override for deal_repository):
- test_create_account: POST /v1/deals/accounts -> 201 with account data
- test_list_accounts: GET /v1/deals/accounts -> 200 with list
- test_create_opportunity: POST /v1/deals/opportunities -> 201
- test_list_opportunities_filter_by_stage: GET /v1/deals/opportunities?stage=discovery -> filtered list
- test_get_opportunity_not_found: GET /v1/deals/opportunities/{bad_id} -> 404
- test_update_opportunity: PATCH /v1/deals/opportunities/{id} -> 200 with updated fields
- test_create_stakeholder: POST /v1/deals/accounts/{id}/stakeholders -> 201
- test_update_stakeholder_scores: PATCH /v1/deals/stakeholders/{id}/scores -> 200
- test_get_account_plan: GET /v1/deals/accounts/{id}/plan -> 200 (or 404 if no plan)
- test_pipeline_view: GET /v1/deals/pipeline -> 200 with stage groups
- test_deals_api_503_when_not_initialized: app.state.deal_repository = None -> 503

**tests/test_deal_hooks.py** -- Integration tests for PostConversationHook:

Use mock/patch for OpportunityDetector, PoliticalMapper, PlanManager, StageProgressionEngine:
- test_hook_creates_opportunity_above_threshold: detector returns confidence=0.85 -> opportunity created
- test_hook_updates_existing_opportunity: detector returns matching_opportunity_id -> opportunity updated
- test_hook_no_opportunity_below_threshold: detector returns confidence=0.50 -> nothing created
- test_hook_error_does_not_raise: detector raises exception -> HookResult still returned, error logged
- test_hook_stage_progression_applied: progression engine returns QUALIFICATION -> opportunity stage updated
  </action>
  <verify>
    cd /Users/RAZER/Documents/projects/sales\ army && python -m pytest tests/test_deal_api.py tests/test_deal_hooks.py -v --timeout=30 2>&1 | tail -30
    cd /Users/RAZER/Documents/projects/sales\ army && python -m pytest tests/ -x -q --timeout=30 2>&1 | tail -5
  </verify>
  <done>Deals router wired into v1 API, main.py initializes all deal management services, integration tests verify API endpoints and hook lifecycle, all tests pass (existing 465 + new deal tests)</done>
</task>

</tasks>

<verification>
1. router.py includes deals.router
2. main.py lifespan initializes DealRepository, OpportunityDetector, PoliticalMapper, PlanManager, StageProgressionEngine, PostConversationHook, SyncEngine
3. app.state.deal_repository, app.state.deal_hook, app.state.sync_engine are set
4. Endpoints return 503 when deal management not initialized (graceful degradation)
5. PostConversationHook is fire-and-forget (never raises, always returns HookResult)
6. Integration tests cover happy path, error cases, and 503 fallback
7. All new tests pass, all existing 465 tests pass
</verification>

<success_criteria>
- Deal management API accessible at /v1/deals/*
- PostConversationHook.run() returns HookResult even when individual steps fail
- main.py initializes all deal services in a single try/except block
- 15+ new integration tests pass
- All existing 465 tests pass
- Total test count: 480+
</success_criteria>

<output>
After completion, create `.planning/phases/05-deal-management/05-05-SUMMARY.md`
</output>
