---
phase: 05-deal-management
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/app/deals/crm/__init__.py
  - src/app/deals/crm/adapter.py
  - src/app/deals/crm/postgres.py
  - src/app/deals/crm/notion.py
  - src/app/deals/crm/sync.py
  - src/app/deals/crm/field_mapping.py
  - tests/test_crm_adapter.py
autonomous: true

must_haves:
  truths:
    - "CRMAdapter ABC defines the standard interface all CRM backends implement"
    - "PostgresAdapter wraps DealRepository as the always-on primary CRM backend"
    - "NotionAdapter connects to Notion databases via notion-client AsyncClient with retry logic"
    - "SyncEngine orchestrates bidirectional sync with field-level conflict resolution"
    - "Outbound sync is batched (not real-time per write) to avoid Notion rate limiting (Pitfall 1)"
  artifacts:
    - path: "src/app/deals/crm/adapter.py"
      provides: "CRMAdapter abstract base class"
      contains: "class CRMAdapter(ABC)"
    - path: "src/app/deals/crm/postgres.py"
      provides: "PostgresAdapter implementing CRMAdapter over DealRepository"
      contains: "class PostgresAdapter(CRMAdapter)"
    - path: "src/app/deals/crm/notion.py"
      provides: "NotionAdapter implementing CRMAdapter over Notion API"
      contains: "class NotionAdapter(CRMAdapter)"
    - path: "src/app/deals/crm/sync.py"
      provides: "SyncEngine for bidirectional sync with conflict resolution"
      contains: "class SyncEngine"
    - path: "tests/test_crm_adapter.py"
      provides: "Unit tests for CRM adapters and sync engine"
  key_links:
    - from: "src/app/deals/crm/postgres.py"
      to: "src/app/deals/repository.py"
      via: "DealRepository wrapping"
      pattern: "DealRepository"
    - from: "src/app/deals/crm/sync.py"
      to: "src/app/deals/crm/adapter.py"
      via: "CRMAdapter interface for primary and external"
      pattern: "CRMAdapter"
---

<objective>
Build the pluggable CRM integration layer: abstract adapter interface, PostgreSQL primary backend, Notion external connector, and bidirectional sync engine with conflict resolution.

Purpose: This plan enables the Sales Agent to keep deal data synchronized with external CRM systems. PostgreSQL is always-on primary storage (agent always has data access even if CRM is down). Notion is the first external connector, with the architecture designed to make Salesforce/HubSpot connectors straightforward additions.

Output: CRMAdapter ABC, PostgresAdapter, NotionAdapter, SyncEngine, FieldOwnershipConfig, and comprehensive unit tests.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-deal-management/05-RESEARCH.md
@.planning/phases/05-deal-management/05-CONTEXT.md
@.planning/phases/05-deal-management/05-01-SUMMARY.md

# Existing patterns:
@src/app/deals/schemas.py
@src/app/deals/repository.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: CRM adapter ABC, PostgresAdapter, and field mapping</name>
  <files>
    src/app/deals/crm/__init__.py
    src/app/deals/crm/adapter.py
    src/app/deals/crm/postgres.py
    src/app/deals/crm/field_mapping.py
  </files>
  <action>
**Install notion-client:**
```bash
cd /Users/RAZER/Documents/projects/sales\ army && pip install notion-client
```
Add `notion-client>=2.7.0` to pyproject.toml dependencies.

**crm/__init__.py** -- Package init exporting CRMAdapter, PostgresAdapter, NotionAdapter, SyncEngine.

**adapter.py** -- CRMAdapter abstract base class (from RESEARCH.md Pattern 1):

```python
from abc import ABC, abstractmethod

class CRMAdapter(ABC):
    """Abstract interface for CRM backend operations."""

    @abstractmethod
    async def create_opportunity(self, opportunity: OpportunityCreate) -> str:
        """Create opportunity, return external ID."""
        ...

    @abstractmethod
    async def update_opportunity(self, external_id: str, data: OpportunityUpdate) -> None: ...

    @abstractmethod
    async def get_opportunity(self, external_id: str) -> OpportunityRead | None: ...

    @abstractmethod
    async def list_opportunities(self, filters: OpportunityFilter) -> list[OpportunityRead]: ...

    @abstractmethod
    async def create_contact(self, contact: ContactCreate) -> str: ...

    @abstractmethod
    async def update_contact(self, external_id: str, data: ContactUpdate) -> None: ...

    @abstractmethod
    async def create_activity(self, activity: ActivityCreate) -> str: ...

    @abstractmethod
    async def get_changes_since(self, since: datetime) -> list[ChangeRecord]: ...
```

**postgres.py** -- PostgresAdapter wrapping DealRepository:

```python
class PostgresAdapter(CRMAdapter):
    def __init__(self, repository: DealRepository, tenant_id: str) -> None:
        self._repo = repository
        self._tenant_id = tenant_id
```

All methods delegate to DealRepository. create_opportunity returns str(opportunity.id). get_changes_since queries by updated_at >= since. This adapter is always-on primary storage.

**field_mapping.py** -- Field ownership configuration and Notion property mappings:

```python
DEFAULT_FIELD_OWNERSHIP = FieldOwnershipConfig(
    agent_owned_fields=[
        "qualification_snapshot", "detection_confidence", "probability",
        "qualification_tracking", "stakeholder_map", "score_evidence",
    ],
    human_owned_fields=[
        "custom_notes", "manual_tags", "override_stage",
    ],
    shared_fields=[
        "deal_stage", "estimated_value", "close_date", "name",
    ],
)
```

Also define NOTION_PROPERTY_MAP: dict mapping internal field names to Notion property names and types:
- "name" -> {"notion_name": "Deal Name", "type": "title"}
- "deal_stage" -> {"notion_name": "Stage", "type": "select"}
- "estimated_value" -> {"notion_name": "Value", "type": "number"}
- "close_date" -> {"notion_name": "Close Date", "type": "date"}
- "product_line" -> {"notion_name": "Product", "type": "select"}
- "probability" -> {"notion_name": "Probability", "type": "number"}
- "source" -> {"notion_name": "Source", "type": "select"}
- "contact_name" -> {"notion_name": "Contact", "type": "rich_text"}
- "contact_email" -> {"notion_name": "Email", "type": "email"}

Add helper functions:
- `to_notion_properties(data: dict, property_map: dict) -> dict` -- converts internal dict to Notion API properties format
- `from_notion_properties(properties: dict, property_map: dict) -> dict` -- converts Notion properties to internal dict
  </action>
  <verify>
    python -c "from src.app.deals.crm.adapter import CRMAdapter; print('Adapter OK')"
    python -c "from src.app.deals.crm.postgres import PostgresAdapter; print('Postgres OK')"
    python -c "from src.app.deals.crm.field_mapping import DEFAULT_FIELD_OWNERSHIP, NOTION_PROPERTY_MAP; print('Field mapping OK')"
  </verify>
  <done>CRMAdapter ABC defines the standard interface, PostgresAdapter delegates to DealRepository, field mappings define ownership rules and Notion property conversions</done>
</task>

<task type="auto">
  <name>Task 2: NotionAdapter, SyncEngine, and unit tests</name>
  <files>
    src/app/deals/crm/notion.py
    src/app/deals/crm/sync.py
    tests/test_crm_adapter.py
  </files>
  <action>
**notion.py** -- NotionAdapter with Notion API 2025-09-03 support:

```python
class NotionAdapter(CRMAdapter):
    def __init__(self, token: str, database_id: str) -> None:
        self._client = AsyncClient(auth=token)
        self._database_id = database_id
        self._data_source_id: str | None = None  # Resolved lazily
```

Key implementation details:
- `_ensure_data_source()`: Lazy resolve data_source_id from database (Pitfall 2: API 2025-09-03 requirement). Try data_sources namespace first; if SDK doesn't support it, fall back to database_id directly.
- All API calls wrapped with `@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=1, max=10))` from tenacity (Pitfall 1: rate limiting)
- `create_opportunity()`: Creates Notion page with properties mapped via field_mapping.to_notion_properties(). Returns page["id"].
- `update_opportunity()`: Updates page properties by page_id.
- `get_opportunity()`: Retrieves page by page_id, maps properties back via from_notion_properties().
- `list_opportunities()`: Queries database with optional filter on Stage/Last edited time.
- `create_contact()`: Creates page in a contacts database (or section of main database).
- `create_activity()`: Appends block to opportunity page body (paragraph block with activity text).
- `get_changes_since(since)`: Query database filtered by "Last edited time" > since.isoformat(). Returns ChangeRecord list.

Handle notion_client import gracefully -- if not installed, raise ImportError with helpful message.

**sync.py** -- SyncEngine for bidirectional sync (RESEARCH.md Pattern 5):

```python
class SyncEngine:
    def __init__(
        self,
        primary: CRMAdapter,       # Always PostgreSQL
        external: CRMAdapter | None,  # Notion, future Salesforce, etc.
        field_ownership: FieldOwnershipConfig,
        sync_interval_seconds: int = 60,  # Pitfall 1: 60s default
    ) -> None:
        self._primary = primary
        self._external = external
        self._ownership = field_ownership
        self._sync_interval = sync_interval_seconds
        self._last_sync: datetime | None = None
```

Methods:
- `async sync_outbound(changes: list[ChangeRecord]) -> SyncResult`
  - Pushes changes from primary to external CRM
  - Respects field ownership: only push agent_owned and shared fields
  - Returns SyncResult with pushed/errors counts
  - If no external adapter configured, returns SyncResult(pushed=0, pulled=0, conflicts=0, errors=[])

- `async sync_inbound() -> SyncResult`
  - Pulls changes from external CRM since last sync
  - For each change, resolves conflicts via _resolve_conflict()
  - Applies resolved changes to primary
  - Updates _last_sync timestamp

- `_resolve_conflict(change: ChangeRecord) -> ChangeRecord`
  - Field-level resolution per RESEARCH.md Pitfall 6:
    - Agent-owned fields: agent wins unless human explicitly overrode
    - Human-owned fields: CRM/external wins always
    - Shared fields: last-write-wins with timestamp comparison
  - Returns filtered ChangeRecord with only the winning fields

- `has_external() -> bool`: Returns True if external adapter is configured

**tests/test_crm_adapter.py** -- Unit tests:

Test PostgresAdapter:
- test_postgres_adapter_create_opportunity: delegates to repo, returns string ID
- test_postgres_adapter_list_opportunities: delegates to repo with filters

Test SyncEngine:
- test_sync_outbound_no_external: returns empty SyncResult when no external configured
- test_resolve_conflict_agent_owned: agent_owned field in change -> agent wins
- test_resolve_conflict_human_owned: human_owned field in change -> external wins
- test_resolve_conflict_shared_last_write_wins: shared field -> most recent timestamp wins
- test_sync_inbound_updates_last_sync: after sync, _last_sync is set

Test NotionAdapter:
- test_notion_adapter_init: initializes with token and database_id
- test_notion_import_error: raises helpful error if notion-client not installed (mock the import)

Use mock/patch for DealRepository and Notion client in tests -- no real database or API calls.
  </action>
  <verify>
    cd /Users/RAZER/Documents/projects/sales\ army && python -m pytest tests/test_crm_adapter.py -v --timeout=30 2>&1 | tail -20
    cd /Users/RAZER/Documents/projects/sales\ army && python -m pytest tests/ -x -q --timeout=30 2>&1 | tail -5
  </verify>
  <done>NotionAdapter handles API calls with retry and lazy data_source resolution, SyncEngine resolves field-level conflicts with ownership rules, all CRM tests pass, all existing tests pass</done>
</task>

</tasks>

<verification>
1. CRMAdapter ABC has all 8 abstract methods (create/update/get/list opportunity, create/update contact, create activity, get_changes_since)
2. PostgresAdapter delegates all operations to DealRepository
3. NotionAdapter uses tenacity retry with exponential backoff (Pitfall 1)
4. SyncEngine defaults to 60-second sync interval (Pitfall 1)
5. Field ownership config separates agent/human/shared fields (Pitfall 6)
6. notion-client added to pyproject.toml dependencies
7. All new tests pass, all existing 465 tests pass
</verification>

<success_criteria>
- `python -c "from src.app.deals.crm import CRMAdapter, PostgresAdapter, NotionAdapter, SyncEngine"` succeeds
- PostgresAdapter wraps DealRepository without additional database logic
- SyncEngine._resolve_conflict correctly applies field ownership rules
- notion-client in pyproject.toml
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-deal-management/05-03-SUMMARY.md`
</output>
