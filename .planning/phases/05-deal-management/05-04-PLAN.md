---
phase: 05-deal-management
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/app/deals/progression.py
  - tests/test_deal_progression.py
autonomous: true

must_haves:
  truths:
    - "StageProgressionEngine defines evidence requirements per deal stage using BANT/MEDDIC completion thresholds"
    - "Auto-progression evaluates qualification signals after every update and advances stage when evidence meets thresholds"
    - "Stage transitions respect existing VALID_TRANSITIONS rules from Phase 4 state_repository"
    - "Progression engine does NOT rebuild qualification -- it CONSUMES existing QualificationState data"
  artifacts:
    - path: "src/app/deals/progression.py"
      provides: "StageProgressionEngine with evidence-based auto-advancement"
      contains: "class StageProgressionEngine"
    - path: "tests/test_deal_progression.py"
      provides: "Unit tests for stage progression logic"
  key_links:
    - from: "src/app/deals/progression.py"
      to: "src/app/agents/sales/state_repository.py"
      via: "VALID_TRANSITIONS import for stage validation"
      pattern: "from src.app.agents.sales.state_repository import VALID_TRANSITIONS, validate_stage_transition"
    - from: "src/app/deals/progression.py"
      to: "src/app/agents/sales/schemas.py"
      via: "DealStage, QualificationState, BANTSignals, MEDDICSignals imports"
      pattern: "from src.app.agents.sales.schemas import"
---

<objective>
Build the evidence-based deal stage progression engine that automatically advances opportunities through the pipeline when qualification signals meet stage-specific thresholds.

Purpose: This is the automation that turns manual pipeline management into intelligent auto-progression. The engine consumes BANT/MEDDIC qualification data (already tracked by Phase 4) and determines when a deal should advance to the next stage based on evidence accumulation. This is a key differentiator -- the Sales Agent doesn't just track deals, it actively manages the pipeline.

Output: StageProgressionEngine with stage requirements, evaluation logic, and comprehensive unit tests.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-deal-management/05-RESEARCH.md
@.planning/phases/05-deal-management/05-CONTEXT.md
@.planning/phases/05-deal-management/05-01-SUMMARY.md

# Critical existing code to consume (not rebuild):
@src/app/agents/sales/state_repository.py
@src/app/agents/sales/schemas.py
@src/app/deals/schemas.py
@src/app/deals/repository.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: StageProgressionEngine with evidence thresholds</name>
  <files>
    src/app/deals/progression.py
  </files>
  <action>
**progression.py** -- StageProgressionEngine (RESEARCH.md Pattern 6):

Define StageRequirements as a dataclass or Pydantic model:
```python
class StageRequirements(BaseModel):
    """Minimum evidence thresholds for entering a deal stage."""
    min_bant_completion: float  # 0.0-1.0
    min_meddic_completion: float  # 0.0-1.0
    min_interactions: int
    required_signals: list[str]  # Names of qualification signals that must be identified
```

Define STAGE_EVIDENCE_REQUIREMENTS (from RESEARCH.md):
```python
STAGE_EVIDENCE_REQUIREMENTS: dict[DealStage, StageRequirements] = {
    DealStage.DISCOVERY: StageRequirements(
        min_bant_completion=0.0, min_meddic_completion=0.0,
        min_interactions=1, required_signals=["need_identified"],
    ),
    DealStage.QUALIFICATION: StageRequirements(
        min_bant_completion=0.25, min_meddic_completion=0.17,
        min_interactions=2, required_signals=["need_identified", "pain_identified"],
    ),
    DealStage.EVALUATION: StageRequirements(
        min_bant_completion=0.50, min_meddic_completion=0.33,
        min_interactions=3, required_signals=["budget_identified", "authority_identified"],
    ),
    DealStage.NEGOTIATION: StageRequirements(
        min_bant_completion=0.75, min_meddic_completion=0.50,
        min_interactions=4, required_signals=["economic_buyer_identified", "decision_criteria_identified"],
    ),
}
```

StageProgressionEngine:
```python
class StageProgressionEngine:
    def __init__(self) -> None:
        self._requirements = STAGE_EVIDENCE_REQUIREMENTS
```

Methods:

- `evaluate_progression(current_stage: DealStage, qualification: QualificationState, interaction_count: int) -> DealStage | None`
  - Returns the highest stage the deal qualifies for based on evidence, or None if no progression is warranted.
  - Logic:
    1. Get the next stage from current_stage (PROSPECTING->DISCOVERY, DISCOVERY->QUALIFICATION, etc.)
    2. If current stage is terminal (CLOSED_WON, CLOSED_LOST) or STALLED, return None
    3. Check if evidence meets the next stage's requirements
    4. If requirements met AND the transition is valid per VALID_TRANSITIONS, return the next stage
    5. Do NOT skip stages -- progression is always one step at a time
  - Import and use validate_stage_transition from state_repository to ensure transition is valid

- `check_requirements(stage: DealStage, qualification: QualificationState, interaction_count: int) -> tuple[bool, list[str]]`
  - Checks if evidence meets a specific stage's requirements
  - Returns (met: bool, missing: list[str]) where missing lists what's not yet satisfied
  - Check min_bant_completion against qualification.bant.completion_score
  - Check min_meddic_completion against qualification.meddic.completion_score
  - Check min_interactions against interaction_count
  - Check required_signals by looking at the qualification state (e.g., "need_identified" checks qualification.bant.need_identified OR qualification.meddic.pain_identified as appropriate)

- `_get_next_stage(current: DealStage) -> DealStage | None`
  - Returns the natural next stage in the pipeline:
    PROSPECTING -> DISCOVERY -> QUALIFICATION -> EVALUATION -> NEGOTIATION
  - Returns None for NEGOTIATION (close decisions are not auto-progressed), CLOSED_WON, CLOSED_LOST, STALLED

- `_check_signal(signal_name: str, qualification: QualificationState) -> bool`
  - Maps signal names to qualification state fields:
    "need_identified" -> qualification.bant.need_identified
    "pain_identified" -> qualification.meddic.pain_identified
    "budget_identified" -> qualification.bant.budget_identified
    "authority_identified" -> qualification.bant.authority_identified
    "economic_buyer_identified" -> qualification.meddic.economic_buyer_identified
    "decision_criteria_identified" -> qualification.meddic.decision_criteria_identified
  - Returns False for unknown signal names (fail-safe)

IMPORTANT: Do NOT auto-progress to CLOSED_WON or CLOSED_LOST. These are human-decision stages. The engine only handles DISCOVERY through NEGOTIATION auto-progression.
  </action>
  <verify>
    python -c "from src.app.deals.progression import StageProgressionEngine, STAGE_EVIDENCE_REQUIREMENTS; print(f'Progression OK, {len(STAGE_EVIDENCE_REQUIREMENTS)} stage requirements')"
  </verify>
  <done>StageProgressionEngine evaluates qualification evidence against stage-specific thresholds and returns progression recommendations respecting VALID_TRANSITIONS</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for stage progression</name>
  <files>
    tests/test_deal_progression.py
  </files>
  <action>
**tests/test_deal_progression.py** -- Comprehensive unit tests for StageProgressionEngine:

Test evaluate_progression:
- test_prospecting_to_discovery: need_identified=True, 1+ interactions -> returns DISCOVERY
- test_prospecting_stays_without_need: need_identified=False -> returns None
- test_discovery_to_qualification: BANT >=0.25, MEDDIC >=0.17, need+pain identified, 2+ interactions -> QUALIFICATION
- test_qualification_to_evaluation: BANT >=0.50, MEDDIC >=0.33, budget+authority identified, 3+ interactions -> EVALUATION
- test_evaluation_to_negotiation: BANT >=0.75, MEDDIC >=0.50, economic_buyer+decision_criteria, 4+ interactions -> NEGOTIATION
- test_negotiation_does_not_auto_close: stage=NEGOTIATION with full qualification -> returns None (no auto-close)
- test_closed_won_no_progression: terminal stage -> returns None
- test_closed_lost_no_progression: terminal stage -> returns None
- test_stalled_no_progression: STALLED stage -> returns None
- test_insufficient_interactions_blocks: all signals met but interaction_count too low -> returns None

Test check_requirements:
- test_check_requirements_all_met: returns (True, [])
- test_check_requirements_missing_bant: returns (False, ["min_bant_completion: 0.25 required, 0.0 actual"])
- test_check_requirements_missing_signal: returns (False, ["required signal: budget_identified"])
- test_check_requirements_missing_interactions: returns (False, ["min_interactions: 3 required, 1 actual"])

Test _check_signal:
- test_check_signal_need: "need_identified" -> qualification.bant.need_identified
- test_check_signal_pain: "pain_identified" -> qualification.meddic.pain_identified
- test_check_signal_unknown: "unknown_signal" -> False (fail-safe)

Test _get_next_stage:
- test_next_stage_prospecting: PROSPECTING -> DISCOVERY
- test_next_stage_negotiation: NEGOTIATION -> None (no auto-close)
- test_next_stage_closed: CLOSED_WON -> None

Build test QualificationState fixtures with specific BANT/MEDDIC fields set for each test case. Use the existing schemas from src/app/agents/sales/schemas.py.
  </action>
  <verify>
    cd /Users/RAZER/Documents/projects/sales\ army && python -m pytest tests/test_deal_progression.py -v --timeout=30 2>&1 | tail -25
    cd /Users/RAZER/Documents/projects/sales\ army && python -m pytest tests/ -x -q --timeout=30 2>&1 | tail -5
  </verify>
  <done>All progression tests pass covering happy path (progressive advancement), edge cases (terminal stages, insufficient evidence), and fail-safe behavior (unknown signals). All existing 465 tests pass.</done>
</task>

</tasks>

<verification>
1. STAGE_EVIDENCE_REQUIREMENTS has entries for DISCOVERY, QUALIFICATION, EVALUATION, NEGOTIATION
2. evaluate_progression returns None for terminal stages (CLOSED_WON, CLOSED_LOST)
3. evaluate_progression does NOT skip stages
4. NEGOTIATION does not auto-progress to CLOSED_WON or CLOSED_LOST
5. validate_stage_transition from state_repository is used for transition validation
6. _check_signal returns False for unknown signal names
7. All new tests pass, all existing 465 tests pass
</verification>

<success_criteria>
- StageProgressionEngine correctly advances PROSPECTING->DISCOVERY->QUALIFICATION->EVALUATION->NEGOTIATION based on evidence
- Terminal stages and STALLED return None (no auto-progression)
- 14+ unit tests covering all progression paths and edge cases
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-deal-management/05-04-SUMMARY.md`
</output>
