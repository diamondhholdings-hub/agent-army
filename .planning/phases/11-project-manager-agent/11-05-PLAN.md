---
phase: 11-project-manager-agent
plan: 05
type: execute
wave: 5
depends_on: ["11-04"]
files_modified:
  - src/app/agents/sales/agent.py
  - tests/test_sales_pm_handoff.py
autonomous: true

must_haves:
  truths:
    - "Sales Agent can dispatch project trigger events to PM agent via execute() handler"
    - "PM agent can receive and process trigger events dispatched by Sales Agent"
    - "Round-trip handoff from Sales Agent to PM agent produces a project plan trigger response"
    - "Trigger dispatch only fires for deal_won, poc_scoped, complex_deal conditions"
  artifacts:
    - path: "src/app/agents/sales/agent.py"
      provides: "dispatch_project_trigger handler added to Sales Agent execute() routing"
      contains: "dispatch_project_trigger"
    - path: "tests/test_sales_pm_handoff.py"
      provides: "Round-trip integration tests for Sales->PM handoff"
      min_lines: 100
  key_links:
    - from: "src/app/agents/sales/agent.py"
      to: "src/app/agents/project_manager/schemas.py"
      via: "lazy import of PMTriggerEvent for payload validation"
      pattern: "from src.app.agents.project_manager.schemas import PMTriggerEvent"
    - from: "tests/test_sales_pm_handoff.py"
      to: "src/app/agents/project_manager/agent.py"
      via: "creates PM agent instance to test round-trip"
      pattern: "from src.app.agents.project_manager"
---

<objective>
Add a dispatch_project_trigger handler to the Sales Agent that sends trigger events to the PM agent, and create round-trip integration tests proving the handoff works end-to-end.

Purpose: The PM agent needs to be triggered by the Sales Agent when deals are won, POCs are scoped, or complex deals are identified. Without this dispatch handler, the PM agent cannot receive work from the sales workflow. This mirrors the Sales -> SA handoff pattern from Phase 10-05.
Output: Updated Sales Agent with dispatch_project_trigger handler, test file proving round-trip handoff.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-project-manager-agent/11-CONTEXT.md
@.planning/phases/11-project-manager-agent/11-RESEARCH.md

# Prior plan SUMMARY for PM agent reference
@.planning/phases/11-project-manager-agent/11-03-SUMMARY.md

# Pattern reference -- Phase 10-05 did exactly this for SA handoff
@.planning/phases/10-solution-architect-agent/10-05-SUMMARY.md

# The Sales Agent file we'll modify
@src/app/agents/sales/agent.py

# PM schemas for trigger payload
@src/app/agents/project_manager/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dispatch_project_trigger to Sales Agent</name>
  <files>src/app/agents/sales/agent.py</files>
  <action>
Follow the exact pattern from Phase 10-05 (dispatch_technical_question). The changes are additive -- do NOT modify existing handlers.

**Step 1: Add to execute() routing dict**

Add one new entry to the handlers dict in execute():
```python
"dispatch_project_trigger": self._handle_dispatch_project_trigger,
```

This makes it the 7th handler (after send_email, send_chat, process_reply, qualify, recommend_action, dispatch_technical_question).

**Step 2: Add handler method**

Add `_handle_dispatch_project_trigger` in the Capability Handlers section (after dispatch_technical_question handler):

```python
async def _handle_dispatch_project_trigger(
    self, task: dict[str, Any], context: dict[str, Any]
) -> dict[str, Any]:
    """Dispatch a project trigger event to the Project Manager agent.

    Triggered when a deal is won, POC is scoped, or a complex deal is
    identified. Uses lazy import to avoid circular dependency.

    Args:
        task: Must include 'trigger_type' (deal_won|poc_scoped|complex_deal|manual)
              and 'deal_id'. Optional: 'deliverables', 'timeline', 'stakeholders'.
        context: Execution context with tenant_id.

    Returns:
        Dict with status, handoff_task, and target_agent_id.
    """
    trigger_type = task.get("trigger_type", "")
    deal_id = task.get("deal_id", "")

    if not trigger_type or not deal_id:
        return {
            "status": "failed",
            "error": "trigger_type and deal_id are required",
        }

    # Lazy import to avoid circular dependency (same pattern as SA dispatch)
    from src.app.agents.project_manager.schemas import PMTriggerEvent

    trigger_payload = PMTriggerEvent(
        trigger_type=trigger_type,
        deal_id=deal_id,
        tenant_id=context.get("tenant_id", ""),
        deliverables=task.get("deliverables", []),
        timeline=task.get("timeline"),
        stakeholders=task.get("stakeholders", []),
        poc_plan=task.get("poc_plan"),
        metadata=task.get("metadata", {}),
    )

    handoff_task = {
        "type": "process_trigger",
        "trigger": trigger_type,
        "deal_id": deal_id,
        "deliverables": trigger_payload.deliverables,
        "timeline": trigger_payload.timeline,
        "stakeholders": trigger_payload.stakeholders,
        "poc_plan": trigger_payload.poc_plan,
    }

    return {
        "status": "dispatched",
        "handoff_task": handoff_task,
        "payload": trigger_payload.model_dump_json(),
        "target_agent_id": "project_manager",
    }
```

**Step 3: Add _is_project_trigger helper**

Add a static method in the Helpers section (after _is_technical_question):

```python
@staticmethod
def _is_project_trigger(deal_stage: str, context: dict[str, Any]) -> str | None:
    """Determine if a deal state warrants a PM trigger.

    Returns the trigger type string if a PM trigger should fire,
    or None if no trigger is warranted.

    Trigger conditions:
    - deal_stage == "closed_won" or "won" -> "deal_won"
    - context contains "poc_scoped": True -> "poc_scoped"
    - context contains "complex_deal": True -> "complex_deal"

    Args:
        deal_stage: Current deal stage string.
        context: Deal context dict with optional flags.

    Returns:
        Trigger type string or None.
    """
    stage_lower = deal_stage.lower().replace(" ", "_")
    if stage_lower in ("closed_won", "won"):
        return "deal_won"
    if context.get("poc_scoped"):
        return "poc_scoped"
    if context.get("complex_deal"):
        return "complex_deal"
    return None
```

All changes are purely additive. Existing handlers and methods remain untouched.
  </action>
  <verify>
Run: `grep -n "dispatch_project_trigger" src/app/agents/sales/agent.py` -- should find handler in routing dict and method definition
Run: `grep -n "_is_project_trigger" src/app/agents/sales/agent.py` -- should find static method
Run: `uv run pytest tests/ -x -q` -- all existing tests pass (no regressions to Sales Agent)
  </verify>
  <done>Sales Agent has dispatch_project_trigger as 7th handler. Lazy import of PMTriggerEvent avoids circular deps. _is_project_trigger heuristic detects deal_won/poc_scoped/complex_deal conditions.</done>
</task>

<task type="auto">
  <name>Task 2: Create round-trip integration tests for Sales->PM handoff</name>
  <files>tests/test_sales_pm_handoff.py</files>
  <action>
Create test_sales_pm_handoff.py following the test_sales_sa_handoff.py pattern (from Phase 10-05). Use pytest, AsyncMock, test classes.

**Test fixtures:**
```python
@pytest.fixture
def sales_agent():
    # Reuse existing sales agent fixture pattern
    from src.app.agents.sales.agent import SalesAgent
    # ... (minimal mock setup matching existing test pattern)

@pytest.fixture
def pm_agent():
    from src.app.agents.project_manager import (
        ProjectManagerAgent,
        create_pm_registration,
    )
    registration = create_pm_registration()
    return ProjectManagerAgent(
        registration=registration,
        llm_service=AsyncMock(),
        rag_pipeline=AsyncMock(),
        notion_pm=AsyncMock(),
    )
```

**7 test cases across 5 test classes:**

**Class: TestSalesAgentDispatchesProjectTrigger**
1. `test_sales_agent_dispatches_deal_won_trigger` -- Invoke Sales Agent with task type="dispatch_project_trigger", trigger_type="deal_won", deal_id="d-1". Assert result has status="dispatched", handoff_task with type="process_trigger", target_agent_id="project_manager".

2. `test_sales_agent_dispatch_missing_fields_fails` -- Invoke with empty trigger_type. Assert result has status="failed".

**Class: TestPMAgentReceivesTrigger**
3. `test_pm_agent_receives_handoff_task` -- Take the handoff_task dict from test 1 output and pass it to PM agent execute(). Mock LLM to return valid trigger analysis. Assert PM agent processes it without error.

**Class: TestFullRoundTrip**
4. `test_full_round_trip_sales_to_pm` -- End-to-end: Sales Agent dispatches deal_won trigger -> extract handoff_task -> PM agent processes trigger -> PM agent creates project plan (mock LLM returns valid ProjectPlan JSON). Assert final result has "trigger_processed": True.

**Class: TestIsProjectTrigger**
5. `test_is_project_trigger_deal_won` -- _is_project_trigger("closed_won", {}) returns "deal_won"
6. `test_is_project_trigger_poc_scoped` -- _is_project_trigger("evaluation", {"poc_scoped": True}) returns "poc_scoped"
7. `test_is_project_trigger_no_trigger` -- _is_project_trigger("qualification", {}) returns None

**Class: TestTriggerPayloadValidation**
8. `test_dispatch_creates_valid_pm_trigger_event` -- Invoke dispatch and verify the payload JSON deserializes back into a valid PMTriggerEvent.

All tests async. Use realistic mock data including deliverables, stakeholders, and timeline.
  </action>
  <verify>
Run: `uv run pytest tests/test_sales_pm_handoff.py -v` -- all 8 tests pass
Run: `uv run pytest tests/ -x -q` -- all tests pass including existing (no regressions)
Count: `grep -c "async def test_\|def test_" tests/test_sales_pm_handoff.py` returns 8
  </verify>
  <done>8 integration tests prove Sales Agent can dispatch project triggers to PM agent. Round-trip handoff works end-to-end. _is_project_trigger heuristic correctly identifies trigger conditions. Zero regressions.</done>
</task>

</tasks>

<verification>
- Sales Agent execute() has 7 handlers (6 original + dispatch_project_trigger)
- dispatch_project_trigger returns status="dispatched" with target_agent_id="project_manager"
- PM agent can process the handoff_task dict produced by Sales Agent dispatch
- Full round-trip (Sales dispatch -> PM process_trigger -> plan creation) works
- `uv run pytest tests/ -x -q` -- all tests pass (no regressions)
</verification>

<success_criteria>
- Sales Agent has dispatch_project_trigger handler (7th handler)
- Lazy import of PMTriggerEvent avoids circular dependency
- _is_project_trigger detects deal_won, poc_scoped, complex_deal conditions
- 8 round-trip integration tests pass
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/11-project-manager-agent/11-05-SUMMARY.md`
</output>
