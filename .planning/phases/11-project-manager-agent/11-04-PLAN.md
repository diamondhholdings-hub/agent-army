---
phase: 11-project-manager-agent
plan: 04
type: execute
wave: 4
depends_on: ["11-03"]
files_modified:
  - pyproject.toml
  - src/app/main.py
  - tests/test_project_manager.py
autonomous: true

must_haves:
  truths:
    - "PM agent initializes during app startup and is registered in AgentRegistry"
    - "PM agent is accessible at app.state.project_manager at runtime"
    - "APScheduler is declared as a project dependency"
    - "Integration tests cover all 6 PM capabilities, fail-open behavior, and registration correctness"
  artifacts:
    - path: "pyproject.toml"
      provides: "APScheduler dependency added"
      contains: "apscheduler"
    - path: "src/app/main.py"
      provides: "Phase 11 PM agent init block in lifespan"
      contains: "phase11.project_manager_initialized"
    - path: "tests/test_project_manager.py"
      provides: "Integration tests for all 6 PM capabilities"
      min_lines: 300
  key_links:
    - from: "src/app/main.py"
      to: "src/app/agents/project_manager"
      via: "imports ProjectManagerAgent, create_pm_registration in lifespan"
      pattern: "from src.app.agents.project_manager import"
    - from: "tests/test_project_manager.py"
      to: "src/app/agents/project_manager/agent.py"
      via: "imports ProjectManagerAgent and invokes execute()"
      pattern: "from src.app.agents.project_manager"
---

<objective>
Add APScheduler dependency, wire PM agent into app startup (main.py lifespan), and create comprehensive integration tests covering all 6 PM capabilities.

Purpose: Without main.py wiring, the PM agent is importable but not running. Without tests, behavior is unverified. This plan makes the PM agent a live part of the application and proves all 6 capabilities work correctly.
Output: Updated pyproject.toml, main.py Phase 11 init block, test_project_manager.py with ~12 tests.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-project-manager-agent/11-CONTEXT.md
@.planning/phases/11-project-manager-agent/11-RESEARCH.md

# Prior plan SUMMARYs
@.planning/phases/11-project-manager-agent/11-01-SUMMARY.md
@.planning/phases/11-project-manager-agent/11-03-SUMMARY.md

# Pattern reference for main.py wiring and test structure
@src/app/main.py
@tests/test_solution_architect.py

# Reference for SA init block pattern (lines 231-260 of main.py)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add APScheduler dependency and wire PM agent in main.py</name>
  <files>
    pyproject.toml
    src/app/main.py
  </files>
  <action>
**Part A: Update pyproject.toml**

Add `"apscheduler>=3.10.0"` to the dependencies list in pyproject.toml. Place it alphabetically near existing dependencies. Do NOT modify any other dependencies.

After editing, run `uv lock` to update the lockfile (do NOT run `uv sync` or install -- just lock).

**Part B: Add Phase 11 init block to main.py**

Add a Phase 11 init block in the lifespan function, placed AFTER the Phase 10 SA agent init block (which ends at line ~260) and BEFORE the Phase 5 Deal Management block (which starts at line ~262).

Follow the exact same pattern as the Phase 10 block:

```python
# ── Phase 11: Project Manager Agent ─────────────────────────────
# PMBOK-certified project lifecycle management agent. Follows the
# Sales Agent / SA Agent pattern: instantiate with shared services,
# register in AgentRegistry. Fail-tolerant -- PM unavailability
# does not prevent app startup.

try:
    from src.app.agents.project_manager import (
        ProjectManagerAgent,
        create_pm_registration,
    )

    pm_registration = create_pm_registration()

    pm_agent = ProjectManagerAgent(
        registration=pm_registration,
        llm_service=getattr(app.state, "llm_service", None)
        or locals().get("llm_service"),
        rag_pipeline=getattr(app.state, "rag_pipeline", None)
        or locals().get("rag_pipeline"),
        notion_pm=None,  # Configured when Projects DB is initialized
        gmail_service=getattr(app.state, "gmail_service", None)
        or locals().get("gmail_service"),
    )

    # Register in agent registry
    agent_registry = getattr(app.state, "agent_registry", None)
    if agent_registry is not None:
        agent_registry.register(pm_registration)
        pm_registration._agent_instance = pm_agent
    app.state.project_manager = pm_agent
    log.info("phase11.project_manager_initialized")
except Exception as exc:
    log.warning("phase11.project_manager_init_failed", error=str(exc))
```

Key points:
- Use getattr(app.state, ...) or locals().get() for service resolution (handles Phase 4 init failure)
- notion_pm=None initially (Projects database needs lazy initialization)
- gmail_service resolved from app.state (set up in Phase 6)
- Store on app.state.project_manager
- Fail-tolerant try/except

Do NOT add PMScheduler initialization here -- scheduler start depends on NotionPM being configured, which happens at first trigger.
  </action>
  <verify>
Run: `grep -n "phase11\|project_manager" src/app/main.py` to verify init block added
Run: `grep -n "apscheduler" pyproject.toml` to verify dependency added
Run: `uv run python -c "print('imports ok')"` to verify lock file is valid
  </verify>
  <done>APScheduler in pyproject.toml. Phase 11 init block in main.py lifespan. PM agent registers in AgentRegistry during startup.</done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests for PM agent</name>
  <files>tests/test_project_manager.py</files>
  <action>
Create test_project_manager.py following the test_solution_architect.py pattern: pytest, AsyncMock, test classes grouped by concern, mock LLM returning pre-built JSON for Pydantic validation round-trips.

**Test fixture:**
```python
@pytest.fixture
def pm_agent():
    from src.app.agents.project_manager import (
        ProjectManagerAgent,
        create_pm_registration,
    )
    registration = create_pm_registration()
    return ProjectManagerAgent(
        registration=registration,
        llm_service=AsyncMock(),
        rag_pipeline=AsyncMock(),
        notion_pm=AsyncMock(),
        gmail_service=AsyncMock(),
    )
```

**12 test cases across 6 test classes:**

**Class: TestCreateProjectPlan**
1. `test_pm_creates_plan_from_deliverables` -- Mock LLM returns valid ProjectPlan JSON (with phases, milestones, tasks). Assert result has "phases", "plan_id", "project_name" keys.
2. `test_pm_create_plan_fail_open` -- Mock LLM raises RuntimeError. Assert result has {"error": ..., "confidence": "low", "partial": True}.

**Class: TestDetectRisks**
3. `test_pm_detects_risks` -- Mock LLM returns list of RiskSignal dicts. Assert result has "risks" key with len > 0, each risk has "signal_type" and "severity".
4. `test_pm_detect_risks_empty_when_no_issues` -- Mock LLM returns empty list. Assert result has "risks" key with len == 0.

**Class: TestAdjustPlan**
5. `test_pm_produces_scope_change_delta` -- Mock LLM returns ScopeChangeDelta JSON. Assert result has "changes", "timeline_impact_days", "recommendation" keys.

**Class: TestGenerateStatusReport**
6. `test_pm_generates_internal_report` -- Mock LLM returns InternalStatusReport JSON. Assert result has "overall_rag", "milestone_progress", "earned_value", "agent_notes" keys.
7. `test_pm_generates_external_report` -- Mock LLM returns ExternalStatusReport JSON. Task has report_type="external". Assert result has "overall_status", "milestone_summary", "key_accomplishments" (NOT "agent_notes" or "deal_context").
8. `test_pm_report_earned_value_is_precalculated` -- Verify that the earned_value in the internal report result matches what calculate_earned_value() returns (not LLM-hallucinated). Mock LLM to return a report with EV values. The test should verify the handler called calculate_earned_value before the LLM call.

**Class: TestWriteCRMRecords**
9. `test_pm_write_crm_calls_notion_adapter` -- Task type="write_crm_records" with operation="create_project". Assert notion_pm mock method was called.
10. `test_pm_write_crm_no_adapter` -- pm_agent with notion_pm=None. Assert result has {"error": contains "not configured"}.

**Class: TestRegistration**
11. `test_pm_registration_has_correct_capabilities` -- Assert agent_id=="project_manager", 6 capabilities, expected capability names.
12. `test_pm_unknown_task_type_raises_valueerror` -- Call execute with type="invalid". Assert ValueError raised with "create_project_plan" in message.

**Mock LLM pattern (from SA tests):**
```python
# Mock returns JSON wrapped in code fences (testing strip logic)
mock_llm_response = {
    "content": '```json\n{"plan_id": "p-1", "deal_id": "d-1", ...}\n```'
}
pm_agent._llm_service.completion = AsyncMock(return_value=mock_llm_response)
```

Use realistic JSON payloads in mocks that match the full Pydantic schema structure (all required fields present with valid values). Import datetime for date fields -- use `datetime.now().isoformat()` in JSON strings.

All tests should be async (use `@pytest.mark.asyncio` or `async def test_*`).
  </action>
  <verify>
Run: `uv run pytest tests/test_project_manager.py -v` -- all 12 tests pass
Run: `uv run pytest tests/ -x -q` -- all tests pass including existing (no regressions)
Count: `grep -c "async def test_\|def test_" tests/test_project_manager.py` returns 12
  </verify>
  <done>12 integration tests covering all 6 PM capabilities, fail-open behavior, CRM write delegation, earned value pre-calculation verification, and registration correctness. Zero regressions.</done>
</task>

</tasks>

<verification>
- `grep "apscheduler" pyproject.toml` returns a match
- `grep "phase11.project_manager_initialized" src/app/main.py` returns a match
- `uv run pytest tests/test_project_manager.py -v` -- 12 tests pass
- `uv run pytest tests/ -x -q` -- all tests pass (no regressions)
- PM agent accessible at app.state.project_manager after lifespan
</verification>

<success_criteria>
- APScheduler declared as dependency in pyproject.toml
- PM agent initializes in main.py lifespan using established pattern
- PM agent registers in AgentRegistry
- 12 integration tests cover all 6 capabilities and edge cases
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/11-project-manager-agent/11-04-SUMMARY.md`
</output>
