---
phase: 11-project-manager-agent
plan: 04
type: execute
wave: 4
depends_on: ["11-03"]
files_modified:
  - pyproject.toml
  - src/app/main.py
  - tests/test_project_manager.py
autonomous: true

must_haves:
  truths:
    - "PM agent initializes during app startup and is registered in AgentRegistry"
    - "PM agent is accessible at app.state.project_manager at runtime"
    - "APScheduler is declared as a project dependency"
    - "Integration tests cover all 6 PM capabilities, fail-open behavior, registration correctness, email dispatch, auto-adjust chain, and milestone CRM writes"
  artifacts:
    - path: "pyproject.toml"
      provides: "APScheduler dependency added"
      contains: "apscheduler"
    - path: "src/app/main.py"
      provides: "Phase 11 PM agent init block in lifespan"
      contains: "phase11.project_manager_initialized"
    - path: "tests/test_project_manager.py"
      provides: "Integration tests for all 6 PM capabilities plus email, auto-adjust, and milestone tests"
      min_lines: 400
  key_links:
    - from: "src/app/main.py"
      to: "src/app/agents/project_manager"
      via: "imports ProjectManagerAgent, create_pm_registration in lifespan"
      pattern: "from src.app.agents.project_manager import"
    - from: "tests/test_project_manager.py"
      to: "src/app/agents/project_manager/agent.py"
      via: "imports ProjectManagerAgent and invokes execute()"
      pattern: "from src.app.agents.project_manager"
    - from: "tests/test_project_manager.py"
      to: "gmail_service.send_email"
      via: "test_pm_report_email_sent asserts gmail mock was called"
      pattern: "gmail_service.*send_email.*assert_called"
    - from: "tests/test_project_manager.py"
      to: "_handle_adjust_plan"
      via: "test_pm_detect_risks_auto_adjust_chain asserts auto-chaining occurred"
      pattern: "auto_adjustments"
---

<objective>
Add APScheduler dependency, wire PM agent into app startup (main.py lifespan), and create comprehensive integration tests covering all 6 PM capabilities plus email dispatch, risk auto-adjust chain, and milestone CRM write.

Purpose: Without main.py wiring, the PM agent is importable but not running. Without tests, behavior is unverified. This plan makes the PM agent a live part of the application and proves all 6 capabilities work correctly, including the critical email delivery, auto-adjust chain, and milestone recording behaviors.
Output: Updated pyproject.toml, main.py Phase 11 init block, test_project_manager.py with ~15 tests.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-project-manager-agent/11-CONTEXT.md
@.planning/phases/11-project-manager-agent/11-RESEARCH.md

# Prior plan SUMMARYs
@.planning/phases/11-project-manager-agent/11-01-SUMMARY.md
@.planning/phases/11-project-manager-agent/11-03-SUMMARY.md

# Pattern reference for main.py wiring and test structure
@src/app/main.py
@tests/test_solution_architect.py

# Reference for SA init block pattern (lines 231-260 of main.py)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add APScheduler dependency and wire PM agent in main.py</name>
  <files>
    pyproject.toml
    src/app/main.py
  </files>
  <action>
**Part A: Update pyproject.toml**

Add `"apscheduler>=3.10.0"` to the dependencies list in pyproject.toml. Place it alphabetically near existing dependencies. Do NOT modify any other dependencies.

After editing, run `uv lock` to update the lockfile (do NOT run `uv sync` or install -- just lock).

**Part B: Add Phase 11 init block to main.py**

Add a Phase 11 init block in the lifespan function, placed AFTER the Phase 10 SA agent init block (which ends at line ~260) and BEFORE the Phase 5 Deal Management block (which starts at line ~262).

Follow the exact same pattern as the Phase 10 block:

```python
# ── Phase 11: Project Manager Agent ─────────────────────────────
# PMBOK-certified project lifecycle management agent. Follows the
# Sales Agent / SA Agent pattern: instantiate with shared services,
# register in AgentRegistry. Fail-tolerant -- PM unavailability
# does not prevent app startup.

try:
    from src.app.agents.project_manager import (
        ProjectManagerAgent,
        create_pm_registration,
    )

    pm_registration = create_pm_registration()

    pm_agent = ProjectManagerAgent(
        registration=pm_registration,
        llm_service=getattr(app.state, "llm_service", None)
        or locals().get("llm_service"),
        rag_pipeline=getattr(app.state, "rag_pipeline", None)
        or locals().get("rag_pipeline"),
        notion_pm=None,  # Configured when Projects DB is initialized
        gmail_service=getattr(app.state, "gmail_service", None)
        or locals().get("gmail_service"),
    )

    # Register in agent registry
    agent_registry = getattr(app.state, "agent_registry", None)
    if agent_registry is not None:
        agent_registry.register(pm_registration)
        pm_registration._agent_instance = pm_agent
    app.state.project_manager = pm_agent
    log.info("phase11.project_manager_initialized")
except Exception as exc:
    log.warning("phase11.project_manager_init_failed", error=str(exc))
```

Key points:
- Use getattr(app.state, ...) or locals().get() for service resolution (handles Phase 4 init failure)
- notion_pm=None initially (Projects database needs lazy initialization)
- gmail_service resolved from app.state (set up in Phase 6)
- Store on app.state.project_manager
- Fail-tolerant try/except

Do NOT add PMScheduler initialization here -- scheduler start depends on NotionPM being configured, which happens at first trigger.
  </action>
  <verify>
Run: `grep -n "phase11\|project_manager" src/app/main.py` to verify init block added
Run: `grep -n "apscheduler" pyproject.toml` to verify dependency added
Run: `uv run python -c "print('imports ok')"` to verify lock file is valid
  </verify>
  <done>APScheduler in pyproject.toml. Phase 11 init block in main.py lifespan. PM agent registers in AgentRegistry during startup.</done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests for PM agent</name>
  <files>tests/test_project_manager.py</files>
  <action>
Create test_project_manager.py following the test_solution_architect.py pattern: pytest, AsyncMock, test classes grouped by concern, mock LLM returning pre-built JSON for Pydantic validation round-trips.

**Test fixture:**
```python
@pytest.fixture
def pm_agent():
    from src.app.agents.project_manager import (
        ProjectManagerAgent,
        create_pm_registration,
    )
    registration = create_pm_registration()
    return ProjectManagerAgent(
        registration=registration,
        llm_service=AsyncMock(),
        rag_pipeline=AsyncMock(),
        notion_pm=AsyncMock(),
        gmail_service=AsyncMock(),
    )
```

**15 test cases across 7 test classes:**

**Class: TestCreateProjectPlan**
1. `test_pm_creates_plan_from_deliverables` -- Mock LLM returns valid ProjectPlan JSON (with phases, milestones, tasks). Assert result has "phases", "plan_id", "project_name" keys.
2. `test_pm_create_plan_fail_open` -- Mock LLM raises RuntimeError. Assert result has {"error": ..., "confidence": "low", "partial": True}.

**Class: TestDetectRisks**
3. `test_pm_detects_risks` -- Mock LLM returns list of RiskSignal dicts. Assert result has "risks" key with len > 0, each risk has "signal_type" and "severity".
4. `test_pm_detect_risks_empty_when_no_issues` -- Mock LLM returns empty list. Assert result has "risks" key with len == 0.
5. `test_pm_detect_risks_auto_adjust_chain` -- **NEW TEST for auto-adjust chain.** Mock LLM to return a list with one risk having severity="high". Mock the LLM to also return a valid ScopeChangeDelta JSON for the second call (the internal _handle_adjust_plan call). Assert:
   - Result contains "auto_adjustments" key
   - auto_adjustments list has len >= 1
   - The adjustment contains "recommendation" or "changes" keys (from ScopeChangeDelta)
   - If notion_pm mock was provided, verify `notion_pm.append_risk_log_entry` was called
   - If gmail_service mock was provided, verify `gmail_service.send_email` was called with subject containing "Risk Alert"

**Class: TestAdjustPlan**
6. `test_pm_produces_scope_change_delta` -- Mock LLM returns ScopeChangeDelta JSON. Assert result has "changes", "timeline_impact_days", "recommendation" keys.

**Class: TestGenerateStatusReport**
7. `test_pm_generates_internal_report` -- Mock LLM returns InternalStatusReport JSON. Assert result has "overall_rag", "milestone_progress", "earned_value", "agent_notes" keys.
8. `test_pm_generates_external_report` -- Mock LLM returns ExternalStatusReport JSON. Task has report_type="external". Assert result has "overall_status", "milestone_summary", "key_accomplishments" (NOT "agent_notes" or "deal_context").
9. `test_pm_report_earned_value_is_precalculated` -- Verify that the earned_value in the internal report result matches what calculate_earned_value() returns (not LLM-hallucinated). Mock LLM to return a report with EV values. The test should verify the handler called calculate_earned_value before the LLM call.
10. `test_pm_report_email_sent` -- **NEW TEST for email delivery.** Set up pm_agent with gmail_service=AsyncMock(). Provide deal_context with stakeholders: [{"name": "John", "email": "john@example.com"}]. Execute generate_status_report task. Assert:
    - `pm_agent._gmail_service.send_email` was called (assert_called_once or assert_called)
    - The call kwargs/args include "john@example.com" in the `to` parameter
    - The subject contains "Status Report"
    - The report itself is still returned successfully (email is side-effect, not blocking)
11. `test_pm_report_email_failure_does_not_break_report` -- **NEW TEST for email failure resilience.** Set gmail_service.send_email to raise an Exception. Execute generate_status_report. Assert the report is still returned successfully (no error key), proving email failure is non-blocking.

**Class: TestWriteCRMRecords**
12. `test_pm_write_crm_calls_notion_adapter` -- Task type="write_crm_records" with operation="create_project". Assert notion_pm mock method was called.
13. `test_pm_write_crm_no_adapter` -- pm_agent with notion_pm=None. Assert result has {"error": contains "not configured"}.
14. `test_pm_write_crm_milestone_event` -- **NEW TEST for milestone event CRM write.** Task type="write_crm_records" with operation="append_milestone", page_id="page-123", milestone_blocks=[{"type": "paragraph", ...}]. Assert:
    - notion_pm.append_milestone_event was called with page_id="page-123"
    - Result has {"status": "written", "operation": "append_milestone"}

**Class: TestRegistration**
15. `test_pm_registration_has_correct_capabilities` -- Assert agent_id=="project_manager", 6 capabilities, expected capability names.

**NOTE: The previous test_pm_unknown_task_type_raises_valueerror test is dropped in favor of the 3 new tests to keep the plan at ~15 tests. If desired it can be included as test 16, but the critical path is the 3 new tests.**

Actually, keep test 16:
16. `test_pm_unknown_task_type_raises_valueerror` -- Call execute with type="invalid". Assert ValueError raised with "create_project_plan" in message.

Total: **16 tests**.

**Mock LLM pattern (from SA tests):**
```python
# Mock returns JSON wrapped in code fences (testing strip logic)
mock_llm_response = {
    "content": '```json\n{"plan_id": "p-1", "deal_id": "d-1", ...}\n```'
}
pm_agent._llm_service.completion = AsyncMock(return_value=mock_llm_response)
```

For the auto-adjust chain test, mock LLM.completion with side_effect to return different JSON for the first call (risk detection) vs second call (adjust_plan):
```python
pm_agent._llm_service.completion = AsyncMock(side_effect=[
    {"content": '[{"signal_type": "milestone_overdue", "severity": "high", ...}]'},
    {"content": '{"changes": [...], "timeline_impact_days": 5, ...}'},
])
```

Use realistic JSON payloads in mocks that match the full Pydantic schema structure (all required fields present with valid values). Import datetime for date fields -- use `datetime.now().isoformat()` in JSON strings.

All tests should be async (use `@pytest.mark.asyncio` or `async def test_*`).
  </action>
  <verify>
Run: `uv run pytest tests/test_project_manager.py -v` -- all 16 tests pass
Run: `uv run pytest tests/ -x -q` -- all tests pass including existing (no regressions)
Count: `grep -c "async def test_\|def test_" tests/test_project_manager.py` returns 16
  </verify>
  <done>16 integration tests covering all 6 PM capabilities, fail-open behavior, CRM write delegation, earned value pre-calculation verification, email dispatch verification, email failure resilience, auto-adjust chain for high-severity risks, milestone event CRM write, and registration correctness. Zero regressions.</done>
</task>

</tasks>

<verification>
- `grep "apscheduler" pyproject.toml` returns a match
- `grep "phase11.project_manager_initialized" src/app/main.py` returns a match
- `uv run pytest tests/test_project_manager.py -v` -- 16 tests pass
- `uv run pytest tests/ -x -q` -- all tests pass (no regressions)
- PM agent accessible at app.state.project_manager after lifespan
- test_pm_report_email_sent proves email dispatch works
- test_pm_detect_risks_auto_adjust_chain proves risk->adjust->notify chain works
- test_pm_write_crm_milestone_event proves milestone CRM write works
</verification>

<success_criteria>
- APScheduler declared as dependency in pyproject.toml
- PM agent initializes in main.py lifespan using established pattern
- PM agent registers in AgentRegistry
- 16 integration tests cover all 6 capabilities, email delivery, auto-adjust chain, milestone writes, and edge cases
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/11-project-manager-agent/11-04-SUMMARY.md`
</output>
