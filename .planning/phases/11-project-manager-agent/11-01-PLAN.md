---
phase: 11-project-manager-agent
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/agents/project_manager/__init__.py
  - src/app/agents/project_manager/schemas.py
  - src/app/agents/project_manager/earned_value.py
  - src/app/handoffs/validators.py
autonomous: true

must_haves:
  truths:
    - "PM domain models exist for all 6 capabilities: WBS project plans, risk signals, scope change deltas, internal/external status reports, earned value metrics, and change requests"
    - "PM handoff types are registered in StrictnessConfig with correct strictness levels"
    - "Earned value calculations produce correct BCWP, ACWP, BCWS, CPI, SPI from task-level 0/100 rule"
  artifacts:
    - path: "src/app/agents/project_manager/schemas.py"
      provides: "All PM Pydantic models (~20 models covering WBS, risks, reports, change requests, triggers, handoff payloads)"
      min_lines: 300
    - path: "src/app/agents/project_manager/earned_value.py"
      provides: "Pure Python earned value calculation functions (no LLM)"
      min_lines: 50
      exports: ["calculate_earned_value", "EarnedValueMetrics"]
    - path: "src/app/agents/project_manager/__init__.py"
      provides: "Empty package init (populated in later plan)"
    - path: "src/app/handoffs/validators.py"
      provides: "PM handoff types registered: project_plan (STRICT), status_report (LENIENT), risk_alert (STRICT)"
  key_links:
    - from: "src/app/agents/project_manager/earned_value.py"
      to: "src/app/agents/project_manager/schemas.py"
      via: "imports EarnedValueMetrics, WBSTask from schemas"
      pattern: "from src.app.agents.project_manager.schemas import"
    - from: "src/app/handoffs/validators.py"
      to: "PM handoff types"
      via: "StrictnessConfig._rules dict entries"
      pattern: "project_plan.*STRICT|status_report.*LENIENT|risk_alert.*STRICT"
---

<objective>
Create all PM domain models (Pydantic schemas), earned value calculation module, and register PM handoff types in the shared validator config.

Purpose: Establishes the type foundation that every PM capability handler, prompt builder, and Notion adapter depends on. Without these schemas, no PM code can be written. The earned value module is pure arithmetic that should never go through an LLM.
Output: schemas.py with ~20 Pydantic models, earned_value.py with deterministic EV functions, updated validators.py with PM handoff rules, empty __init__.py for package structure.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-project-manager-agent/11-CONTEXT.md
@.planning/phases/11-project-manager-agent/11-RESEARCH.md

# Pattern reference -- clone this structure for PM schemas
@src/app/agents/solution_architect/schemas.py

# Handoff validator to extend with PM types
@src/app/handoffs/validators.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PM Pydantic schemas</name>
  <files>
    src/app/agents/project_manager/__init__.py
    src/app/agents/project_manager/schemas.py
  </files>
  <action>
Create the project_manager package directory and schema file following the SA schemas pattern (from_future annotations, Literal types, Field constraints, docstrings on every class/attribute).

**schemas.py must define these models in this order:**

1. **WBSTask** -- lowest WBS level: task_id (str), name (str), owner (str), duration_days (float, ge=0), dependencies (list[str] of task_ids, default_factory=list), status (Literal["not_started", "in_progress", "completed", "blocked"])

2. **WBSMilestone** -- middle WBS level: milestone_id (str), name (str), target_date (datetime), tasks (list[WBSTask]), success_criteria (str), status (Literal["not_started", "in_progress", "completed", "at_risk", "overdue"])

3. **WBSPhase** -- top WBS level: phase_id (str), name (str), milestones (list[WBSMilestone]), resource_estimate_days (float, ge=0)

4. **RiskThresholds** -- configurable per-project risk thresholds: milestone_overdue_days_short (int, default=1, doc="Threshold for milestones < 1 week"), milestone_overdue_days_long (int, default=3, doc="Threshold for milestones >= 2 weeks"), resource_exceeded_pct (float, default=0.2, doc="20% overrun triggers risk"), stalled_days (int, default=7, doc="Days of no CRM activity before stall alert")

5. **ProjectPlan** -- complete PMBOK plan: plan_id (str), deal_id (str), project_name (str), phases (list[WBSPhase]), created_at (datetime), updated_at (datetime), version (int, default=1), trigger_source (Literal["deal_won", "poc_scoped", "complex_deal", "manual"]), risk_thresholds (RiskThresholds, default_factory=RiskThresholds), total_budget_days (float, ge=0, computed from phases)

6. **RiskSignal** -- detected risk: risk_id (str), signal_type (Literal["milestone_overdue", "critical_path_blocked", "resource_exceeded", "deal_stage_stalled"]), severity (Literal["low", "medium", "high", "critical"]), description (str), affected_milestone_id (str | None = None), recommended_action (str), auto_adjustment (dict[str, Any] | None = None), detected_at (datetime)

7. **RiskLogEntry** -- risk log record: risk_id (str), signal_type (str), severity (str), description (str), owner (str), status (Literal["open", "mitigated", "closed", "accepted"]), created_at (datetime), resolved_at (datetime | None = None)

8. **MilestoneProgress** -- per-milestone progress: milestone_id (str), name (str), total_tasks (int), completed_tasks (int), pct_complete (float), status (Literal["on_track", "at_risk", "overdue", "completed"]), target_date (datetime), projected_date (datetime | None = None)

9. **ActionItem** -- next action: action_id (str), description (str), owner (str), due_date (datetime), status (Literal["pending", "in_progress", "completed"])

10. **EarnedValueMetrics** -- EV calculations: bcwp (float, doc="Budgeted Cost of Work Performed (earned value)"), acwp (float, doc="Actual Cost of Work Performed"), bcws (float, doc="Budgeted Cost of Work Scheduled (planned value)"), cpi (float, doc="Cost Performance Index = BCWP/ACWP"), spi (float, doc="Schedule Performance Index = BCWP/BCWS")

11. **InternalStatusReport** -- full detail for internal team: report_id (str), project_id (str), report_date (datetime), overall_rag (Literal["red", "amber", "green"]), milestone_progress (list[MilestoneProgress]), risks_and_issues (list[RiskLogEntry]), next_actions (list[ActionItem]), earned_value (EarnedValueMetrics), deal_context (dict[str, Any]), agent_notes (str), sa_summary (str)

12. **MilestoneSummary** -- polished milestone info for customer: name (str), status (str), estimated_completion (str)

13. **ExternalStatusReport** -- customer-facing (structurally different from Internal, NOT a subset): report_id (str), project_name (str), report_date (datetime), overall_status (Literal["On Track", "At Risk", "Delayed"]), milestone_summary (list[MilestoneSummary]), key_accomplishments (list[str]), upcoming_activities (list[str]), items_requiring_attention (list[str])

14. **PlanDelta** -- single change element: element_type (Literal["phase", "milestone", "task"]), element_id (str), field (str), original_value (str), revised_value (str), change_type (Literal["added", "removed", "modified"])

15. **ScopeChangeDelta** -- delta report: change_request_id (str), original_plan_version (int), revised_plan_version (int), trigger (Literal["sa_updated_requirements", "manual_input"]), changes (list[PlanDelta]), timeline_impact_days (int), resource_impact_days (float), affected_milestones (list[str]), risk_assessment (str), recommendation (Literal["approve", "approve_with_conditions", "reject_recommend_descope"])

16. **ChangeRequest** -- audit log entry: request_id (str), project_id (str), requested_by (str), description (str), status (Literal["pending", "approved", "declined"]), scope_change_delta (ScopeChangeDelta | None = None), created_at (datetime), resolved_at (datetime | None = None), resolved_by (str | None = None)

17. **PMTriggerEvent** -- trigger from event bus: trigger_type (Literal["deal_won", "poc_scoped", "complex_deal", "manual"]), deal_id (str), tenant_id (str), poc_plan (dict[str, Any] | None = None), deliverables (list[str] = Field(default_factory=list)), timeline (str | None = None), stakeholders (list[str] = Field(default_factory=list)), metadata (dict[str, Any] = Field(default_factory=dict))

18. **ProjectPlanHandoffPayload** -- handoff from PM to other agents: project_id (str), plan_id (str), deal_id (str), summary (str), milestone_count (int), total_budget_days (float), risk_count (int)

19. **StatusReportHandoffPayload** -- handoff from PM for distribution: report_id (str), project_id (str), report_type (Literal["internal", "external"]), recipients (list[str]), subject (str), body_html (str)

20. **RiskAlertHandoffPayload** -- handoff from PM when risk detected: risk_id (str), project_id (str), deal_id (str), signal_type (str), severity (str), description (str), recommended_action (str)

Include `__all__` at the bottom exporting all model names.

**__init__.py** should be an empty file with just a docstring:
```python
"""Project Manager agent package."""
```
  </action>
  <verify>
Run: `python -c "from src.app.agents.project_manager.schemas import *; print(len(__all__))"`
Expected: prints 20 (or close, depending on final model count)
Run: `python -c "from src.app.agents.project_manager.schemas import ProjectPlan, InternalStatusReport, ExternalStatusReport, EarnedValueMetrics; print('OK')"`
Expected: prints "OK"
  </verify>
  <done>All 20 PM Pydantic models importable, each with docstrings, Literal enums, Field constraints. __init__.py creates the package.</done>
</task>

<task type="auto">
  <name>Task 2: Register PM handoff types and create earned value module</name>
  <files>
    src/app/handoffs/validators.py
    src/app/agents/project_manager/earned_value.py
  </files>
  <action>
**Part A: Update validators.py**

Add 3 PM-specific handoff type rules to StrictnessConfig.__init__ (after the existing SA entries for technical_question and technical_answer):
- `"project_plan": ValidationStrictness.STRICT` -- carries structured WBS data, needs validation
- `"status_report": ValidationStrictness.LENIENT` -- informational, no action-triggering data
- `"risk_alert": ValidationStrictness.STRICT` -- triggers auto-adjustments, must be validated

This is an additive change. Do NOT modify existing rules. Add the 3 new entries at the end of the `_rules` dict in `__init__`.

**Part B: Create earned_value.py**

Create a pure Python module with NO LLM calls. This is deterministic arithmetic.

Import EarnedValueMetrics and WBSTask from schemas.py.

Implement `calculate_earned_value` function:
```python
def calculate_earned_value(
    tasks: list[WBSTask],
    actual_days_spent: float,
    scheduled_completion_pct: float,
) -> EarnedValueMetrics:
```

Logic (0/100 rule -- tasks are either 0% or 100% complete):
1. **BCWP** (Earned Value) = sum of `duration_days` for tasks where `status == "completed"`
2. **ACWP** = `actual_days_spent` (passed in directly)
3. **Total planned budget** = sum of `duration_days` for ALL tasks
4. **BCWS** (Planned Value) = total_planned_budget * scheduled_completion_pct
5. **CPI** = BCWP / ACWP if ACWP > 0 else 1.0
6. **SPI** = BCWP / BCWS if BCWS > 0 else 1.0

Return `EarnedValueMetrics(bcwp=bcwp, acwp=acwp, bcws=bcws, cpi=cpi, spi=spi)`.

Also implement a helper:
```python
def compute_milestone_progress(milestone: WBSMilestone) -> MilestoneProgress:
```
That computes completed_tasks, pct_complete (completed/total), and derives status from target_date comparison.

Import MilestoneProgress and WBSMilestone from schemas.

Add docstrings explaining the 0/100 rule and PMBOK EV formulas. Include `__all__` exporting both functions.
  </action>
  <verify>
Run: `python -c "
from src.app.agents.project_manager.schemas import WBSTask, EarnedValueMetrics
from src.app.agents.project_manager.earned_value import calculate_earned_value
tasks = [
    WBSTask(task_id='t1', name='A', owner='X', duration_days=5, status='completed'),
    WBSTask(task_id='t2', name='B', owner='Y', duration_days=10, status='not_started'),
]
ev = calculate_earned_value(tasks, actual_days_spent=6.0, scheduled_completion_pct=0.5)
assert ev.bcwp == 5.0  # only t1 completed
assert ev.acwp == 6.0
assert ev.bcws == 7.5   # (5+10) * 0.5
assert abs(ev.cpi - 5.0/6.0) < 0.01
assert abs(ev.spi - 5.0/7.5) < 0.01
print('EV calculations correct')
"`
Run: `python -c "
from src.app.handoffs.validators import StrictnessConfig, ValidationStrictness
c = StrictnessConfig()
assert c.get_strictness('project_plan') == ValidationStrictness.STRICT
assert c.get_strictness('status_report') == ValidationStrictness.LENIENT
assert c.get_strictness('risk_alert') == ValidationStrictness.STRICT
print('PM handoff rules registered')
"`
Run full test suite: `uv run pytest tests/ -x -q`
  </verify>
  <done>3 PM handoff types registered in StrictnessConfig. Earned value module produces correct BCWP/ACWP/BCWS/CPI/SPI using 0/100 rule. All existing tests pass.</done>
</task>

</tasks>

<verification>
- `python -c "from src.app.agents.project_manager import schemas"` succeeds
- `python -c "from src.app.agents.project_manager.earned_value import calculate_earned_value"` succeeds
- Earned value calculation returns correct metrics for a known input
- PM handoff types return expected strictness from StrictnessConfig
- `uv run pytest tests/ -x -q` -- all existing tests pass (no regressions)
</verification>

<success_criteria>
- 20 Pydantic models covering WBS, risks, reports, change requests, triggers, handoffs
- Earned value module with pure Python 0/100 rule calculations
- 3 PM handoff types registered in shared validator config
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/11-project-manager-agent/11-01-SUMMARY.md`
</output>
