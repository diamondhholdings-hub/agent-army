---
phase: 11-project-manager-agent
plan: 03
type: execute
wave: 3
depends_on: ["11-01", "11-02"]
files_modified:
  - src/app/agents/project_manager/agent.py
  - src/app/agents/project_manager/capabilities.py
  - src/app/agents/project_manager/scheduler.py
  - src/app/agents/project_manager/__init__.py
autonomous: true

must_haves:
  truths:
    - "ProjectManagerAgent routes tasks to 6 handlers via execute() method matching the BaseAgent pattern"
    - "Each handler follows fail-open semantics: LLM or parse errors return {error, confidence: low, partial: True}"
    - "Earned value metrics are computed by pure Python functions, never by LLM"
    - "Status report handler sends email to stakeholders via gmail_service after generating report"
    - "Detect risks handler auto-chains to adjust_plan for high/critical risks, then dispatches notification (CRM write + email) with NO human approval gate"
    - "CRM write handler supports append_milestone operation for recording milestone completion events"
    - "PM capabilities are declared with correct names and output schemas"
    - "Scheduler can start/stop and register weekly report jobs with implemented report generation logic"
  artifacts:
    - path: "src/app/agents/project_manager/agent.py"
      provides: "ProjectManagerAgent(BaseAgent) with 6 fail-open handlers, email dispatch in status report, auto-adjust chain in detect_risks"
      min_lines: 400
      exports: ["ProjectManagerAgent"]
    - path: "src/app/agents/project_manager/capabilities.py"
      provides: "PM_CAPABILITIES list + create_pm_registration() factory"
      min_lines: 60
      exports: ["PM_CAPABILITIES", "create_pm_registration"]
    - path: "src/app/agents/project_manager/scheduler.py"
      provides: "PMScheduler class wrapping APScheduler for weekly reports with implemented _generate_weekly_reports"
      min_lines: 60
      exports: ["PMScheduler"]
    - path: "src/app/agents/project_manager/__init__.py"
      provides: "Package re-exports for ProjectManagerAgent, capabilities, and all schema classes"
      min_lines: 20
  key_links:
    - from: "src/app/agents/project_manager/agent.py"
      to: "src/app/agents/project_manager/prompts.py"
      via: "imports all 6 prompt builder functions"
      pattern: "from src.app.agents.project_manager.prompts import"
    - from: "src/app/agents/project_manager/agent.py"
      to: "src/app/agents/project_manager/earned_value.py"
      via: "imports calculate_earned_value for status report handler"
      pattern: "from src.app.agents.project_manager.earned_value import calculate_earned_value"
    - from: "src/app/agents/project_manager/agent.py"
      to: "src/app/agents/project_manager/notion_pm.py"
      via: "stores NotionPMAdapter instance for CRM writes"
      pattern: "self._notion_pm"
    - from: "src/app/agents/project_manager/agent.py"
      to: "self._gmail_service"
      via: "status report handler calls gmail_service.send_email() after LLM parse"
      pattern: "self._gmail_service\\.send_email"
    - from: "src/app/agents/project_manager/agent.py"
      to: "_handle_adjust_plan"
      via: "detect_risks handler internally calls _handle_adjust_plan for high/critical risks"
      pattern: "_handle_adjust_plan.*inside.*_handle_detect_risks|auto.adjust"
    - from: "src/app/agents/project_manager/capabilities.py"
      to: "src/app/agents/base.py"
      via: "imports AgentCapability, AgentRegistration"
      pattern: "from src.app.agents.base import"
---

<objective>
Implement the ProjectManagerAgent class with 6 capability handlers, PM capabilities declaration with registration factory, weekly report scheduler, and complete package exports.

Purpose: This is the core PM agent -- the central class that receives tasks, routes to handlers, calls LLM with prompts, computes earned value deterministically, writes to CRM, sends email reports, auto-chains risk detection to plan adjustment, and returns structured results. Combined with the capabilities module, the PM agent becomes registerable in the AgentRegistry.
Output: agent.py with ProjectManagerAgent(BaseAgent), capabilities.py with PM_CAPABILITIES + factory, scheduler.py with PMScheduler, updated __init__.py with full re-exports.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-project-manager-agent/11-CONTEXT.md
@.planning/phases/11-project-manager-agent/11-RESEARCH.md

# Prior plan SUMMARYs for schema and prompt references
@.planning/phases/11-project-manager-agent/11-01-SUMMARY.md
@.planning/phases/11-project-manager-agent/11-02-SUMMARY.md

# Pattern reference -- clone these exactly for PM agent
@src/app/agents/solution_architect/agent.py
@src/app/agents/solution_architect/capabilities.py
@src/app/agents/solution_architect/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ProjectManagerAgent with 6 handlers</name>
  <files>src/app/agents/project_manager/agent.py</files>
  <action>
Create agent.py following the SolutionArchitectAgent pattern exactly. Module docstring, imports, class with BaseAgent inheritance, execute() router, 6 handler methods, helpers section.

**Class: ProjectManagerAgent(BaseAgent)**

Constructor:
```python
def __init__(
    self,
    registration: AgentRegistration,
    llm_service: object,
    rag_pipeline: object | None = None,
    notion_pm: object | None = None,
    gmail_service: object | None = None,
) -> None:
```
- Call `super().__init__(registration)`
- Store _llm_service, _rag_pipeline, _notion_pm, _gmail_service
- Create structlog logger bound to agent_id and agent_name

**execute() router** -- routes by task["type"]:
```python
handlers = {
    "create_project_plan": self._handle_create_project_plan,
    "detect_risks": self._handle_detect_risks,
    "adjust_plan": self._handle_adjust_plan,
    "generate_status_report": self._handle_generate_status_report,
    "write_crm_records": self._handle_write_crm_records,
    "process_trigger": self._handle_process_trigger,
}
```
Raise ValueError for unknown task types (include list of supported types in error).

**6 Handler methods** (all follow same pattern: try/except with fail-open):

1. `_handle_create_project_plan(task, context)`:
   - Extract deliverables, deal_context, sa_artifacts, timeline from task
   - Query RAG for project planning context (content_types=["methodology", "product"])
   - Call build_create_plan_prompt()
   - LLM completion with temperature=0.3, max_tokens=4096, model="reasoning"
   - Parse JSON with _parse_llm_json() into ProjectPlan
   - Return plan.model_dump()
   - Fail-open on error: {"error": str(exc), "confidence": "low", "partial": True}

2. `_handle_detect_risks(task, context)`:
   - Extract plan_json, current_progress, deal_context from task
   - Call build_detect_risks_prompt()
   - LLM completion with temperature=0.2, max_tokens=2048
   - Parse response as list of RiskSignal dicts
   - **AUTO-ADJUST CHAIN (CRITICAL -- locked decision: "Risk response: Flag + auto-adjust + notify, NO human approval gate"):**
     After parsing risks, for each risk with severity "high" or "critical":
     1. Automatically call `_handle_adjust_plan` internally, passing:
        - `original_plan_json=plan_json`
        - `scope_change_description=risk["description"]`
        - `trigger=f"auto_risk_response:{risk['signal_type']}"`
        - `deal_context=deal_context`
        This mirrors the pattern in `_handle_process_trigger` which already internally calls `_handle_create_project_plan`.
     2. After adjust_plan returns, dispatch notifications:
        - CRM write: If self._notion_pm is not None, call `self._notion_pm.append_risk_log_entry()` with risk details + adjustment delta
        - Email: If self._gmail_service is not None, extract stakeholder emails from deal_context.get("stakeholders", []), format a risk alert email body (risk description + severity + auto-adjustment summary), call `self._gmail_service.send_email(to=recipients, subject=f"Risk Alert: {risk['signal_type']}", body=body)`
     3. Collect adjustment results into an `auto_adjustments` list
   - Return {"risks": parsed_risks, "risk_count": len(parsed_risks), "auto_adjustments": auto_adjustments}
   - Wrap the auto-adjust chain in its own try/except so that chain failure does NOT fail the overall risk detection (log warning and continue)
   - Fail-open on overall error

3. `_handle_adjust_plan(task, context)`:
   - Extract original_plan_json, scope_change_description, trigger from task
   - Call build_adjust_plan_prompt()
   - LLM completion with temperature=0.3, max_tokens=4096
   - Parse into ScopeChangeDelta
   - Return delta.model_dump()
   - Fail-open on error

4. `_handle_generate_status_report(task, context)`:
   - Extract plan_json, progress_data, deal_context, sa_summary from task
   - **CRITICAL: Calculate earned value FIRST using pure Python** (not LLM):
     - Parse plan_json to get tasks list
     - Extract actual_days_spent and scheduled_completion_pct from progress_data
     - Call `calculate_earned_value()` from earned_value module
     - Serialize EV metrics to JSON string
   - Determine report_type from task (default "internal")
   - If internal: call build_internal_report_prompt() with pre-calculated EV
   - If external: call build_external_report_prompt()
   - LLM completion with temperature=0.3, max_tokens=4096
   - Parse into InternalStatusReport or ExternalStatusReport based on report_type
   - **EMAIL DELIVERY (CRITICAL -- locked decision: "Delivery: Email (Gmail) + CRM record"):**
     After successful LLM parse, deliver the report via email:
     1. Extract recipients from deal_context: `deal_context.get("stakeholders", [])` -- each stakeholder should have an "email" field. If report_type is "external", filter to external stakeholders only. If "internal", include all (AE + internal team).
     2. Format email body: render report as readable text/HTML (use report.model_dump() fields -- overall_rag/overall_status, milestone_progress summary, next actions). For internal reports include earned_value and risk sections. For external reports use polished customer-facing language.
     3. If self._gmail_service is not None and recipients list is non-empty:
        - Call `await self._gmail_service.send_email(to=recipients, subject=f"Project Status Report: {report.project_name or task.get('project_name', 'Project')}", body=formatted_body)`
        - Log success with structlog: `self._log.info("pm_report_email_sent", recipient_count=len(recipients), report_type=report_type)`
     4. If gmail_service is None, log warning: `self._log.warning("pm_report_email_skipped", reason="gmail_service not configured")`
     5. Wrap email sending in try/except -- email failure should NOT fail the report generation (log error and continue)
   - Return report.model_dump()
   - Fail-open on overall error

5. `_handle_write_crm_records(task, context)`:
   - Extract operation (one of: "create_project", "update_metrics", "append_report", "append_risk", "append_change", "append_milestone"), plus operation-specific data
   - If self._notion_pm is None, return {"error": "NotionPM adapter not configured", "partial": True}
   - Route to appropriate NotionPMAdapter method based on operation:
     - "create_project" -> self._notion_pm.create_project_record(data)
     - "update_metrics" -> self._notion_pm.update_project_metrics(page_id, metrics)
     - "append_report" -> self._notion_pm.append_status_report(page_id, blocks)
     - "append_risk" -> self._notion_pm.append_risk_log_entry(page_id, blocks)
     - "append_change" -> self._notion_pm.append_change_request(page_id, blocks)
     - "append_milestone" -> self._notion_pm.append_milestone_event(page_id, milestone_blocks)
   - Return {"status": "written", "operation": operation}
   - Fail-open on error

6. `_handle_process_trigger(task, context)`:
   - Extract trigger_type, deal_id, deliverables, sa_artifacts from task
   - Query RAG for deal context
   - Call build_process_trigger_prompt()
   - LLM completion with temperature=0.3, max_tokens=2048
   - Parse response as trigger analysis dict
   - If trigger analysis recommends creating a plan, call _handle_create_project_plan internally
   - Return {"trigger_processed": True, "trigger_type": trigger_type, "plan": plan_result_or_None}
   - Fail-open on error

**Helpers section** (same pattern as SA agent):

- `_query_rag()` -- identical to SA agent's _query_rag (fail-open, returns empty string)
- `_parse_llm_json()` -- identical to SA agent's _parse_llm_json (strip code fences, parse, validate)

Both helpers should be copied from SA agent with no modifications (they are generic utilities).
  </action>
  <verify>
Run: `python -c "
from src.app.agents.project_manager.agent import ProjectManagerAgent
from src.app.agents.base import AgentRegistration
print('ProjectManagerAgent importable')
# Verify it has all 6 handler methods
import inspect
methods = [m for m in dir(ProjectManagerAgent) if m.startswith('_handle_')]
assert len(methods) == 6, f'Expected 6 handlers, got {len(methods)}: {methods}'
print(f'Has {len(methods)} handlers: {methods}')
# Verify source contains gmail and auto-adjust wiring
src = inspect.getsource(ProjectManagerAgent)
assert 'send_email' in src, 'Missing gmail send_email call in agent source'
assert 'auto_adjustments' in src, 'Missing auto_adjustments in detect_risks handler'
assert 'append_milestone' in src, 'Missing append_milestone in write_crm handler'
print('Email dispatch, auto-adjust chain, and milestone ops confirmed in source')
"`
  </verify>
  <done>ProjectManagerAgent extends BaseAgent with execute() routing to 6 handlers. Each handler follows fail-open pattern. Status report handler computes earned value via pure Python before LLM call AND dispatches email to stakeholders. Detect risks handler auto-chains to adjust_plan for high/critical risks and dispatches CRM + email notifications. CRM write handler supports append_milestone operation.</done>
</task>

<task type="auto">
  <name>Task 2: Create capabilities, scheduler, and package init</name>
  <files>
    src/app/agents/project_manager/capabilities.py
    src/app/agents/project_manager/scheduler.py
    src/app/agents/project_manager/__init__.py
  </files>
  <action>
**capabilities.py** -- clone from SA capabilities.py pattern:

Import AgentCapability, AgentRegistration from base. Import PM output schemas.

Define `PM_CAPABILITIES: list[AgentCapability]` with 6 entries:
1. `create_project_plan` -- "Generate a PMBOK-compliant 3-level WBS project plan from deal deliverables and SA artifacts", output_schema=ProjectPlan
2. `detect_risks` -- "Analyze milestone progress against plan and flag predicted schedule delays", output_schema=RiskSignal (note: handler returns list, but schema reference is the element type)
3. `adjust_plan` -- "Produce a scope change delta report showing adjusted plan when scope changes are introduced", output_schema=ScopeChangeDelta
4. `generate_status_report` -- "Generate internal and customer-facing status reports with RAG, risks, and earned value metrics", output_schema=InternalStatusReport
5. `write_crm_records` -- "Write project plan, milestones, risk log, and status reports to Notion CRM", output_schema=None (CRM operations, no structured LLM output)
6. `process_trigger` -- "Process trigger events (deal won, POC scoped, complex deal, manual) to initiate project planning", output_schema=PMTriggerEvent

Define `create_pm_registration() -> AgentRegistration`:
- agent_id="project_manager"
- name="Project Manager"
- description="Project lifecycle management agent that creates PMBOK-compliant project plans, detects schedule risks, auto-adjusts plans on scope changes, generates status reports with earned value metrics, and integrates with CRM"
- capabilities=PM_CAPABILITIES
- backup_agent_id=None
- tags=["project_management", "planning", "risk", "reporting", "crm"]
- max_concurrent_tasks=3

**scheduler.py** -- lightweight APScheduler wrapper:

Graceful import of APScheduler (try/except with helpful error message, similar to notion-client import pattern).

```python
class PMScheduler:
    """Lightweight scheduler for weekly PM status reports.

    Uses APScheduler AsyncIOScheduler for cron-based job scheduling.
    Falls back gracefully if APScheduler is not installed.
    """

    def __init__(self, pm_agent, notion_pm=None, gmail_service=None):
        self._pm_agent = pm_agent
        self._notion_pm = notion_pm
        self._gmail_service = gmail_service
        self._scheduler = None
        self._started = False

    def start(self) -> bool:
        """Start the scheduler. Returns False if APScheduler not available."""
        if AsyncIOScheduler is None:
            logger.warning("pm_scheduler_unavailable", reason="apscheduler not installed")
            return False
        self._scheduler = AsyncIOScheduler()
        self._scheduler.add_job(
            self._generate_weekly_reports,
            trigger=CronTrigger(day_of_week="mon", hour=9, minute=0),
            id="pm_weekly_reports",
            name="Generate weekly PM status reports",
            misfire_grace_time=3600,  # 1 hour grace period
        )
        self._scheduler.start()
        self._started = True
        logger.info("pm_scheduler_started", job="weekly_reports", schedule="Monday 9:00 AM")
        return True

    async def _generate_weekly_reports(self):
        """Generate status reports for all active projects.

        Queries active projects from Notion and invokes PM agent for each.
        Logs errors per-project to avoid one failure blocking all reports.
        """
        logger.info("pm_weekly_reports_triggered")

        # Step 1: Query active projects from Notion
        if self._notion_pm is None:
            logger.warning("pm_weekly_reports_skipped", reason="notion_pm not configured")
            return

        try:
            # Query Projects database for active projects (Status = "Active")
            active_projects = await self._notion_pm.query_active_projects()
        except Exception as exc:
            logger.error("pm_weekly_reports_query_failed", error=str(exc))
            return

        if not active_projects:
            logger.info("pm_weekly_reports_none_active", count=0)
            return

        logger.info("pm_weekly_reports_processing", project_count=len(active_projects))

        # Step 2: For each active project, invoke PM agent with generate_status_report
        results = {"success": 0, "failed": 0}
        for project in active_projects:
            try:
                task = {
                    "type": "generate_status_report",
                    "plan_json": project.get("plan_json", "{}"),
                    "progress_data": project.get("progress_data", "{}"),
                    "deal_context": project.get("deal_context", {}),
                    "sa_summary": project.get("sa_summary", ""),
                    "report_type": "internal",
                    "project_name": project.get("project_name", "Unknown"),
                }
                result = await self._pm_agent.execute(task, context={})
                if "error" not in result:
                    results["success"] += 1
                else:
                    results["failed"] += 1
                    logger.warning(
                        "pm_weekly_report_partial",
                        project=project.get("project_name"),
                        error=result.get("error"),
                    )
            except Exception as exc:
                results["failed"] += 1
                logger.error(
                    "pm_weekly_report_failed",
                    project=project.get("project_name"),
                    error=str(exc),
                )

        logger.info("pm_weekly_reports_complete", **results)

    def stop(self):
        """Shut down the scheduler."""
        if self._scheduler and self._started:
            self._scheduler.shutdown(wait=False)
            self._started = False
            logger.info("pm_scheduler_stopped")
```

Use graceful import pattern:
```python
try:
    from apscheduler.schedulers.asyncio import AsyncIOScheduler
    from apscheduler.triggers.cron import CronTrigger
except ImportError:
    AsyncIOScheduler = None
    CronTrigger = None
```

Also add a `query_active_projects` method stub to NotionPMAdapter (in the scheduler module, reference it as a duck-typed dependency -- the scheduler calls `self._notion_pm.query_active_projects()` and the adapter provides it). **NOTE: Do NOT modify notion_pm.py here (it belongs to Plan 02). Instead, the scheduler should handle the case where `query_active_projects` is not available by catching AttributeError and logging a warning.**

**__init__.py** -- re-export public API:

Following SA __init__.py pattern, re-export:
- ProjectManagerAgent from agent
- PM_CAPABILITIES, create_pm_registration from capabilities
- PMScheduler from scheduler
- All schema classes from schemas (all 20 models)
- calculate_earned_value, compute_milestone_progress from earned_value
- NotionPMAdapter, render_wbs_to_notion_blocks from notion_pm

Include `__all__` listing all exported names.
  </action>
  <verify>
Run: `python -c "
from src.app.agents.project_manager import (
    ProjectManagerAgent,
    PM_CAPABILITIES,
    create_pm_registration,
    PMScheduler,
    ProjectPlan,
    InternalStatusReport,
    ExternalStatusReport,
    EarnedValueMetrics,
    calculate_earned_value,
    NotionPMAdapter,
)
reg = create_pm_registration()
assert reg.agent_id == 'project_manager'
assert len(PM_CAPABILITIES) == 6
cap_names = [c.name for c in PM_CAPABILITIES]
assert 'create_project_plan' in cap_names
assert 'detect_risks' in cap_names
assert 'generate_status_report' in cap_names
print(f'PM registration: {reg.agent_id}, {len(PM_CAPABILITIES)} capabilities')
print(f'Capabilities: {cap_names}')

# Verify scheduler has implemented _generate_weekly_reports (not just pass)
import inspect
src = inspect.getsource(PMScheduler._generate_weekly_reports)
assert 'pass' not in src or 'active_projects' in src, 'Scheduler _generate_weekly_reports appears to be a stub'
assert 'query_active_projects' in src, 'Scheduler must query active projects'
print('PMScheduler._generate_weekly_reports is implemented (not a stub)')
"`
Run: `uv run pytest tests/ -x -q` (ensure no regressions)
  </verify>
  <done>PM_CAPABILITIES with 6 entries. create_pm_registration() factory. PMScheduler with graceful APScheduler import and fully implemented _generate_weekly_reports that queries active projects and invokes PM agent per project. __init__.py re-exports full PM public API.</done>
</task>

</tasks>

<verification>
- ProjectManagerAgent importable with 6 handler methods
- execute() routes to correct handler by task type
- Unknown task type raises ValueError with supported types list
- Status report handler sends email via gmail_service after report generation
- Detect risks handler auto-chains to adjust_plan for high/critical severity risks
- CRM write handler supports "append_milestone" operation
- PM_CAPABILITIES has 6 entries matching handler names
- create_pm_registration returns AgentRegistration with agent_id="project_manager"
- PMScheduler importable, handles missing APScheduler gracefully, _generate_weekly_reports is implemented
- __init__.py re-exports all public symbols
- `uv run pytest tests/ -x -q` -- all existing tests pass
</verification>

<success_criteria>
- ProjectManagerAgent with 6 fail-open handlers following SA agent pattern
- Status report handler uses pure Python EV calculation before LLM call, then dispatches email
- Detect risks handler auto-chains to adjust_plan + notification for high/critical risks
- CRM write handler routes "append_milestone" to NotionPMAdapter.append_milestone_event
- PM registration factory with 6 capabilities
- PMScheduler with graceful APScheduler fallback and implemented weekly report generation
- Complete package __init__.py with all re-exports
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/11-project-manager-agent/11-03-SUMMARY.md`
</output>
