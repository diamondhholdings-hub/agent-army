---
phase: 11-project-manager-agent
plan: 03
type: execute
wave: 3
depends_on: ["11-01", "11-02"]
files_modified:
  - src/app/agents/project_manager/agent.py
  - src/app/agents/project_manager/capabilities.py
  - src/app/agents/project_manager/scheduler.py
  - src/app/agents/project_manager/__init__.py
autonomous: true

must_haves:
  truths:
    - "ProjectManagerAgent routes tasks to 6 handlers via execute() method matching the BaseAgent pattern"
    - "Each handler follows fail-open semantics: LLM or parse errors return {error, confidence: low, partial: True}"
    - "Earned value metrics are computed by pure Python functions, never by LLM"
    - "PM capabilities are declared with correct names and output schemas"
    - "Scheduler can start/stop and register weekly report jobs"
  artifacts:
    - path: "src/app/agents/project_manager/agent.py"
      provides: "ProjectManagerAgent(BaseAgent) with 6 fail-open handlers"
      min_lines: 350
      exports: ["ProjectManagerAgent"]
    - path: "src/app/agents/project_manager/capabilities.py"
      provides: "PM_CAPABILITIES list + create_pm_registration() factory"
      min_lines: 60
      exports: ["PM_CAPABILITIES", "create_pm_registration"]
    - path: "src/app/agents/project_manager/scheduler.py"
      provides: "PMScheduler class wrapping APScheduler for weekly reports"
      min_lines: 40
      exports: ["PMScheduler"]
    - path: "src/app/agents/project_manager/__init__.py"
      provides: "Package re-exports for ProjectManagerAgent, capabilities, and all schema classes"
      min_lines: 20
  key_links:
    - from: "src/app/agents/project_manager/agent.py"
      to: "src/app/agents/project_manager/prompts.py"
      via: "imports all 6 prompt builder functions"
      pattern: "from src.app.agents.project_manager.prompts import"
    - from: "src/app/agents/project_manager/agent.py"
      to: "src/app/agents/project_manager/earned_value.py"
      via: "imports calculate_earned_value for status report handler"
      pattern: "from src.app.agents.project_manager.earned_value import calculate_earned_value"
    - from: "src/app/agents/project_manager/agent.py"
      to: "src/app/agents/project_manager/notion_pm.py"
      via: "stores NotionPMAdapter instance for CRM writes"
      pattern: "self._notion_pm"
    - from: "src/app/agents/project_manager/capabilities.py"
      to: "src/app/agents/base.py"
      via: "imports AgentCapability, AgentRegistration"
      pattern: "from src.app.agents.base import"
---

<objective>
Implement the ProjectManagerAgent class with 6 capability handlers, PM capabilities declaration with registration factory, weekly report scheduler, and complete package exports.

Purpose: This is the core PM agent -- the central class that receives tasks, routes to handlers, calls LLM with prompts, computes earned value deterministically, writes to CRM, and returns structured results. Combined with the capabilities module, the PM agent becomes registerable in the AgentRegistry.
Output: agent.py with ProjectManagerAgent(BaseAgent), capabilities.py with PM_CAPABILITIES + factory, scheduler.py with PMScheduler, updated __init__.py with full re-exports.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-project-manager-agent/11-CONTEXT.md
@.planning/phases/11-project-manager-agent/11-RESEARCH.md

# Prior plan SUMMARYs for schema and prompt references
@.planning/phases/11-project-manager-agent/11-01-SUMMARY.md
@.planning/phases/11-project-manager-agent/11-02-SUMMARY.md

# Pattern reference -- clone these exactly for PM agent
@src/app/agents/solution_architect/agent.py
@src/app/agents/solution_architect/capabilities.py
@src/app/agents/solution_architect/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ProjectManagerAgent with 6 handlers</name>
  <files>src/app/agents/project_manager/agent.py</files>
  <action>
Create agent.py following the SolutionArchitectAgent pattern exactly. Module docstring, imports, class with BaseAgent inheritance, execute() router, 6 handler methods, helpers section.

**Class: ProjectManagerAgent(BaseAgent)**

Constructor:
```python
def __init__(
    self,
    registration: AgentRegistration,
    llm_service: object,
    rag_pipeline: object | None = None,
    notion_pm: object | None = None,
    gmail_service: object | None = None,
) -> None:
```
- Call `super().__init__(registration)`
- Store _llm_service, _rag_pipeline, _notion_pm, _gmail_service
- Create structlog logger bound to agent_id and agent_name

**execute() router** -- routes by task["type"]:
```python
handlers = {
    "create_project_plan": self._handle_create_project_plan,
    "detect_risks": self._handle_detect_risks,
    "adjust_plan": self._handle_adjust_plan,
    "generate_status_report": self._handle_generate_status_report,
    "write_crm_records": self._handle_write_crm_records,
    "process_trigger": self._handle_process_trigger,
}
```
Raise ValueError for unknown task types (include list of supported types in error).

**6 Handler methods** (all follow same pattern: try/except with fail-open):

1. `_handle_create_project_plan(task, context)`:
   - Extract deliverables, deal_context, sa_artifacts, timeline from task
   - Query RAG for project planning context (content_types=["methodology", "product"])
   - Call build_create_plan_prompt()
   - LLM completion with temperature=0.3, max_tokens=4096, model="reasoning"
   - Parse JSON with _parse_llm_json() into ProjectPlan
   - Return plan.model_dump()
   - Fail-open on error: {"error": str(exc), "confidence": "low", "partial": True}

2. `_handle_detect_risks(task, context)`:
   - Extract plan_json, current_progress, deal_context from task
   - Call build_detect_risks_prompt()
   - LLM completion with temperature=0.2, max_tokens=2048
   - Parse response as list of RiskSignal dicts
   - Return {"risks": parsed_risks, "risk_count": len(parsed_risks)}
   - Fail-open on error

3. `_handle_adjust_plan(task, context)`:
   - Extract original_plan_json, scope_change_description, trigger from task
   - Call build_adjust_plan_prompt()
   - LLM completion with temperature=0.3, max_tokens=4096
   - Parse into ScopeChangeDelta
   - Return delta.model_dump()
   - Fail-open on error

4. `_handle_generate_status_report(task, context)`:
   - Extract plan_json, progress_data, deal_context, sa_summary from task
   - **CRITICAL: Calculate earned value FIRST using pure Python** (not LLM):
     - Parse plan_json to get tasks list
     - Extract actual_days_spent and scheduled_completion_pct from progress_data
     - Call `calculate_earned_value()` from earned_value module
     - Serialize EV metrics to JSON string
   - Determine report_type from task (default "internal")
   - If internal: call build_internal_report_prompt() with pre-calculated EV
   - If external: call build_external_report_prompt()
   - LLM completion with temperature=0.3, max_tokens=4096
   - Parse into InternalStatusReport or ExternalStatusReport based on report_type
   - Return report.model_dump()
   - Fail-open on error

5. `_handle_write_crm_records(task, context)`:
   - Extract operation (one of: "create_project", "update_metrics", "append_report", "append_risk", "append_change"), plus operation-specific data
   - If self._notion_pm is None, return {"error": "NotionPM adapter not configured", "partial": True}
   - Route to appropriate NotionPMAdapter method based on operation
   - Return {"status": "written", "operation": operation}
   - Fail-open on error

6. `_handle_process_trigger(task, context)`:
   - Extract trigger_type, deal_id, deliverables, sa_artifacts from task
   - Query RAG for deal context
   - Call build_process_trigger_prompt()
   - LLM completion with temperature=0.3, max_tokens=2048
   - Parse response as trigger analysis dict
   - If trigger analysis recommends creating a plan, call _handle_create_project_plan internally
   - Return {"trigger_processed": True, "trigger_type": trigger_type, "plan": plan_result_or_None}
   - Fail-open on error

**Helpers section** (same pattern as SA agent):

- `_query_rag()` -- identical to SA agent's _query_rag (fail-open, returns empty string)
- `_parse_llm_json()` -- identical to SA agent's _parse_llm_json (strip code fences, parse, validate)

Both helpers should be copied from SA agent with no modifications (they are generic utilities).
  </action>
  <verify>
Run: `python -c "
from src.app.agents.project_manager.agent import ProjectManagerAgent
from src.app.agents.base import AgentRegistration
print('ProjectManagerAgent importable')
# Verify it has all 6 handler methods
import inspect
methods = [m for m in dir(ProjectManagerAgent) if m.startswith('_handle_')]
assert len(methods) == 6, f'Expected 6 handlers, got {len(methods)}: {methods}'
print(f'Has {len(methods)} handlers: {methods}')
"`
  </verify>
  <done>ProjectManagerAgent extends BaseAgent with execute() routing to 6 handlers. Each handler follows fail-open pattern. Status report handler computes earned value via pure Python before LLM call. CRM write handler delegates to NotionPMAdapter.</done>
</task>

<task type="auto">
  <name>Task 2: Create capabilities, scheduler, and package init</name>
  <files>
    src/app/agents/project_manager/capabilities.py
    src/app/agents/project_manager/scheduler.py
    src/app/agents/project_manager/__init__.py
  </files>
  <action>
**capabilities.py** -- clone from SA capabilities.py pattern:

Import AgentCapability, AgentRegistration from base. Import PM output schemas.

Define `PM_CAPABILITIES: list[AgentCapability]` with 6 entries:
1. `create_project_plan` -- "Generate a PMBOK-compliant 3-level WBS project plan from deal deliverables and SA artifacts", output_schema=ProjectPlan
2. `detect_risks` -- "Analyze milestone progress against plan and flag predicted schedule delays", output_schema=RiskSignal (note: handler returns list, but schema reference is the element type)
3. `adjust_plan` -- "Produce a scope change delta report showing adjusted plan when scope changes are introduced", output_schema=ScopeChangeDelta
4. `generate_status_report` -- "Generate internal and customer-facing status reports with RAG, risks, and earned value metrics", output_schema=InternalStatusReport
5. `write_crm_records` -- "Write project plan, milestones, risk log, and status reports to Notion CRM", output_schema=None (CRM operations, no structured LLM output)
6. `process_trigger` -- "Process trigger events (deal won, POC scoped, complex deal, manual) to initiate project planning", output_schema=PMTriggerEvent

Define `create_pm_registration() -> AgentRegistration`:
- agent_id="project_manager"
- name="Project Manager"
- description="Project lifecycle management agent that creates PMBOK-compliant project plans, detects schedule risks, auto-adjusts plans on scope changes, generates status reports with earned value metrics, and integrates with CRM"
- capabilities=PM_CAPABILITIES
- backup_agent_id=None
- tags=["project_management", "planning", "risk", "reporting", "crm"]
- max_concurrent_tasks=3

**scheduler.py** -- lightweight APScheduler wrapper:

Graceful import of APScheduler (try/except with helpful error message, similar to notion-client import pattern).

```python
class PMScheduler:
    """Lightweight scheduler for weekly PM status reports.

    Uses APScheduler AsyncIOScheduler for cron-based job scheduling.
    Falls back gracefully if APScheduler is not installed.
    """

    def __init__(self, pm_agent, notion_pm=None, gmail_service=None):
        self._pm_agent = pm_agent
        self._notion_pm = notion_pm
        self._gmail_service = gmail_service
        self._scheduler = None
        self._started = False

    def start(self) -> bool:
        """Start the scheduler. Returns False if APScheduler not available."""
        if AsyncIOScheduler is None:
            logger.warning("pm_scheduler_unavailable", reason="apscheduler not installed")
            return False
        self._scheduler = AsyncIOScheduler()
        self._scheduler.add_job(
            self._generate_weekly_reports,
            trigger=CronTrigger(day_of_week="mon", hour=9, minute=0),
            id="pm_weekly_reports",
            name="Generate weekly PM status reports",
            misfire_grace_time=3600,  # 1 hour grace period
        )
        self._scheduler.start()
        self._started = True
        logger.info("pm_scheduler_started", job="weekly_reports", schedule="Monday 9:00 AM")
        return True

    async def _generate_weekly_reports(self):
        """Generate status reports for all active projects.

        Queries active projects and invokes PM agent for each.
        Logs errors per-project to avoid one failure blocking all reports.
        """
        logger.info("pm_weekly_reports_triggered")
        # Implementation will query active projects from Notion/DB
        # and invoke PM agent with generate_status_report task for each
        pass

    def stop(self):
        """Shut down the scheduler."""
        if self._scheduler and self._started:
            self._scheduler.shutdown(wait=False)
            self._started = False
            logger.info("pm_scheduler_stopped")
```

Use graceful import pattern:
```python
try:
    from apscheduler.schedulers.asyncio import AsyncIOScheduler
    from apscheduler.triggers.cron import CronTrigger
except ImportError:
    AsyncIOScheduler = None
    CronTrigger = None
```

**__init__.py** -- re-export public API:

Following SA __init__.py pattern, re-export:
- ProjectManagerAgent from agent
- PM_CAPABILITIES, create_pm_registration from capabilities
- PMScheduler from scheduler
- All schema classes from schemas (all 20 models)
- calculate_earned_value, compute_milestone_progress from earned_value
- NotionPMAdapter, render_wbs_to_notion_blocks from notion_pm

Include `__all__` listing all exported names.
  </action>
  <verify>
Run: `python -c "
from src.app.agents.project_manager import (
    ProjectManagerAgent,
    PM_CAPABILITIES,
    create_pm_registration,
    PMScheduler,
    ProjectPlan,
    InternalStatusReport,
    ExternalStatusReport,
    EarnedValueMetrics,
    calculate_earned_value,
    NotionPMAdapter,
)
reg = create_pm_registration()
assert reg.agent_id == 'project_manager'
assert len(PM_CAPABILITIES) == 6
cap_names = [c.name for c in PM_CAPABILITIES]
assert 'create_project_plan' in cap_names
assert 'detect_risks' in cap_names
assert 'generate_status_report' in cap_names
print(f'PM registration: {reg.agent_id}, {len(PM_CAPABILITIES)} capabilities')
print(f'Capabilities: {cap_names}')
"`
Run: `uv run pytest tests/ -x -q` (ensure no regressions)
  </verify>
  <done>PM_CAPABILITIES with 6 entries. create_pm_registration() factory. PMScheduler with graceful APScheduler import. __init__.py re-exports full PM public API.</done>
</task>

</tasks>

<verification>
- ProjectManagerAgent importable with 6 handler methods
- execute() routes to correct handler by task type
- Unknown task type raises ValueError with supported types list
- PM_CAPABILITIES has 6 entries matching handler names
- create_pm_registration returns AgentRegistration with agent_id="project_manager"
- PMScheduler importable, handles missing APScheduler gracefully
- __init__.py re-exports all public symbols
- `uv run pytest tests/ -x -q` -- all existing tests pass
</verification>

<success_criteria>
- ProjectManagerAgent with 6 fail-open handlers following SA agent pattern
- Status report handler uses pure Python EV calculation before LLM call
- PM registration factory with 6 capabilities
- PMScheduler with graceful APScheduler fallback
- Complete package __init__.py with all re-exports
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/11-project-manager-agent/11-03-SUMMARY.md`
</output>
