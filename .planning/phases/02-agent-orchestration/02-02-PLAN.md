---
phase: 02-agent-orchestration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/agents/__init__.py
  - src/app/agents/base.py
  - src/app/agents/registry.py
  - tests/test_agent_registry.py
autonomous: true

must_haves:
  truths:
    - "Agents can register with typed capabilities and be discovered by capability name"
    - "Backup agents can be retrieved for failure routing (preventing single-agent-of-failure)"
    - "Agent registry provides a serializable agent list for LLM routing context"
    - "Base agent defines a consistent interface for all future agent implementations"
  artifacts:
    - path: "src/app/agents/base.py"
      provides: "BaseAgent abstract class, AgentCapability, AgentRegistration, AgentStatus"
      exports: ["BaseAgent", "AgentCapability", "AgentRegistration", "AgentStatus"]
    - path: "src/app/agents/registry.py"
      provides: "AgentRegistry with register/discover/backup/list operations"
      exports: ["AgentRegistry", "get_agent_registry"]
    - path: "tests/test_agent_registry.py"
      provides: "Unit tests for agent registration, discovery, backup routing"
      min_lines: 60
  key_links:
    - from: "src/app/agents/registry.py"
      to: "src/app/agents/base.py"
      via: "stores AgentRegistration instances"
      pattern: "AgentRegistration"
    - from: "src/app/agents/registry.py"
      to: "backup routing"
      via: "get_backup returns backup_agent_id's registration"
      pattern: "get_backup|backup_agent_id"
---

<objective>
Create the agent registry and base agent abstractions that enable agents to be registered, discovered by capability, and routed to backup agents on failure.

Purpose: PLT-05 requires an agent registry and handoff protocol. This plan builds the registry infrastructure -- how agents declare themselves, how the supervisor finds agents for tasks, and how failure routing works (LOCKED DECISION: route to backup agent with similar capabilities). The actual handoff protocol is in Plan 03.

Output: Complete agents/ package with BaseAgent abstract class, AgentCapability/AgentRegistration data models, and AgentRegistry singleton with discovery and backup routing.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-agent-orchestration/02-CONTEXT.md
@.planning/phases/02-agent-orchestration/02-RESEARCH.md
@src/app/config.py
@src/app/core/tenant.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BaseAgent, AgentCapability, and AgentRegistration</name>
  <files>src/app/agents/__init__.py, src/app/agents/base.py</files>
  <action>
1. Create src/app/agents/__init__.py with exports for BaseAgent, AgentCapability, AgentRegistration, AgentStatus, AgentRegistry, get_agent_registry.

2. Create src/app/agents/base.py with:

   AgentStatus enum (str, Enum): IDLE, BUSY, ERROR, OFFLINE

   AgentCapability dataclass:
   - name: str (e.g., "research", "writing", "crm_lookup")
   - description: str (human-readable, used by LLM router for capability matching)
   - input_schema: type[BaseModel] | None = None (Pydantic model for input validation, optional)
   - output_schema: type[BaseModel] | None = None (Pydantic model for output validation, optional)

   AgentRegistration dataclass:
   - agent_id: str (unique identifier, e.g., "research_agent")
   - name: str (human-readable name, e.g., "Research Agent")
   - description: str (what this agent does -- used by LLM router)
   - capabilities: list[AgentCapability]
   - backup_agent_id: str | None = None (LOCKED DECISION: for failure routing)
   - tags: list[str] = field(default_factory=list) (e.g., ["sales", "research"])
   - max_concurrent_tasks: int = 5

   BaseAgent abstract class:
   - __init__(self, registration: AgentRegistration)
   - self.registration: AgentRegistration
   - self.status: AgentStatus = AgentStatus.IDLE
   - self._logger: structlog logger bound with agent_id
   - @property agent_id -> str (shortcut to registration.agent_id)
   - @property capabilities -> list[AgentCapability]
   - @abstractmethod async def execute(self, task: dict, context: dict) -> dict -- core execution method
   - async def invoke(self, task: dict, context: dict) -> dict -- wraps execute() with status tracking (IDLE -> BUSY -> IDLE/ERROR), logging, and error handling. Sets status to BUSY before execute(), catches exceptions and sets ERROR, returns result and resets to IDLE.
   - def to_routing_info(self) -> dict -- returns {"id": agent_id, "name": name, "description": description, "capabilities": [cap.name for cap in capabilities], "status": status.value} for LLM routing context

Follow existing patterns: `from __future__ import annotations`, structlog logging, docstrings.
  </action>
  <verify>
Run: `python -c "from src.app.agents.base import BaseAgent, AgentCapability, AgentRegistration, AgentStatus; print('Base imports OK')"` succeeds.
Run: `python -c "
from src.app.agents.base import AgentCapability, AgentRegistration, AgentStatus
cap = AgentCapability(name='research', description='Research things')
reg = AgentRegistration(agent_id='test', name='Test Agent', description='A test', capabilities=[cap])
assert reg.agent_id == 'test'
assert reg.capabilities[0].name == 'research'
assert reg.backup_agent_id is None
print('Models OK')
"` succeeds.
  </verify>
  <done>BaseAgent abstract class defines consistent agent interface with status tracking and invoke() wrapper. AgentCapability and AgentRegistration provide typed models for agent metadata.</done>
</task>

<task type="auto">
  <name>Task 2: Build AgentRegistry with discovery and backup routing</name>
  <files>src/app/agents/registry.py, tests/test_agent_registry.py</files>
  <action>
1. Create src/app/agents/registry.py with AgentRegistry class:
   - __init__(self) -- self._agents: dict[str, AgentRegistration] = {}
   - register(self, registration: AgentRegistration) -> None -- stores registration, raises ValueError if agent_id already registered. Logs registration with structlog.
   - unregister(self, agent_id: str) -> None -- removes agent, raises KeyError if not found.
   - get(self, agent_id: str) -> AgentRegistration | None -- returns registration or None
   - get_backup(self, agent_id: str) -> AgentRegistration | None -- (LOCKED DECISION) looks up agent, if it has backup_agent_id, returns that agent's registration. Returns None if no backup configured or backup not registered.
   - find_by_capability(self, capability_name: str) -> list[AgentRegistration] -- returns all agents that have a capability with the given name
   - find_by_tag(self, tag: str) -> list[AgentRegistration] -- returns all agents with the given tag
   - list_agents(self) -> list[dict] -- returns list of routing info dicts (calls to_routing_info on each registration... wait, registration doesn't have to_routing_info. Return: [{"id": a.agent_id, "name": a.name, "description": a.description, "capabilities": [c.name for c in a.capabilities]} for a in self._agents.values()])
   - list_agent_ids(self) -> list[str] -- returns all registered agent IDs
   - __len__(self) -> int -- returns number of registered agents
   - __contains__(self, agent_id: str) -> bool -- checks if agent is registered

   Add module-level singleton:
   - _registry: AgentRegistry | None = None
   - get_agent_registry() -> AgentRegistry -- returns singleton, creates if None

2. Create tests/test_agent_registry.py with:
   - test_register_agent: Register an agent, verify it's in registry
   - test_register_duplicate_raises: Register same agent_id twice raises ValueError
   - test_unregister_agent: Register then unregister, verify gone
   - test_unregister_nonexistent_raises: Unregister unknown ID raises KeyError
   - test_get_agent: Register and retrieve by ID
   - test_get_nonexistent_returns_none: Get unknown ID returns None
   - test_get_backup_agent: Register agent A with backup_agent_id="B", register B, verify get_backup("A") returns B
   - test_get_backup_no_backup_configured: Agent without backup returns None
   - test_get_backup_backup_not_registered: Agent with backup_agent_id pointing to unregistered agent returns None
   - test_find_by_capability: Register 3 agents with varying capabilities, find by specific capability
   - test_find_by_tag: Register agents with tags, find by tag
   - test_list_agents: Register multiple, list_agents returns all with correct structure
   - test_len_and_contains: Test __len__ and __contains__
   - At least 12 test cases
  </action>
  <verify>
Run: `python -m pytest tests/test_agent_registry.py -v` -- all tests pass.
Run: `python -c "from src.app.agents import AgentRegistry, get_agent_registry; r = get_agent_registry(); print(f'Registry with {len(r)} agents')"` succeeds.
  </verify>
  <done>AgentRegistry supports registration, discovery by capability/tag, backup agent routing for failure handling, and provides serializable agent list for LLM routing context. All 12+ tests pass.</done>
</task>

</tasks>

<verification>
1. All classes import cleanly: `from src.app.agents import BaseAgent, AgentCapability, AgentRegistration, AgentStatus, AgentRegistry, get_agent_registry`
2. AgentRegistry.find_by_capability returns correct agents
3. AgentRegistry.get_backup follows backup_agent_id chain
4. AgentRegistry.list_agents returns LLM-friendly routing info
5. All tests in tests/test_agent_registry.py pass
</verification>

<success_criteria>
- BaseAgent defines abstract execute() with invoke() wrapper that tracks status
- AgentCapability and AgentRegistration provide typed agent metadata
- AgentRegistry supports register, discover, backup routing, and listing
- Backup agent routing follows the locked decision (route to backup on failure)
- All 12+ tests pass covering registration, discovery, backup, and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/02-agent-orchestration/02-02-SUMMARY.md`
</output>
