---
phase: 02-agent-orchestration
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/app/handoffs/__init__.py
  - src/app/handoffs/validators.py
  - src/app/handoffs/semantic.py
  - src/app/handoffs/protocol.py
  - tests/test_handoffs.py
autonomous: true

must_haves:
  truths:
    - "Structural validation catches missing source attribution, empty call chains, and type errors"
    - "LLM semantic validation detects hallucinated claims not grounded in available context"
    - "Validation strictness is configurable per handoff type (STRICT = structural + semantic, LENIENT = structural only)"
    - "Rejected handoffs include specific rejection reasons for debugging"
  artifacts:
    - path: "src/app/handoffs/validators.py"
      provides: "HandoffPayload model, ValidationStrictness enum, structural validation"
      exports: ["HandoffPayload", "ValidationStrictness", "HandoffResult"]
    - path: "src/app/handoffs/semantic.py"
      provides: "LLM-based semantic validation for claim verification"
      exports: ["SemanticValidator"]
    - path: "src/app/handoffs/protocol.py"
      provides: "HandoffProtocol that chains structural then semantic validation"
      exports: ["HandoffProtocol"]
    - path: "tests/test_handoffs.py"
      provides: "Unit tests for structural validation, semantic validation, and protocol"
      min_lines: 80
  key_links:
    - from: "src/app/handoffs/protocol.py"
      to: "src/app/handoffs/validators.py"
      via: "structural validation as first step"
      pattern: "HandoffPayload|validate"
    - from: "src/app/handoffs/protocol.py"
      to: "src/app/handoffs/semantic.py"
      via: "semantic validation for STRICT handoffs"
      pattern: "SemanticValidator|semantic"
    - from: "src/app/handoffs/semantic.py"
      to: "src/app/services/llm.py"
      via: "LLM call for claim verification"
      pattern: "LLMService|completion"
---

<objective>
Build the handoff validation protocol that prevents cascading hallucination between agents through two-layer validation: Pydantic structural checks followed by LLM semantic verification.

Purpose: PLT-07 requires validation checkpoints at agent handoffs to prevent cascading hallucination. This is the key defense: when Agent A fabricates data, the validation layer catches it before Agent B builds on false information. LOCKED DECISIONS: both hallucination prevention AND completeness, configurable strictness per handoff type, LLM semantic validation depth.

Output: Complete handoffs/ package with structural validators (Pydantic), semantic validator (LLM-based), and HandoffProtocol that chains them with configurable strictness.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-agent-orchestration/02-CONTEXT.md
@.planning/phases/02-agent-orchestration/02-RESEARCH.md
@.planning/phases/02-agent-orchestration/02-01-SUMMARY.md
@.planning/phases/02-agent-orchestration/02-02-SUMMARY.md
@src/app/services/llm.py
@src/app/events/schemas.py
@src/app/agents/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HandoffPayload structural validators</name>
  <files>src/app/handoffs/__init__.py, src/app/handoffs/validators.py</files>
  <action>
1. Create src/app/handoffs/__init__.py with exports for HandoffPayload, ValidationStrictness, HandoffResult, SemanticValidator, HandoffProtocol.

2. Create src/app/handoffs/validators.py with:

   ValidationStrictness enum (str, Enum):
   - STRICT = "strict" (structural + semantic validation)
   - LENIENT = "lenient" (structural only -- for routine handoffs like status updates)

   HandoffResult Pydantic model:
   - valid: bool
   - strictness: ValidationStrictness
   - structural_issues: list[str] = [] (structural validation failures)
   - semantic_issues: list[str] = [] (semantic validation failures)
   - validated_at: datetime (auto-set)
   - validator_model: str | None = None (which LLM model did semantic check, if any)

   HandoffPayload Pydantic model:
   - handoff_id: str (default uuid4)
   - source_agent_id: str (Field with min_length=1)
   - target_agent_id: str (Field with min_length=1)
   - call_chain: list[str] (min_length=1)
   - tenant_id: str (Field with min_length=1)
   - handoff_type: str (e.g., "deal_data", "research_result", "status_update" -- used to determine strictness)
   - data: dict[str, Any] (the actual payload being handed off)
   - context_refs: list[str] = [] (references to shared context for semantic validation)
   - confidence: float = Field(ge=0.0, le=1.0, default=1.0) (source agent's confidence)
   - timestamp: datetime (default utcnow)

   Model validators:
   - source_agent_id must appear in call_chain (same as event schema)
   - target_agent_id must NOT appear in call_chain (it's where data is going, not where it came from)
   - If confidence < 0.5, log a warning (low-confidence handoffs should be flagged)

   StrictnessConfig class:
   - _rules: dict[str, ValidationStrictness] mapping handoff_type to strictness
   - Default rules: {"deal_data": STRICT, "customer_info": STRICT, "research_result": STRICT, "status_update": LENIENT, "notification": LENIENT}
   - get_strictness(self, handoff_type: str) -> ValidationStrictness -- returns mapped strictness, defaults to STRICT for unknown types (fail-safe)
   - register_rule(self, handoff_type: str, strictness: ValidationStrictness) -> None
  </action>
  <verify>
Run: `python -c "
from src.app.handoffs.validators import HandoffPayload, ValidationStrictness, StrictnessConfig
p = HandoffPayload(source_agent_id='a1', target_agent_id='a2', call_chain=['a1', 'supervisor'], tenant_id='t1', handoff_type='deal_data', data={'amount': 50000})
assert p.source_agent_id == 'a1'
config = StrictnessConfig()
assert config.get_strictness('deal_data') == ValidationStrictness.STRICT
assert config.get_strictness('status_update') == ValidationStrictness.LENIENT
assert config.get_strictness('unknown_type') == ValidationStrictness.STRICT
print('Validators OK')
"` succeeds.
  </verify>
  <done>HandoffPayload validates source attribution and call chain integrity. StrictnessConfig maps handoff types to validation depth with fail-safe defaults.</done>
</task>

<task type="auto">
  <name>Task 2: Build semantic validator and HandoffProtocol</name>
  <files>src/app/handoffs/semantic.py, src/app/handoffs/protocol.py, tests/test_handoffs.py</files>
  <action>
1. Create src/app/handoffs/semantic.py with SemanticValidator class:
   - __init__(self, llm_service: LLMService) -- takes the existing LLMService from Phase 1
   - async validate(self, payload: HandoffPayload, available_context: dict | None = None) -> tuple[bool, list[str]]
     - Constructs a validation prompt asking the LLM to check:
       1. Are all claims in payload.data supported by available_context? (if context provided)
       2. Are there fabricated/hallucinated data points (e.g., specific numbers, dates, names without source)?
       3. Is the data logically consistent (no internal contradictions)?
     - Calls llm_service.completion with model="fast" (Claude Haiku for speed), temperature=0.0 (deterministic)
     - Parses structured response: {"valid": bool, "issues": ["list of problems"]}
     - Returns (is_valid, issues_list)
     - If LLM call fails (RuntimeError, timeout), returns (True, ["semantic_validation_unavailable"]) -- fail-open with warning to prevent blocking all handoffs when LLM is down
   - Log all validation results with structlog (payload.handoff_id, valid/invalid, issues)

2. Create src/app/handoffs/protocol.py with HandoffProtocol class:
   - __init__(self, strictness_config: StrictnessConfig, semantic_validator: SemanticValidator | None = None)
   - async validate(self, payload: HandoffPayload, available_context: dict | None = None) -> HandoffResult
     - Step 1: Structural validation -- try to instantiate/re-validate the payload with Pydantic. Catch ValidationError and collect issues.
     - Step 2: Check strictness via config.get_strictness(payload.handoff_type)
     - Step 3: If STRICT and semantic_validator is available, run semantic validation
     - Step 4: Return HandoffResult with all collected issues
     - A handoff is valid only if structural passes AND (if STRICT, semantic also passes)
   - async validate_or_reject(self, payload: HandoffPayload, context: dict | None = None) -> HandoffPayload
     - Calls validate(), if invalid raises HandoffRejectedError with the HandoffResult
     - If valid, returns the payload (pass-through)

   HandoffRejectedError(Exception):
   - __init__(self, result: HandoffResult, payload: HandoffPayload)
   - self.result = result
   - self.payload = payload
   - Descriptive __str__ showing rejection reasons

3. Create tests/test_handoffs.py with:
   - test_valid_handoff_payload: Valid payload passes structural validation
   - test_missing_source_in_call_chain: source_agent_id not in call_chain raises ValidationError
   - test_target_in_call_chain: target_agent_id in call_chain raises ValidationError
   - test_empty_call_chain: Empty call_chain raises ValidationError
   - test_confidence_range: confidence outside 0-1 raises ValidationError
   - test_strictness_config_defaults: Default rules map correctly
   - test_strictness_config_unknown_is_strict: Unknown handoff type defaults to STRICT
   - test_protocol_lenient_skips_semantic: LENIENT handoff type skips semantic validation
   - test_protocol_strict_runs_semantic: STRICT type runs both structural and semantic (mock LLM)
   - test_protocol_semantic_failure_rejects: Mock LLM returns invalid, protocol returns invalid result
   - test_protocol_llm_unavailable_failopen: Mock LLM raises RuntimeError, validation passes with warning
   - test_validate_or_reject_raises: Invalid payload raises HandoffRejectedError
   - At least 10 test cases. Mock LLMService for semantic validation tests.
  </action>
  <verify>
Run: `python -m pytest tests/test_handoffs.py -v` -- all tests pass.
Run: `python -c "from src.app.handoffs import HandoffProtocol, HandoffPayload, SemanticValidator; print('Handoff imports OK')"` succeeds.
  </verify>
  <done>SemanticValidator uses LLM to detect hallucinated claims. HandoffProtocol chains structural then semantic validation with configurable strictness. Rejected handoffs include specific reasons. LLM failure is fail-open with warning.</done>
</task>

</tasks>

<verification>
1. All classes import cleanly: `from src.app.handoffs import HandoffPayload, ValidationStrictness, HandoffResult, SemanticValidator, HandoffProtocol`
2. HandoffPayload validates source_agent_id is in call_chain
3. StrictnessConfig defaults: deal_data=STRICT, status_update=LENIENT, unknown=STRICT
4. Protocol chains structural -> semantic for STRICT, structural-only for LENIENT
5. SemanticValidator fails open when LLM is unavailable
6. HandoffRejectedError includes specific rejection reasons
7. All tests in tests/test_handoffs.py pass
</verification>

<success_criteria>
- Structural validation catches missing fields, type errors, and attribution issues
- LLM semantic validation detects ungrounded claims when context is available
- Strictness is configurable per handoff type with fail-safe defaults (unknown = STRICT)
- LLM failure is fail-open to prevent blocking all handoffs
- Rejected handoffs include specific, debuggable rejection reasons
- All 10+ tests pass covering structural, semantic, protocol, and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/02-agent-orchestration/02-03-SUMMARY.md`
</output>
