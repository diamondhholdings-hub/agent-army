---
phase: 02-agent-orchestration
plan: 05
type: execute
wave: 3
depends_on: ["02-02", "02-03", "02-04"]
files_modified:
  - src/app/agents/router.py
  - src/app/agents/supervisor.py
  - tests/test_supervisor.py
autonomous: true

must_haves:
  truths:
    - "Supervisor receives a task, decomposes it into subtasks, routes to specialists, and synthesizes a coherent result"
    - "Hybrid router uses deterministic rules for known patterns (fast) and LLM for ambiguous cases (flexible)"
    - "Failed agent execution routes to backup agent via registry (not retry on same agent)"
    - "Result synthesis uses LLM to combine multiple agent outputs into a unified response"
  artifacts:
    - path: "src/app/agents/router.py"
      provides: "HybridRouter with rules-based routing and LLM fallback"
      exports: ["HybridRouter", "RoutingDecision"]
    - path: "src/app/agents/supervisor.py"
      provides: "SupervisorOrchestrator with task decomposition, routing, synthesis"
      exports: ["SupervisorOrchestrator", "create_supervisor_graph"]
    - path: "tests/test_supervisor.py"
      provides: "Unit tests for routing, decomposition, failure handling, synthesis"
      min_lines: 80
  key_links:
    - from: "src/app/agents/router.py"
      to: "src/app/agents/registry.py"
      via: "queries registry for available agents and capabilities"
      pattern: "AgentRegistry|find_by_capability|list_agents"
    - from: "src/app/agents/supervisor.py"
      to: "src/app/agents/router.py"
      via: "uses HybridRouter for task-to-agent routing"
      pattern: "HybridRouter|route"
    - from: "src/app/agents/supervisor.py"
      to: "src/app/handoffs/protocol.py"
      via: "validates handoffs between supervisor and agents"
      pattern: "HandoffProtocol|validate"
    - from: "src/app/agents/supervisor.py"
      to: "src/app/context/manager.py"
      via: "compiles working context for each agent invocation"
      pattern: "ContextManager|compile_working_context"
    - from: "src/app/agents/supervisor.py"
      to: "langgraph"
      via: "LangGraph functional API for graph execution"
      pattern: "entrypoint|task|StateGraph"
---

<objective>
Build the supervisor orchestrator that coordinates specialist agents through hybrid routing (rules + LLM), task decomposition, validated handoffs, and LLM-based result synthesis.

Purpose: PLT-04 requires a supervisor orchestration topology (not flat "bag of agents"). The supervisor is the "conductor" -- it receives tasks, decides which agent(s) should handle them, decomposes complex tasks, validates handoffs, and synthesizes results. LOCKED DECISIONS: hybrid routing (rules for known, LLM for ambiguous), full decomposition, LLM synthesis, route to backup agent on failure.

Output: HybridRouter with pluggable routing rules and LLM fallback. SupervisorOrchestrator built on LangGraph functional API that decomposes tasks, routes through validated handoffs, handles failures with backup agents, and synthesizes final results.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-agent-orchestration/02-CONTEXT.md
@.planning/phases/02-agent-orchestration/02-RESEARCH.md
@.planning/phases/02-agent-orchestration/02-02-SUMMARY.md
@.planning/phases/02-agent-orchestration/02-03-SUMMARY.md
@.planning/phases/02-agent-orchestration/02-04-SUMMARY.md
@src/app/agents/base.py
@src/app/agents/registry.py
@src/app/handoffs/protocol.py
@src/app/context/manager.py
@src/app/services/llm.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build HybridRouter with rules-based and LLM routing</name>
  <files>src/app/agents/router.py</files>
  <action>
1. Create src/app/agents/router.py with:

   RoutingDecision Pydantic model:
   - agent_id: str (which agent to route to)
   - reasoning: str (why this agent was chosen -- for traceability)
   - subtasks: list[dict] = [] (decomposed subtasks if the router detected a multi-step task)
   - confidence: float = Field(ge=0.0, le=1.0, default=1.0)
   - routed_by: str = "rules" or "llm" (which routing method was used)

   TaskDecomposition Pydantic model:
   - original_task: dict
   - subtasks: list[dict] (each subtask has "description", "required_capabilities", "priority", "depends_on")
   - decomposed_by: str = "llm" (always LLM for decomposition)

   HybridRouter class:
   - __init__(self, registry: AgentRegistry, llm_service: LLMService)
   - self._rules: list[tuple[Callable[[dict], bool], str]] -- list of (matcher_function, agent_id) pairs
   - add_rule(self, matcher: Callable[[dict], bool], agent_id: str) -> None -- register a deterministic routing rule. Matcher receives task dict, returns True if this agent should handle it.
   - remove_rule(self, agent_id: str) -> None -- remove rules for an agent_id
   - async route(self, task: dict) -> RoutingDecision
     - Phase 1 (Rules): Iterate self._rules in order. First matcher that returns True -> return RoutingDecision with agent_id, routed_by="rules", confidence=1.0
     - Phase 2 (LLM): If no rule matches, construct prompt with task description and available agents (from registry.list_agents()). Use llm_service.completion with model="fast", temperature=0.0. Parse structured response as RoutingDecision. Set routed_by="llm".
     - Log routing decision with structlog (task_type, chosen_agent, routed_by, confidence)
   - async decompose(self, task: dict) -> TaskDecomposition
     - Construct prompt asking LLM to break task into subtasks with required capabilities and dependencies
     - Use llm_service.completion with model="reasoning" (decomposition needs deeper thinking)
     - Parse structured response. Each subtask gets: description, required_capabilities list, priority (1=highest), depends_on (list of subtask indices)
     - Return TaskDecomposition
   - async route_subtasks(self, subtasks: list[dict]) -> list[tuple[dict, RoutingDecision]]
     - Route each subtask independently via self.route()
     - Return list of (subtask, routing_decision) pairs

2. Update src/app/agents/__init__.py to export HybridRouter and RoutingDecision.
  </action>
  <verify>
Run: `python -c "
from src.app.agents.router import HybridRouter, RoutingDecision
from src.app.agents.registry import AgentRegistry
rd = RoutingDecision(agent_id='test', reasoning='matched rule', routed_by='rules')
assert rd.routed_by == 'rules'
print('Router imports OK')
"` succeeds.
  </verify>
  <done>HybridRouter applies deterministic rules first (fast, confident) then falls back to LLM routing for ambiguous tasks. TaskDecomposition breaks complex tasks into parallelizable subtasks with capability requirements.</done>
</task>

<task type="auto">
  <name>Task 2: Build SupervisorOrchestrator with LangGraph</name>
  <files>src/app/agents/supervisor.py, tests/test_supervisor.py</files>
  <action>
1. Create src/app/agents/supervisor.py with:

   SupervisorOrchestrator class:
   - __init__(self, registry: AgentRegistry, router: HybridRouter, handoff_protocol: HandoffProtocol, context_manager: ContextManager, llm_service: LLMService)
   - Store all dependencies as instance variables

   Core methods:
   - async execute_task(self, task: dict, tenant_id: str, thread_id: str) -> dict
     The main entry point. Orchestrates the full flow:
     1. Compile working context via context_manager.compile_working_context()
     2. Decide if task needs decomposition (heuristic: if task has multiple verbs/goals, or if description is long, decompose)
     3. If simple: route directly via router.route(), execute single agent
     4. If complex: decompose via router.decompose(), route subtasks, execute in dependency order (parallel where possible using asyncio.gather for independent subtasks)
     5. Validate each agent's output via handoff_protocol.validate_or_reject()
     6. Synthesize results if multiple agents contributed
     7. Return final result with full call chain for traceability

   - async _execute_agent(self, agent_id: str, task: dict, context: dict, call_chain: list[str], tenant_id: str) -> dict
     Execute a single agent:
     1. Get agent from registry
     2. Call agent.invoke(task, context)
     3. If agent fails, try backup via registry.get_backup(agent_id) (LOCKED DECISION)
     4. If backup also fails or no backup, raise AgentExecutionError
     5. Return result with updated call_chain

   - async _synthesize_results(self, results: list[dict], original_task: dict) -> dict
     Use LLM (model="reasoning") to combine multiple agent outputs into a coherent response (LOCKED DECISION: LLM synthesis). The synthesis prompt includes:
     - Original task description
     - Each agent's output with their agent_id
     - Instruction to produce unified, non-redundant response

   - async _should_decompose(self, task: dict) -> bool
     Heuristic check: task description length > 200 chars, contains "and" joining distinct actions, or has explicit subtask markers. Conservative -- when in doubt, don't decompose (let the single agent handle it).

   Helper to create a configured supervisor:
   - create_supervisor_graph(registry, router, handoff_protocol, context_manager, llm_service, checkpointer) -> SupervisorOrchestrator
     Factory function that wires all dependencies and returns a ready-to-use supervisor.

2. Create tests/test_supervisor.py with:
   - test_simple_task_routes_directly: Simple task goes to single agent without decomposition
   - test_complex_task_decomposes: Long multi-goal task triggers decomposition (mock LLM)
   - test_agent_failure_routes_to_backup: Primary agent raises, backup is tried (mock agents)
   - test_no_backup_raises: Agent fails, no backup configured, AgentExecutionError raised
   - test_handoff_validation_rejects: Agent output fails validation, appropriate error returned
   - test_result_synthesis: Multiple agent results synthesized into coherent response (mock LLM)
   - test_call_chain_tracking: Call chain includes supervisor + agent IDs
   - test_working_context_compiled: Verify context_manager.compile_working_context is called before agent execution (mock)
   - test_parallel_subtask_execution: Independent subtasks execute concurrently (mock with timing)
   - At least 8 test cases. All agent invocations, LLM calls, and context operations are mocked.
  </action>
  <verify>
Run: `python -m pytest tests/test_supervisor.py -v` -- all tests pass.
Run: `python -c "from src.app.agents.supervisor import SupervisorOrchestrator, create_supervisor_graph; print('Supervisor imports OK')"` succeeds.
  </verify>
  <done>SupervisorOrchestrator receives tasks, decomposes when needed, routes through hybrid router, validates handoffs, executes agents with backup failure handling, and synthesizes results via LLM. Full call chain maintained for traceability. All tests pass.</done>
</task>

</tasks>

<verification>
1. All classes import: `from src.app.agents import HybridRouter, RoutingDecision, SupervisorOrchestrator, create_supervisor_graph`
2. HybridRouter.route() tries rules first, then LLM fallback
3. SupervisorOrchestrator.execute_task() compiles context, routes, validates handoffs, synthesizes
4. Agent failure routes to backup agent (not retry same agent)
5. Call chain tracks full path: ["user", "supervisor", "agent_id"]
6. All tests in tests/test_supervisor.py pass
</verification>

<success_criteria>
- Supervisor decomposes complex tasks into parallelizable subtasks
- Hybrid router uses deterministic rules for known patterns, LLM for ambiguous
- Failed agent execution routes to backup agent via registry
- Result synthesis produces coherent unified response from multiple agents
- Full call chain maintained for traceability
- Handoff validation enforced between supervisor and agents
- All 8+ tests pass with mocked agents, LLM, and context
</success_criteria>

<output>
After completion, create `.planning/phases/02-agent-orchestration/02-05-SUMMARY.md`
</output>
