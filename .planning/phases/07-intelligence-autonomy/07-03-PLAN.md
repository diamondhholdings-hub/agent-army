---
phase: 07-intelligence-autonomy
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/app/intelligence/consolidation/entity_linker.py
  - src/app/intelligence/consolidation/summarizer.py
  - src/app/intelligence/consolidation/customer_view.py
  - tests/test_consolidation.py
autonomous: true

must_haves:
  truths:
    - "EntityLinker matches conversations to accounts via email domain overlap (no fuzzy matching)"
    - "ContextSummarizer progressively summarizes timeline data (30/90/365 day windows)"
    - "CustomerViewService assembles unified cross-channel views by composing existing repositories"
    - "Most recent signal wins when data conflicts across channels"
  artifacts:
    - path: "src/app/intelligence/consolidation/entity_linker.py"
      provides: "EntityLinker for email domain + participant matching"
      contains: "class EntityLinker"
    - path: "src/app/intelligence/consolidation/summarizer.py"
      provides: "ContextSummarizer with progressive 30/90/365 day windowing"
      contains: "class ContextSummarizer"
    - path: "src/app/intelligence/consolidation/customer_view.py"
      provides: "CustomerViewService composing existing Phase 3/4/5/6 repositories"
      contains: "class CustomerViewService"
  key_links:
    - from: "src/app/intelligence/consolidation/customer_view.py"
      to: "src/app/deals/repository.py"
      via: "DealRepository composition"
      pattern: "deal_repository"
    - from: "src/app/intelligence/consolidation/customer_view.py"
      to: "src/app/meetings/repository.py"
      via: "MeetingRepository composition"
      pattern: "meeting_repository"
    - from: "src/app/intelligence/consolidation/customer_view.py"
      to: "src/knowledge/conversations/store.py"
      via: "ConversationStore composition"
      pattern: "conversation_store"
    - from: "src/app/intelligence/consolidation/entity_linker.py"
      to: "src/app/deals/repository.py"
      via: "Account/stakeholder lookup"
      pattern: "deal_repository"
---

<objective>
Build the cross-channel data consolidation layer -- EntityLinker for connecting conversations to accounts, ContextSummarizer for progressive summarization, and CustomerViewService for assembling unified customer views across emails, chats, meetings, and CRM data.

Purpose: The unified customer view is the foundation for pattern recognition and autonomous behavior. Every intelligence operation needs to see the complete picture across all channels.

Output: Three service classes in `src/app/intelligence/consolidation/` with comprehensive tests.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-intelligence-autonomy/07-CONTEXT.md
@.planning/phases/07-intelligence-autonomy/07-RESEARCH.md
@.planning/phases/07-intelligence-autonomy/07-01-SUMMARY.md
@src/app/deals/repository.py
@src/app/meetings/repository.py
@src/knowledge/conversations/store.py
@src/app/intelligence/consolidation/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: EntityLinker and ContextSummarizer</name>
  <files>
    src/app/intelligence/consolidation/entity_linker.py
    src/app/intelligence/consolidation/summarizer.py
  </files>
  <action>
    **entity_linker.py:** Create `EntityLinker` for cross-channel entity resolution.

    Per CONTEXT.md locked decision: "Email domain + participant matching. NO fuzzy matching."

    - Constructor: no required dependencies (stateless utility).
    - `extract_domains(participants: list[str]) -> set[str]`: Extract email domains from a list of email addresses. Lowercase, skip entries without "@". Pure function.
    - `async link_to_account(tenant_id: str, participants: list[str], deal_repository) -> str | None`: Find matching account by email domain overlap.
      1. Extract domains from participants.
      2. Query `deal_repository.list_accounts(tenant_id)` to get all accounts.
      3. For each account, query `deal_repository.list_stakeholders(tenant_id, account.id)`.
      4. Extract stakeholder email domains.
      5. If intersection between participant domains and stakeholder domains exists, return account.id.
      6. Return None if no match (explicit domain/participant overlap required).
    - `async link_to_deal(tenant_id: str, account_id: str, deal_repository) -> str | None`: Given an account, find the most relevant open opportunity.
      Uses `deal_repository.list_opportunities(tenant_id, filter=OpportunityFilter(account_id=account_id))`. Returns the first non-closed opportunity, or None.
    - `resolve_conflict(signals: list[ChannelSignal]) -> ChannelSignal`: Per CONTEXT.md: "most recent wins." Sorts by timestamp descending, returns first. Raises ValueError on empty list.

    **summarizer.py:** Create `ContextSummarizer` for progressive summarization.

    - Class constants: `RECENT_WINDOW_DAYS = 30`, `MEDIUM_WINDOW_DAYS = 90`, `OLD_WINDOW_DAYS = 365`.
    - Constructor takes optional `llm_service` (for LLM-based summarization) and optional `max_tokens_per_summary: int = 500`.
    - `async summarize_timeline(timeline: list[ChannelInteraction]) -> SummarizedTimeline`: Core method.
      1. Partition timeline by age: recent (<=30 days), medium (31-90 days), old (>90 days).
      2. Recent: keep full detail (return as-is).
      3. Medium: group by ISO week, summarize each week.
      4. Old: group by month, summarize each month.
      5. If llm_service is available, use LLM (model='fast') to generate summaries from grouped interactions.
      6. If llm_service is None, use rule-based fallback: concatenate content_summary fields, truncate to max_tokens_per_summary chars, prefix with period descriptor.
      7. Return SummarizedTimeline.
    - `_group_by_period(interactions: list[ChannelInteraction], period: str) -> dict[str, list[ChannelInteraction]]`: Groups by "week" (ISO year-week) or "month" (year-month).
    - `_compute_token_estimate(text: str) -> int`: Use `len(text) / 4.0` (matching 03-02 CHARS_PER_TOKEN convention).
    - `async _summarize_group(interactions: list[ChannelInteraction], period_label: str) -> dict`: Summarize a group of interactions. Returns {"period": period_label, "summary": str, "interaction_count": int, "channels": list[str]}.

    Both classes: structlog logging, `from __future__ import annotations`, standard error handling.
  </action>
  <verify>Run `python -c "from src.app.intelligence.consolidation.entity_linker import EntityLinker; from src.app.intelligence.consolidation.summarizer import ContextSummarizer; print('OK')"` -- imports succeed.</verify>
  <done>EntityLinker performs exact domain matching for account linking. ContextSummarizer partitions timelines into 30/90/365 day windows with progressive summarization.</done>
</task>

<task type="auto">
  <name>Task 2: CustomerViewService and comprehensive tests</name>
  <files>
    src/app/intelligence/consolidation/customer_view.py
    tests/test_consolidation.py
  </files>
  <action>
    **customer_view.py:** Create `CustomerViewService` -- the central cross-channel composition service.

    This service composes existing repositories (Phase 3/4/5/6) to assemble a unified customer view. It does NOT duplicate or replace existing data stores.

    - Constructor takes:
      - `conversation_store` (ConversationStore from Phase 3 or compatible interface)
      - `state_repository` (ConversationStateRepository from Phase 4 or compatible interface)
      - `deal_repository` (DealRepository from Phase 5 or compatible interface)
      - `meeting_repository` (MeetingRepository from Phase 6 or compatible interface)
      - `summarizer` (ContextSummarizer)
      - `entity_linker` (EntityLinker)

    - `async get_unified_view(tenant_id: str, account_id: str) -> UnifiedCustomerView`: Main method. Assembles complete customer view:
      1. Use `asyncio.gather()` to fetch in parallel from all 4 data sources:
         - Deals/opportunities for account from deal_repository
         - Stakeholders for account from deal_repository
         - Meetings associated with account from meeting_repository (filter by account or use entity_linker for participant matching)
         - Conversation history from state_repository or conversation_store
      2. Build chronological timeline by merging all interactions with channel tags (ChannelType enum).
      3. Apply progressive summarization via summarizer.
      4. Extract current signals (latest BANT/MEDDIC signals from conversation state, deal stage, etc.).
      5. Build action history (emails sent, meetings attended, proposals shared) from interaction data.
      6. Return UnifiedCustomerView.

    - `_build_timeline(conversations, deals, meetings) -> list[ChannelInteraction]`: Merge all data sources into a sorted list of ChannelInteraction objects. Each source maps to ChannelType.
    - `_extract_current_signals(deals, conversations) -> dict[str, ChannelSignal]`: Extract the latest signals using entity_linker.resolve_conflict for duplicates (most recent wins).
    - `_build_action_history(conversations, meetings) -> list[ChannelInteraction]`: Filter for agent-initiated actions (sent emails, attended meetings, not received).
    - `async get_recent_activity(tenant_id: str, account_id: str, days: int = 7) -> list[ChannelInteraction]`: Convenience method returning only recent interactions (no summarization, no LLM cost).

    **tests/test_consolidation.py:** Comprehensive tests with in-memory test doubles (no database):

    1. EntityLinker tests (6+):
       - `test_extract_domains` -- extracts correct domains from email list
       - `test_extract_domains_invalid_emails` -- skips entries without "@"
       - `test_link_to_account_match` -- finds account when domain overlaps
       - `test_link_to_account_no_match` -- returns None when no domain overlap
       - `test_resolve_conflict_most_recent` -- most recent signal wins
       - `test_resolve_conflict_empty` -- ValueError on empty list

    2. ContextSummarizer tests (5+):
       - `test_summarize_recent_only` -- all recent interactions kept as-is
       - `test_summarize_mixed_timeline` -- recent full, medium summarized, old summarized
       - `test_group_by_week` -- correct grouping by ISO week
       - `test_group_by_month` -- correct grouping by year-month
       - `test_fallback_without_llm` -- rule-based summarization when llm_service is None

    3. CustomerViewService tests (5+):
       - `test_get_unified_view_assembles_all_channels` -- view contains data from all 4 sources
       - `test_timeline_chronological_order` -- interactions sorted by timestamp
       - `test_current_signals_most_recent_wins` -- conflicting signals resolved by recency
       - `test_get_recent_activity` -- returns only last N days
       - `test_empty_account` -- handles account with no interactions gracefully

    Create in-memory doubles: `MockDealRepository`, `MockMeetingRepository`, `MockConversationStore`, `MockStateRepository` -- each returns predefined test data. These are minimal test-only classes, not production code.
  </action>
  <verify>Run `python -m pytest tests/test_consolidation.py -v` -- all tests pass.</verify>
  <done>CustomerViewService assembles unified views from all 4 data sources. EntityLinker uses exact domain matching. ContextSummarizer applies 30/90/365 day progressive windowing. 16+ tests pass.</done>
</task>

</tasks>

<verification>
- `python -m pytest tests/test_consolidation.py -v` -- all tests pass
- EntityLinker never uses fuzzy matching (verify no fuzzy/approximate string matching imports)
- ContextSummarizer windows: 30/90/365 days
- CustomerViewService composes (not duplicates) existing repositories
- Conflict resolution: most recent timestamp wins
</verification>

<success_criteria>
- Unified customer view assembles data from conversations, deals, meetings, and CRM
- Entity linking uses explicit email domain overlap only (CONTEXT.md locked decision)
- Progressive summarization applies correctly at 30/90/365 day boundaries
- Most recent signal wins for cross-channel conflicts (CONTEXT.md locked decision)
- 16+ tests pass covering all 3 services
</success_criteria>

<output>
After completion, create `.planning/phases/07-intelligence-autonomy/07-03-SUMMARY.md`
</output>
