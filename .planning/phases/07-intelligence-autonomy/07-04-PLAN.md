---
phase: 07-intelligence-autonomy
plan: 04
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/app/intelligence/patterns/engine.py
  - src/app/intelligence/patterns/detectors.py
  - src/app/intelligence/patterns/insights.py
  - tests/test_patterns.py
autonomous: true

must_haves:
  truths:
    - "PatternRecognitionEngine detects buying signals, risk indicators, engagement changes, and cross-account patterns"
    - "Patterns are filtered by confidence threshold (starting at 0.7)"
    - "InsightGenerator creates alerts for critical patterns and daily digests for lower-priority"
    - "Pattern detection uses instructor for structured LLM extraction"
    - "Alert feedback ('useful'/'false_alarm') is tracked for threshold tuning"
  artifacts:
    - path: "src/app/intelligence/patterns/engine.py"
      provides: "PatternRecognitionEngine orchestrating all detectors"
      contains: "class PatternRecognitionEngine"
    - path: "src/app/intelligence/patterns/detectors.py"
      provides: "BuyingSignalDetector, RiskIndicatorDetector, EngagementChangeDetector"
      contains: "class BuyingSignalDetector"
    - path: "src/app/intelligence/patterns/insights.py"
      provides: "InsightGenerator for alert and digest creation"
      contains: "class InsightGenerator"
  key_links:
    - from: "src/app/intelligence/patterns/engine.py"
      to: "src/app/intelligence/patterns/detectors.py"
      via: "detector composition"
      pattern: "BuyingSignalDetector|RiskIndicatorDetector|EngagementChangeDetector"
    - from: "src/app/intelligence/patterns/engine.py"
      to: "src/app/intelligence/consolidation/schemas.py"
      via: "UnifiedCustomerView input"
      pattern: "UnifiedCustomerView"
    - from: "src/app/intelligence/patterns/insights.py"
      to: "src/app/intelligence/repository.py"
      via: "Insight persistence"
      pattern: "IntelligenceRepository"
---

<objective>
Build the pattern recognition system -- detectors for buying signals, risk indicators, and engagement changes; a PatternRecognitionEngine that orchestrates detectors; and an InsightGenerator that creates alerts and daily digests from detected patterns.

Purpose: Pattern recognition transforms raw data into actionable intelligence. This is the core "intelligence" in Intelligence & Autonomy -- enabling the agent to spot opportunities and risks before humans do.

Output: Three service classes in `src/app/intelligence/patterns/` with comprehensive tests.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-intelligence-autonomy/07-CONTEXT.md
@.planning/phases/07-intelligence-autonomy/07-RESEARCH.md
@.planning/phases/07-intelligence-autonomy/07-01-SUMMARY.md
@src/app/intelligence/patterns/schemas.py
@src/app/intelligence/consolidation/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pattern detectors and recognition engine</name>
  <files>
    src/app/intelligence/patterns/detectors.py
    src/app/intelligence/patterns/engine.py
  </files>
  <action>
    **detectors.py:** Create individual pattern detector classes that analyze customer data for specific signal types. Each detector has a hybrid approach: rule-based checks for obvious patterns + LLM for nuanced detection.

    `BuyingSignalDetector`:
    - Constructor takes optional `llm_service`.
    - `async detect(timeline: list[ChannelInteraction], signals: dict) -> list[PatternMatch]`:
      1. Rule-based checks:
         - Budget mention: scan content_summary for "budget", "funding", "approved", "$" patterns -> PatternMatch(type=buying_signal, confidence=0.8)
         - Timeline urgency: "this quarter", "by end of", "deadline", "urgent" -> confidence=0.75
         - Competitive evaluation: "comparing", "alternative", "other vendor", "shortlist" -> confidence=0.7
         - Stakeholder expansion: count unique participants increasing over time -> confidence=0.65
      2. LLM-enhanced detection (if llm_service available): Use instructor with model='fast' to analyze the last 10 interactions for buying signals the rules missed. Response model: list[PatternMatch]. Merge with rule-based results, deduplicating by signal type + account.
      3. Return combined list.

    `RiskIndicatorDetector`:
    - Same constructor pattern.
    - `async detect(timeline: list[ChannelInteraction], signals: dict) -> list[PatternMatch]`:
      1. Rule-based:
         - Radio silence: no interactions in last 14 days for active deal -> confidence=0.8, severity=high
         - Delayed responses: average response time increasing by >50% -> confidence=0.7
         - Budget freeze: "freeze", "cut", "hold", "postpone" -> confidence=0.75, severity=high
         - Champion departure: "leaving", "new role", "transition" in context of known champion -> confidence=0.7, severity=critical
         - Competitor preference: "prefer", "leaning toward [competitor]", "better fit" -> confidence=0.75
      2. LLM enhancement same pattern as BuyingSignalDetector.

    `EngagementChangeDetector`:
    - `async detect(timeline: list[ChannelInteraction], signals: dict) -> list[PatternMatch]`:
      1. Rule-based:
         - Response rate change: compare last 7 days to prior 30-day average
         - Meeting attendance: track attendee count trends (increasing = positive, decreasing = risk)
         - Engagement depth: longer responses or more questions = deepening engagement
      2. Returns PatternMatch objects with pattern_type=engagement_change.

    All detectors:
    - Return empty list on errors (fail-open, consistent with 02-03/04-04 pattern)
    - Log warnings on LLM failures
    - Each PatternMatch includes evidence (list of quotes/references from source data)

    **engine.py:** Create `PatternRecognitionEngine` that orchestrates all detectors.

    - Constructor takes: `detectors: list` (list of detector instances), `confidence_threshold: float = 0.7`, `min_evidence_count: int = 2`.
    - `async detect_patterns(customer_view: UnifiedCustomerView) -> list[PatternMatch]`: Main method.
      1. Extract timeline and signals from customer_view.
      2. Run all detectors in parallel via `asyncio.gather()`.
      3. Merge all results.
      4. Filter by confidence >= confidence_threshold.
      5. Filter by evidence count >= min_evidence_count (per RESEARCH.md Pitfall 2).
      6. Sort by severity (critical > high > medium > low), then by confidence descending.
      7. Return filtered, sorted list.
    - `async scan_account(tenant_id: str, account_id: str, customer_view_service) -> list[PatternMatch]`: Convenience method. Fetches unified view from customer_view_service, then runs detect_patterns.
    - `update_confidence_threshold(new_threshold: float) -> None`: Allows runtime threshold adjustment based on feedback loop. Clamps to [0.3, 0.95].
    - Class-level defaults: `DEFAULT_CONFIDENCE_THRESHOLD = 0.7`.

    Factory function: `create_default_engine(llm_service=None) -> PatternRecognitionEngine` that instantiates all 3 detectors and the engine with defaults.
  </action>
  <verify>Run `python -c "from src.app.intelligence.patterns.engine import PatternRecognitionEngine, create_default_engine; from src.app.intelligence.patterns.detectors import BuyingSignalDetector, RiskIndicatorDetector, EngagementChangeDetector; print('OK')"` -- imports succeed.</verify>
  <done>PatternRecognitionEngine orchestrates 3 detectors. Confidence threshold filtering at 0.7 default. Minimum 2 evidence points required.</done>
</task>

<task type="auto">
  <name>Task 2: InsightGenerator and comprehensive tests</name>
  <files>
    src/app/intelligence/patterns/insights.py
    tests/test_patterns.py
  </files>
  <action>
    **insights.py:** Create `InsightGenerator` for converting detected patterns into actionable insights and alerts.

    - Constructor takes: `repository` (IntelligenceRepository or compatible), optional `event_bus` (for real-time alerts via SSE).
    - `async create_insight(tenant_id: str, pattern: PatternMatch) -> Insight`: Persists a pattern as an insight via repository. Returns the created Insight.
    - `async create_insights_batch(tenant_id: str, patterns: list[PatternMatch]) -> list[Insight]`: Batch creation. Deduplicates by (account_id, pattern_type) -- if an identical pending insight exists for the same account and pattern type created in the last 24 hours, skip it (prevent alert flooding).
    - `async send_alert(insight: Insight) -> Alert`: For critical/high severity insights, publish to event bus for real-time SSE delivery. Creates Alert record. If event_bus is None, logs warning and returns Alert with delivered_at=None.
    - `async generate_daily_digest(tenant_id: str, clone_id: str | None = None) -> DailyDigest`: Aggregates all pending insights from the last 24 hours. Groups by account. Sorts by severity. Returns DailyDigest schema.
    - `async process_feedback(tenant_id: str, insight_id: str, feedback: str, comment: str | None = None) -> bool`: Records alert feedback ("useful" or "false_alarm") via repository. Returns True on success.
    - `async get_feedback_summary(tenant_id: str) -> dict`: Returns feedback statistics (useful_count, false_alarm_count, accuracy_rate). Used for threshold tuning.
    - `_should_alert_realtime(pattern: PatternMatch) -> bool`: Returns True if severity is "critical" or "high". Lower severity patterns go to daily digest only.
    - `_is_duplicate(existing_insights: list[Insight], pattern: PatternMatch) -> bool`: Check for duplicate within 24 hours.

    **tests/test_patterns.py:** Comprehensive tests with in-memory doubles:

    1. BuyingSignalDetector tests (4+):
       - `test_detect_budget_mention` -- "approved $500K budget" -> buying_signal pattern
       - `test_detect_timeline_urgency` -- "need this by Q2" -> buying_signal
       - `test_detect_no_signals` -- neutral conversation -> empty list
       - `test_detect_empty_timeline` -- empty timeline -> empty list

    2. RiskIndicatorDetector tests (4+):
       - `test_detect_radio_silence` -- no interactions in 14 days -> risk_indicator
       - `test_detect_budget_freeze` -- "budget freeze" mention -> risk_indicator
       - `test_detect_champion_departure` -- "new role" + champion context -> risk_indicator
       - `test_detect_no_risks` -- healthy engagement -> empty list

    3. EngagementChangeDetector tests (3+):
       - `test_detect_increasing_engagement` -- more frequent interactions -> positive engagement_change
       - `test_detect_decreasing_engagement` -- fewer interactions -> negative engagement_change
       - `test_stable_engagement` -- consistent engagement -> empty list

    4. PatternRecognitionEngine tests (4+):
       - `test_detect_patterns_filters_by_confidence` -- low confidence patterns filtered out
       - `test_detect_patterns_filters_by_evidence` -- patterns with <2 evidence filtered
       - `test_update_confidence_threshold` -- threshold clamped to [0.3, 0.95]
       - `test_detect_patterns_sorted_by_severity` -- critical before high before medium

    5. InsightGenerator tests (4+):
       - `test_create_insight` -- persists pattern as insight
       - `test_batch_deduplication` -- duplicate pattern+account within 24h skipped
       - `test_should_alert_realtime_critical` -- critical severity -> True
       - `test_should_alert_realtime_low` -- low severity -> False
       - `test_generate_daily_digest` -- aggregates last 24h insights

    Use `InMemoryIntelligenceRepository` test double from 07-01 tests (import or recreate). Mock event_bus. No database dependency.
  </action>
  <verify>Run `python -m pytest tests/test_patterns.py -v` -- all tests pass.</verify>
  <done>InsightGenerator creates insights, sends real-time alerts for critical patterns, generates daily digests, and tracks feedback. 19+ tests pass covering all pattern detection and insight generation.</done>
</task>

</tasks>

<verification>
- `python -m pytest tests/test_patterns.py -v` -- all tests pass
- Confidence threshold defaults to 0.7 (per CONTEXT.md)
- Minimum evidence requirement of 2 data points (per RESEARCH.md Pitfall 2)
- Real-time alerts for critical/high severity only
- Daily digest for lower-priority patterns
- Feedback loop tracks useful/false_alarm
</verification>

<success_criteria>
- 3 detectors identify buying signals, risk indicators, and engagement changes
- PatternRecognitionEngine orchestrates parallel detection with confidence filtering
- InsightGenerator creates insights, deduplicates, sends alerts, and generates digests
- Feedback tracking enables threshold tuning over time
- 19+ tests pass with no database dependency
</success_criteria>

<output>
After completion, create `.planning/phases/07-intelligence-autonomy/07-04-SUMMARY.md`
</output>
