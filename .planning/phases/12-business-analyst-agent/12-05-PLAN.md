---
phase: 12-business-analyst-agent
plan: 05
type: execute
wave: 3
depends_on: ["12-02"]
files_modified:
  - src/app/agents/sales/agent.py
  - src/app/agents/project_manager/agent.py
  - tests/test_ba_handoff.py
autonomous: true

must_haves:
  truths:
    - "Sales Agent dispatches to BA on keyword triggers or stage threshold"
    - "PM Agent dispatches to BA for scope change impact analysis"
    - "Both dispatches use lazy import pattern to avoid circular deps"
    - "Round-trip handoff test proves Sales->BA and PM->BA dispatch works"
    - "analysis_scope maps to correct BA task_type via explicit dict"
  artifacts:
    - path: "src/app/agents/sales/agent.py"
      provides: "dispatch_requirements_analysis handler + _is_ba_trigger heuristic"
      contains: "dispatch_requirements_analysis"
    - path: "src/app/agents/project_manager/agent.py"
      provides: "dispatch_scope_change_analysis handler"
      contains: "dispatch_scope_change_analysis"
    - path: "tests/test_ba_handoff.py"
      provides: "Round-trip integration tests for Sales->BA and PM->BA handoff"
      min_lines: 100
  key_links:
    - from: "src/app/agents/sales/agent.py"
      to: "src/app/agents/business_analyst/schemas.py"
      via: "lazy import BAHandoffRequest inside dispatch function body"
      pattern: "from src.app.agents.business_analyst.schemas import"
    - from: "src/app/agents/project_manager/agent.py"
      to: "src/app/agents/business_analyst/schemas.py"
      via: "lazy import BAHandoffRequest inside dispatch function body"
      pattern: "from src.app.agents.business_analyst.schemas import"
    - from: "src/app/agents/sales/agent.py"
      to: "src/app/agents/business_analyst/agent.py"
      via: "SCOPE_TO_TASK_TYPE dict maps analysis_scope to BA task router keys"
      pattern: "SCOPE_TO_TASK_TYPE"
---

<objective>
Add BA dispatch handlers to the Sales Agent and PM Agent, with round-trip integration tests proving cross-agent handoff works.

Purpose: Completes the BA agent's integration into the multi-agent system. Sales Agent can trigger requirements analysis from conversations; PM Agent can request scope change impact analysis.
Output: Updated sales/agent.py (dispatch_requirements_analysis + trigger heuristic), updated project_manager/agent.py (dispatch_scope_change_analysis), test_ba_handoff.py
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-business-analyst-agent/12-CONTEXT.md
@.planning/phases/12-business-analyst-agent/12-RESEARCH.md

# Pattern references -- dispatch patterns to clone
@src/app/agents/sales/agent.py
@src/app/agents/project_manager/agent.py

# Handoff test patterns
@tests/test_solution_architect.py
@tests/test_project_manager.py

# Dependencies
@src/app/agents/business_analyst/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add BA dispatch to Sales Agent and PM Agent</name>
  <files>
    src/app/agents/sales/agent.py
    src/app/agents/project_manager/agent.py
  </files>
  <action>
**Sales Agent (src/app/agents/sales/agent.py):**

1. Add `"dispatch_requirements_analysis": self._handle_dispatch_requirements_analysis` to the handlers dict in the execute() router.

2. Add the trigger heuristic as a static method:
```python
@staticmethod
def _is_ba_trigger(text: str, deal_stage: str) -> bool:
    """Detect if message should trigger BA requirements analysis.

    Triggers on:
    1. Keyword signals in message text (2+ matches required to reduce false positives)
    2. Deal reaching technical_evaluation stage

    Returns True if either condition met.
    """
    BA_KEYWORDS = [
        "we need", "our process requires", "does it support",
        "requirement", "must have", "should have", "our workflow",
        "current process", "pain point", "gap in", "can it handle",
        "business need", "use case", "acceptance criteria",
    ]
    keyword_matches = sum(1 for kw in BA_KEYWORDS if kw in text.lower())
    keyword_trigger = keyword_matches >= 2

    stage_normalized = deal_stage.lower().replace(" ", "_")
    stage_trigger = stage_normalized in ("technical_evaluation", "evaluation", "discovery")

    return keyword_trigger or stage_trigger
```

3. Add the dispatch handler. CRITICAL: Use an explicit dict to map `analysis_scope` to BA agent task_type. Do NOT use `.replace("_only", "")` -- that produces wrong keys like 'gap', 'stories', 'process' which don't match the BA agent's task router keys ('gap_analysis', 'user_story_generation', 'process_documentation').
```python
# Explicit mapping from analysis_scope values to BA agent task_type keys.
# DO NOT use .replace("_only", "") -- it produces 'gap', 'stories', 'process'
# which silently hit the BA agent's unknown-type error path.
SCOPE_TO_TASK_TYPE = {
    "full": "requirements_extraction",
    "gap_only": "gap_analysis",
    "stories_only": "user_story_generation",
    "process_only": "process_documentation",
}

async def _handle_dispatch_requirements_analysis(
    self, task: dict[str, Any], context: dict[str, Any]
) -> dict[str, Any]:
    """Dispatch requirements analysis to the Business Analyst agent.

    Uses lazy import to avoid circular dependency.

    Args:
        task: Must include 'conversation_text' and 'deal_id'.
              Optional: 'analysis_scope' (full|gap_only|stories_only|process_only).
        context: Execution context with tenant_id.

    Returns:
        Dict with status, handoff_task, payload, and target_agent_id.
    """
    conversation_text = task.get("conversation_text", "")
    deal_id = task.get("deal_id", "")

    if not conversation_text or not deal_id:
        return {
            "status": "failed",
            "error": "conversation_text and deal_id are required",
        }

    # Lazy import to avoid circular dependency
    from src.app.agents.business_analyst.schemas import BAHandoffRequest

    request = BAHandoffRequest(
        conversation_text=conversation_text,
        deal_id=deal_id,
        tenant_id=context.get("tenant_id", ""),
        analysis_scope=task.get("analysis_scope", "full"),
    )

    # Use explicit dict mapping -- NOT .replace("_only", "")
    task_type = SCOPE_TO_TASK_TYPE.get(
        request.analysis_scope, "requirements_extraction"
    )

    handoff_task = {
        "type": task_type,
        "conversation_text": conversation_text,
        "deal_id": deal_id,
    }

    logger.info(
        "requirements_analysis_dispatched",
        deal_id=deal_id,
        scope=request.analysis_scope,
        task_type=task_type,
        tenant_id=context.get("tenant_id", ""),
    )

    return {
        "status": "dispatched",
        "handoff_task": handoff_task,
        "payload": request.model_dump_json(),
        "target_agent_id": "business_analyst",
    }
```

Place `SCOPE_TO_TASK_TYPE` as a module-level constant near the top of the file (after imports, before class), OR as a class-level constant inside SalesAgent. Either is acceptable; module-level is preferred for visibility.

4. Update the module docstring to mention dispatch_requirements_analysis alongside dispatch_technical_question and dispatch_project_trigger.

**Project Manager Agent (src/app/agents/project_manager/agent.py):**

1. Add `"dispatch_scope_change_analysis": self._handle_dispatch_scope_change_analysis` to the PM agent's handlers dict in its execute() router.

2. Add the dispatch handler:
```python
async def _handle_dispatch_scope_change_analysis(
    self, task: dict[str, Any], context: dict[str, Any]
) -> dict[str, Any]:
    """Dispatch scope change impact analysis to the Business Analyst agent.

    When a scope change occurs on a project, the PM asks the BA to
    analyze the impact on requirements. Uses lazy import pattern.

    Args:
        task: Must include 'conversation_text' describing the scope change,
              'deal_id', and optional 'existing_requirements'.
        context: Execution context with tenant_id.

    Returns:
        Dict with status, handoff_task, payload, and target_agent_id.
    """
    conversation_text = task.get("conversation_text", "")
    deal_id = task.get("deal_id", "")

    if not conversation_text or not deal_id:
        return {
            "status": "failed",
            "error": "conversation_text and deal_id are required for scope change analysis",
        }

    # Lazy import to avoid circular dependency
    from src.app.agents.business_analyst.schemas import BAHandoffRequest

    request = BAHandoffRequest(
        conversation_text=conversation_text,
        deal_id=deal_id,
        tenant_id=context.get("tenant_id", ""),
        analysis_scope="gap_only",  # Scope changes need gap analysis
    )

    handoff_task = {
        "type": "gap_analysis",
        "conversation_text": conversation_text,
        "deal_id": deal_id,
        "existing_requirements": task.get("existing_requirements", []),
    }

    self._log.info(
        "scope_change_analysis_dispatched",
        deal_id=deal_id,
        tenant_id=context.get("tenant_id", ""),
    )

    return {
        "status": "dispatched",
        "handoff_task": handoff_task,
        "payload": request.model_dump_json(),
        "target_agent_id": "business_analyst",
    }
```

3. Update the PM module docstring to mention dispatch_scope_change_analysis.

CRITICAL: Both dispatch handlers MUST use lazy import (`from src.app.agents.business_analyst.schemas import BAHandoffRequest` INSIDE the function body, NOT at module top level). This prevents circular imports.
  </action>
  <verify>
Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "
# Verify Sales Agent has the new handler
from src.app.agents.sales.agent import SalesAgent
assert hasattr(SalesAgent, '_handle_dispatch_requirements_analysis'), 'Sales Agent missing BA dispatch handler'
assert hasattr(SalesAgent, '_is_ba_trigger'), 'Sales Agent missing BA trigger heuristic'
print('Sales Agent BA dispatch OK')
"` -- must succeed.

Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "
# Verify PM Agent has the new handler
from src.app.agents.project_manager.agent import ProjectManagerAgent
assert hasattr(ProjectManagerAgent, '_handle_dispatch_scope_change_analysis'), 'PM Agent missing scope change dispatch'
print('PM Agent scope change dispatch OK')
"` -- must succeed.

Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "
# Verify lazy import works (no circular import)
from src.app.agents.sales.agent import SalesAgent
from src.app.agents.project_manager.agent import ProjectManagerAgent
from src.app.agents.business_analyst.schemas import BAHandoffRequest
print('No circular imports')
"` -- must succeed.

Run: `cd "/Users/RAZER/Documents/projects/sales army" && grep -n 'SCOPE_TO_TASK_TYPE' src/app/agents/sales/agent.py` -- must find the explicit mapping dict.
  </verify>
  <done>
Sales Agent has dispatch_requirements_analysis with keyword/stage trigger heuristic and explicit SCOPE_TO_TASK_TYPE dict mapping. PM Agent has dispatch_scope_change_analysis. Both use lazy import pattern. All analysis_scope values map to correct BA task router keys.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create round-trip handoff integration tests</name>
  <files>tests/test_ba_handoff.py</files>
  <action>
Create `tests/test_ba_handoff.py` following the patterns in the SA handoff tests (test_solution_architect.py) and PM handoff tests (test_project_manager.py).

**Tests (minimum 8):**

1. `test_sales_agent_ba_trigger_keyword_detection` -- Test _is_ba_trigger with various texts:
   - "We need API access and our process requires SSO" -> True (2 keyword matches)
   - "Hello, nice weather" -> False (0 matches)
   - "We need something" -> False (only 1 match, need 2+)

2. `test_sales_agent_ba_trigger_stage_detection` -- Test _is_ba_trigger with stage triggers:
   - deal_stage="technical_evaluation" -> True
   - deal_stage="Technical Evaluation" -> True (case insensitive)
   - deal_stage="prospecting" -> False

3. `test_sales_agent_dispatch_requirements_analysis` -- Create SalesAgent with mock LLM, call execute with type="dispatch_requirements_analysis", conversation_text, deal_id. Assert result has status="dispatched", target_agent_id="business_analyst", handoff_task with correct type.

4. `test_sales_agent_dispatch_missing_fields` -- Call dispatch without conversation_text or deal_id. Assert status="failed".

5. `test_sales_agent_scope_to_task_type_mapping` -- Verify all 4 analysis_scope values map correctly:
   - "full" -> handoff_task["type"] == "requirements_extraction"
   - "gap_only" -> handoff_task["type"] == "gap_analysis"
   - "stories_only" -> handoff_task["type"] == "user_story_generation"
   - "process_only" -> handoff_task["type"] == "process_documentation"
   This test is CRITICAL -- it proves the SCOPE_TO_TASK_TYPE dict fix works and prevents regression to the broken .replace("_only", "") pattern.

6. `test_pm_agent_dispatch_scope_change_analysis` -- Create ProjectManagerAgent with mock LLM, call execute with type="dispatch_scope_change_analysis", conversation_text, deal_id. Assert result has status="dispatched", target_agent_id="business_analyst".

7. `test_pm_agent_dispatch_missing_fields` -- Call dispatch without required fields. Assert status="failed".

8. `test_sales_to_ba_round_trip` -- Full round-trip test:
   a. Create Sales Agent (mock LLM) and BA Agent (mock LLM returning requirements JSON)
   b. Sales Agent dispatches requirements_analysis
   c. Use dispatch result's handoff_task to call BA Agent's execute()
   d. Assert BA Agent returns structured requirements in result
   This tests the complete Sales -> BA handoff flow with mocked LLM.

9. `test_pm_to_ba_round_trip` -- Full round-trip test:
   a. Create PM Agent (mock LLM) and BA Agent (mock LLM returning gap analysis JSON)
   b. PM Agent dispatches scope_change_analysis
   c. Use dispatch result's handoff_task to call BA Agent's execute()
   d. Assert BA Agent returns gap analysis in result

**Agent fixtures:**
- `sales_agent` fixture: SalesAgent with mock LLM (reuse the fixture pattern from existing tests -- mock enough of SalesAgent constructor to work)
- `ba_agent` fixture: BusinessAnalystAgent with mock LLM
- `pm_agent` fixture: ProjectManagerAgent with mock LLM

For constructing agents in tests, follow the exact patterns used in test_solution_architect.py and test_project_manager.py. The SalesAgent constructor may need more mocks -- check its __init__ signature and mock what's needed.

All tests use `@pytest.mark.asyncio`. Mock LLM returns pre-built JSON strings.
  </action>
  <verify>
Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -m pytest tests/test_ba_handoff.py -v --timeout=30 2>&1 | tail -20` -- all tests must pass.

Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -m pytest tests/test_ba_handoff.py --co -q 2>&1` -- must list at least 9 tests (including the new scope mapping test).

Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -m pytest tests/ -x -q --timeout=30 2>&1 | tail -5` -- full test suite passes.
  </verify>
  <done>
9+ round-trip handoff tests pass covering Sales->BA dispatch (keyword triggers, stage triggers, missing fields, scope-to-task-type mapping), PM->BA dispatch, and full round-trip flows proving end-to-end handoff works. The scope mapping test explicitly verifies all 4 analysis_scope values resolve to correct BA task router keys.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_ba_handoff.py -v` -- all 9+ tests pass
2. `python -m pytest tests/ -x -q --timeout=30` -- full test suite passes
3. Sales Agent has dispatch_requirements_analysis + _is_ba_trigger
4. PM Agent has dispatch_scope_change_analysis
5. No circular imports between Sales/PM/BA agent modules
6. `grep 'SCOPE_TO_TASK_TYPE' src/app/agents/sales/agent.py` -- explicit dict exists
</verification>

<success_criteria>
- Sales Agent dispatches to BA on 2+ keyword matches or stage threshold
- PM Agent dispatches to BA for scope change impact analysis
- Both use lazy import pattern (no circular deps)
- SCOPE_TO_TASK_TYPE dict correctly maps all 4 scope values to BA task router keys
- Round-trip tests prove Sales->BA and PM->BA handoff flows work
- Full existing test suite still passes
</success_criteria>

<output>
After completion, create `.planning/phases/12-business-analyst-agent/12-05-SUMMARY.md`
</output>
