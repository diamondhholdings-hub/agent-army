---
phase: 12-business-analyst-agent
plan: 03
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/app/agents/business_analyst/notion_ba.py
autonomous: true

must_haves:
  truths:
    - "NotionBAAdapter creates requirement pages linked to deals"
    - "Block renderers are module-level functions decoupled from adapter class"
    - "User stories render dual-grouped: by epic/theme AND by stakeholder domain"
    - "Low-confidence items are visually flagged in Notion output"
  artifacts:
    - path: "src/app/agents/business_analyst/notion_ba.py"
      provides: "NotionBAAdapter + 4 module-level block renderers"
      exports: ["NotionBAAdapter", "render_requirements_to_notion_blocks", "render_gap_analysis_to_notion_blocks", "render_user_stories_to_notion_blocks", "render_process_doc_to_notion_blocks"]
      min_lines: 150
  key_links:
    - from: "src/app/agents/business_analyst/notion_ba.py"
      to: "src/app/agents/business_analyst/schemas.py"
      via: "imports domain models for block rendering"
      pattern: "from src.app.agents.business_analyst.schemas import"
    - from: "src/app/agents/business_analyst/notion_ba.py"
      to: "notion_client.AsyncClient"
      via: "graceful import with fallback placeholder"
      pattern: "from notion_client import AsyncClient"
---

<objective>
Build the NotionBAAdapter for creating Notion pages from BA analysis results, following the NotionPMAdapter pattern with module-level block renderers.

Purpose: Delivers BA results to the CRM as Notion pages linked to deals, making requirements, gaps, stories, and process docs visible to the sales team.
Output: notion_ba.py with NotionBAAdapter class + 4 module-level block renderer functions
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-business-analyst-agent/12-CONTEXT.md
@.planning/phases/12-business-analyst-agent/12-RESEARCH.md

# Pattern reference -- clone this structure exactly
@src/app/agents/project_manager/notion_pm.py

# Dependencies from plan 01
@src/app/agents/business_analyst/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create module-level block renderers for BA domain models</name>
  <files>src/app/agents/business_analyst/notion_ba.py</files>
  <action>
Create `notion_ba.py` following the NotionPMAdapter pattern from Phase 11.

**Imports and graceful notion-client handling** -- same pattern as notion_pm.py:
```python
from __future__ import annotations
from datetime import datetime, timezone
from typing import Any
import structlog
from tenacity import retry, retry_if_exception_type, stop_after_attempt, wait_exponential

from src.app.agents.business_analyst.schemas import (
    ExtractedRequirement, CapabilityGap, RequirementContradiction,
    UserStory, ProcessDocumentation, GapAnalysisResult, BAResult,
)

try:
    from notion_client import AsyncClient
except ImportError as _import_err:
    # ... same placeholder pattern as notion_pm.py
```

**Module-level block renderer functions** (decoupled from adapter class):

1. `render_requirements_to_notion_blocks(requirements: list[ExtractedRequirement]) -> list[dict]`:
   - Heading 2: "Requirements"
   - Group requirements by category (functional, non_functional, constraint)
   - For each group: Heading 3 with category name, then a table or bulleted list of requirements
   - Each requirement shows: description, MoSCoW priority, stakeholder domain, priority score, confidence
   - Low-confidence requirements (is_low_confidence=True) get a warning callout or italic prefix "[LOW CONFIDENCE]"
   - Return list of Notion block dicts

2. `render_gap_analysis_to_notion_blocks(gap_analysis: GapAnalysisResult) -> list[dict]`:
   - Heading 2: "Gap Analysis"
   - Paragraph: f"Coverage: {gap_analysis.coverage_percentage:.1f}%"
   - If gaps exist: Heading 3 "Gaps", then each gap as a bulleted list item with description, severity, recommended_action, and SA escalation flag
   - If contradictions exist: Heading 3 "Contradictions", then each contradiction as a bulleted list item with conflict_description, affected requirement IDs, resolution_suggestion
   - Callout block for recommended_next_action

3. `render_user_stories_to_notion_blocks(stories: list[UserStory]) -> list[dict]`:
   - Heading 2: "User Stories"
   - **Dual grouping:** First section groups by epic_theme, second section groups by stakeholder_domain
   - For epic grouping: Heading 3 per epic, then each story as a toggle block containing As-a/I-want/So-that + acceptance criteria + story points + priority
   - For domain grouping: Heading 3 per domain, then story IDs listed (cross-reference to epic section)
   - Low-confidence stories flagged with "[LOW CONFIDENCE]" prefix

4. `render_process_doc_to_notion_blocks(process_doc: ProcessDocumentation) -> list[dict]`:
   - Heading 2: f"Process: {process_doc.process_name}"
   - Heading 3: "Current State" + paragraph with current_state
   - Heading 3: "Future State" + paragraph with future_state
   - Heading 3: "Delta (Changes)" + paragraph with delta
   - Bulleted list of stakeholders
   - If assumptions: Heading 3 "Assumptions" + bulleted list

**Notion block helpers** (internal, prefixed with `_`):
- `_heading_block(text: str, level: int = 2) -> dict` -- creates heading_2 or heading_3 block
- `_paragraph_block(text: str) -> dict` -- creates paragraph block
- `_bulleted_list_block(text: str) -> dict` -- creates bulleted_list_item block
- `_callout_block(text: str, emoji: str = "!") -> dict` -- creates callout block
- `_toggle_block(text: str, children: list[dict]) -> dict` -- creates toggle block

These helpers follow the exact Notion API block format:
```python
def _paragraph_block(text: str) -> dict:
    return {
        "object": "block",
        "type": "paragraph",
        "paragraph": {
            "rich_text": [{"type": "text", "text": {"content": text}}]
        }
    }
```
  </action>
  <verify>
Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "
from src.app.agents.business_analyst.notion_ba import (
    render_requirements_to_notion_blocks,
    render_gap_analysis_to_notion_blocks,
    render_user_stories_to_notion_blocks,
    render_process_doc_to_notion_blocks,
)
from src.app.agents.business_analyst.schemas import (
    ExtractedRequirement, GapAnalysisResult, CapabilityGap,
    RequirementContradiction, UserStory, ProcessDocumentation,
)

# Test requirements renderer
reqs = [
    ExtractedRequirement(requirement_id='REQ-001', description='SSO support', category='functional', moscow_priority='must_have', stakeholder_domain='tech', priority_score='high', extraction_confidence=0.9),
    ExtractedRequirement(requirement_id='REQ-002', description='Maybe logging', category='non_functional', moscow_priority='could_have', stakeholder_domain='ops', priority_score='low', extraction_confidence=0.4),
]
blocks = render_requirements_to_notion_blocks(reqs)
assert len(blocks) > 0, 'No blocks rendered for requirements'
# Verify low-confidence flag appears somewhere
block_text = str(blocks)
assert 'LOW CONFIDENCE' in block_text, 'Low confidence not flagged'

# Test gap analysis renderer
gap = GapAnalysisResult(
    requirements=reqs,
    gaps=[CapabilityGap(requirement_id='REQ-001', gap_description='No SSO yet', severity='critical', recommended_action='build_it')],
    contradictions=[RequirementContradiction(requirement_ids=['REQ-001', 'REQ-002'], conflict_description='Contradicts', resolution_suggestion='Discuss', severity='minor')],
    coverage_percentage=75.0,
    recommended_next_action='Address SSO gap',
)
gap_blocks = render_gap_analysis_to_notion_blocks(gap)
assert len(gap_blocks) > 0, 'No blocks for gap analysis'

# Test user stories renderer
stories = [
    UserStory(story_id='US-001', as_a='admin', i_want='SSO', so_that='security', acceptance_criteria=['SAML works'], story_points=5, priority='must_have', epic_theme='Auth', stakeholder_domain='tech'),
]
story_blocks = render_user_stories_to_notion_blocks(stories)
assert len(story_blocks) > 0, 'No blocks for stories'

# Test process doc renderer
doc = ProcessDocumentation(process_name='Onboarding', current_state='Manual', future_state='Automated', delta='Remove manual steps', stakeholders=['Sales', 'Ops'])
doc_blocks = render_process_doc_to_notion_blocks(doc)
assert len(doc_blocks) > 0, 'No blocks for process doc'

print('All 4 renderers produce valid blocks')
"` -- must succeed.
  </verify>
  <done>
4 module-level renderers produce Notion block lists. Low-confidence items flagged. User stories dual-grouped by epic and domain.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create NotionBAAdapter class with retry-wrapped CRUD methods</name>
  <files>src/app/agents/business_analyst/notion_ba.py</files>
  <action>
Add the `NotionBAAdapter` class to the same `notion_ba.py` file, after the module-level renderers.

**Class: NotionBAAdapter**

Constructor:
- `__init__(self, notion_client: AsyncClient, database_id: str)` -- takes pre-authenticated AsyncClient (NOT token string, same as NotionPMAdapter)
- Store `self.client = notion_client`, `self.database_id = database_id`
- Create bound logger

Methods:

1. `async def create_requirements_page(self, deal_id: str, result: BAResult, title: str | None = None) -> str`:
   - Creates a new Notion page in the BA database
   - Title: `title or f"BA Analysis - {deal_id} - {datetime.now(timezone.utc).strftime('%Y-%m-%d')}"`
   - Properties: deal_id (rich_text), analysis_date (date), task_type (select)
   - Children blocks: Combine all relevant renderers based on what's in BAResult:
     - If result.requirements: render_requirements_to_notion_blocks
     - If result.gap_analysis: render_gap_analysis_to_notion_blocks
     - If result.user_stories: render_user_stories_to_notion_blocks
     - If result.process_documentation: render_process_doc_to_notion_blocks
   - Returns page URL
   - Wrapped with tenacity retry: `@retry(retry=retry_if_exception_type(Exception), stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=1, max=10))`

2. `async def update_requirements_page(self, page_id: str, result: BAResult) -> None`:
   - Appends new blocks to existing page (for incremental analysis)
   - Uses `self.client.blocks.children.append(page_id, children=blocks)`
   - Retry-wrapped

3. `async def get_deal_analysis_pages(self, deal_id: str) -> list[dict]`:
   - Queries database for pages matching deal_id
   - Returns list of page metadata dicts
   - Retry-wrapped

The Notion API call pattern (same as notion_pm.py):
```python
page = await self.client.pages.create(
    parent={"database_id": self.database_id},
    properties={
        "title": {"title": [{"text": {"content": page_title}}]},
        "Deal ID": {"rich_text": [{"text": {"content": deal_id}}]},
        # ...
    },
    children=blocks[:100],  # Notion API limit: 100 blocks per request
)
page_url = page.get("url", "")
```

If blocks exceed 100, append remaining in subsequent calls.
  </action>
  <verify>
Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "
from src.app.agents.business_analyst.notion_ba import NotionBAAdapter
import inspect
methods = [m for m in dir(NotionBAAdapter) if not m.startswith('_')]
assert 'create_requirements_page' in methods, 'Missing create_requirements_page'
assert 'update_requirements_page' in methods, 'Missing update_requirements_page'
assert 'get_deal_analysis_pages' in methods, 'Missing get_deal_analysis_pages'
print(f'NotionBAAdapter has {len(methods)} public methods: {methods}')
"` -- must succeed.
  </verify>
  <done>
NotionBAAdapter with 3 retry-wrapped CRUD methods. Takes pre-authenticated AsyncClient. create_requirements_page combines all 4 renderers based on BAResult content and returns page URL.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.app.agents.business_analyst.notion_ba import NotionBAAdapter, render_requirements_to_notion_blocks"` -- imports succeed
2. All 4 renderers produce non-empty block lists for valid input
3. NotionBAAdapter has create_requirements_page, update_requirements_page, get_deal_analysis_pages methods
4. Existing tests still pass
</verification>

<success_criteria>
- 4 module-level block renderers produce correct Notion block structures
- Low-confidence items visually flagged in rendered output
- User stories dual-grouped (by epic_theme and stakeholder_domain)
- NotionBAAdapter takes pre-authenticated AsyncClient
- All methods retry-wrapped with tenacity
- Existing test suite unbroken
</success_criteria>

<output>
After completion, create `.planning/phases/12-business-analyst-agent/12-03-SUMMARY.md`
</output>
