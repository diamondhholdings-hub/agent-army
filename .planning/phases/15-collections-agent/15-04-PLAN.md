---
phase: 15-collections-agent
plan: 04
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/app/agents/collections/notion_adapter.py
  - src/app/config.py
autonomous: true

must_haves:
  truths:
    - "NotionCollectionsAdapter reads AR invoice data from a Notion DB and builds ARAgingReport with 4 aging buckets"
    - "NotionCollectionsAdapter persists and retrieves EscalationState per account from a dedicated Notion DB"
    - "create_payment_plan_page writes a structured Notion page with options table and returns page_id"
    - "log_collection_event writes an append-only event log entry to Notion"
    - "get_all_delinquent_accounts returns list of account dicts with outstanding invoices for scheduler scan"
    - "Config has 4 new Notion DB ID settings for collections"
  artifacts:
    - path: "src/app/agents/collections/notion_adapter.py"
      provides: "NotionCollectionsAdapter with 6 async methods"
      min_lines: 180
    - path: "src/app/config.py"
      provides: "4 new NOTION_COLLECTIONS_* settings fields"
      contains: "NOTION_COLLECTIONS_AR_DATABASE_ID"
  key_links:
    - from: "src/app/agents/collections/notion_adapter.py"
      to: "src/app/agents/collections/schemas.py"
      via: "ARAgingReport, ARAgingBucket, EscalationState imported and returned"
      pattern: "from src.app.agents.collections.schemas import"
    - from: "src/app/agents/collections/notion_adapter.py"
      to: "notion_client.AsyncClient"
      via: "takes pre-authenticated AsyncClient in constructor"
      pattern: "def __init__.*notion_client"
---

<objective>
Build NotionCollectionsAdapter (6 async methods) and add 4 new config settings for Collections Notion databases. The adapter is the persistence layer — it reads AR invoices, persists escalation state, creates payment plan pages, and logs events.

Purpose: Collections Agent needs a Notion persistence layer for AR invoice data, escalation state machine, payment plan pages, and audit log. This plan is Wave 2 (parallel with scorer) because it only depends on schemas, not handlers.
Output: `src/app/agents/collections/notion_adapter.py` and 4 new fields in `src/app/config.py`.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md

@src/app/agents/collections/schemas.py
@src/app/agents/customer_success/notion_adapter.py
@src/app/agents/technical_account_manager/notion_adapter.py
@src/app/config.py
@.planning/phases/15-collections-agent/15-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 4 Collections Notion config fields to Settings</name>
  <files>src/app/config.py</files>
  <action>
Edit `src/app/config.py` — add 4 new fields to the `Settings` class after the existing Notion CSM fields (after line ~76):

```python
# Notion Collections Agent Databases -- Phase 15
NOTION_COLLECTIONS_AR_DATABASE_ID: str = ""      # AR invoices tracking DB
NOTION_COLLECTIONS_ESCALATION_DATABASE_ID: str = ""  # Escalation state per account DB
NOTION_COLLECTIONS_EVENTS_DATABASE_ID: str = ""  # Collections event log DB
FINANCE_TEAM_EMAIL: str = ""                      # Finance team email for stage 5 human handoff
```

Add comment block header `# Notion Collections Agent Databases -- Phase 15` before the 3 Notion fields.
FINANCE_TEAM_EMAIL is a plain str field (not a Notion DB ID but placed here with related settings).

Do NOT modify any other settings. Do NOT change any existing fields.
  </action>
  <verify>
Run: `cd /Users/RAZER/Documents/projects/sales\ army && python -c "from src.app.config import get_settings; s = get_settings(); assert hasattr(s, 'NOTION_COLLECTIONS_AR_DATABASE_ID'); assert hasattr(s, 'NOTION_COLLECTIONS_ESCALATION_DATABASE_ID'); assert hasattr(s, 'NOTION_COLLECTIONS_EVENTS_DATABASE_ID'); assert hasattr(s, 'FINANCE_TEAM_EMAIL'); print('config OK')"` — note: call `get_settings.cache_clear()` may be needed if settings was already loaded.
  </verify>
  <done>All 4 new settings fields exist on Settings class with empty string defaults. Existing settings untouched. Module imports without error.</done>
</task>

<task type="auto">
  <name>Task 2: Create NotionCollectionsAdapter with 6 async methods</name>
  <files>src/app/agents/collections/notion_adapter.py</files>
  <action>
Create `src/app/agents/collections/notion_adapter.py` following the NotionCSMAdapter pattern exactly (takes pre-authenticated AsyncClient, module-level block renderer functions, no token strings).

Module docstring: Notion adapter for Collections Agent — reads AR invoices, persists escalation state, creates payment plan pages, and logs collection events.

```python
from __future__ import annotations
from datetime import date, datetime, timezone
from typing import Any
import structlog
from src.app.agents.collections.schemas import ARAgingBucket, ARAgingReport, EscalationState

logger = structlog.get_logger(__name__)

class NotionCollectionsAdapter:
    """Notion persistence adapter for Collections Agent.

    Reads AR invoice data, manages escalation state machine, creates payment
    plan pages, and maintains collection event log.

    Args:
        notion_client: Pre-authenticated notion_client.AsyncClient instance.
        ar_database_id: Notion DB ID for AR invoices.
        escalation_database_id: Notion DB ID for escalation state per account.
        events_database_id: Notion DB ID for collections event log.
    """
    def __init__(self, notion_client, *, ar_database_id: str, escalation_database_id: str, events_database_id: str):
        self._client = notion_client
        self._ar_db = ar_database_id
        self._esc_db = escalation_database_id
        self._events_db = events_database_id
```

**Method 1: async get_ar_aging(account_id: str) -> ARAgingReport**
Query `_ar_db` filtering by account_id property AND status=="outstanding". For each invoice page, extract: invoice_number, invoice_date, amount_usd, days_overdue from Notion page properties. Group invoices into 4 aging buckets by days_overdue:
- "0-30": 0-30 days
- "31-60": 31-60 days
- "61-90": 61-90 days
- "90+": 91+ days
Build ARAgingBucket for each bucket that has at least 1 invoice. Compute total_outstanding_usd as sum of all invoice amounts. Find oldest invoice (highest days_overdue). Return ARAgingReport. If Notion query fails, log error and return ARAgingReport with empty buckets and zero totals.

**Method 2: async get_all_delinquent_accounts() -> list[dict]**
Query `_ar_db` filtering by status=="outstanding" AND days_overdue > 0. Return list of dicts with unique account_ids and their total outstanding amounts. Used by CollectionsScheduler for daily scan.

**Method 3: async get_escalation_state(account_id: str) -> EscalationState**
Query `_esc_db` filtering by account_id. If no record found, return EscalationState(account_id=account_id) (default state, stage=0). Parse Notion page properties (current_stage, stage_entered_at, last_message_sent_at, messages_unanswered as number, stage5_notified as checkbox, payment_received_at, response_received_at). Return EscalationState model.

**Method 4: async update_escalation_state(account_id: str, state: EscalationState) -> None**
Upsert to `_esc_db`. Query for existing page by account_id. If exists: update properties. If not exists: create new page. Properties to write: current_stage (number), stage_entered_at (date), last_message_sent_at (date), messages_unanswered (number), stage5_notified (checkbox), payment_received_at (date), response_received_at (date). Log error on failure but do not raise (fail-open).

**Method 5: async create_payment_plan_page(account_id: str, options: dict) -> str**
Create a new Notion page. Page title: "Payment Plan Options — {account_id} — {date}". Add heading block "Payment Plan Options". Add paragraph with total outstanding amount. Add a table or bulleted list with each option (option_type, description, total_usd, proposed_dates). Add paragraph with llm_rationale. Return the created page's id (UUID). Log error and return "" on failure.

**Method 6: async log_collection_event(account_id: str, event_type: str, details: dict) -> None**
Create a new page in `_events_db` with: account_id property, event_type property, event details as paragraph blocks, timestamp (created_at as date property set to now). Append-only — never modify existing event log entries. Log error on failure but do not raise.

Module-level block renderer helpers (decoupled from adapter class, following CSM/TAM pattern):
- `def _make_heading(text: str) -> dict` — returns Notion heading_2 block dict
- `def _make_paragraph(text: str) -> dict` — returns Notion paragraph block dict
- `def _make_option_bullet(option: dict) -> dict` — returns Notion bulleted_list_item block dict

Export: `__all__ = ["NotionCollectionsAdapter"]`
  </action>
  <verify>
Run: `cd /Users/RAZER/Documents/projects/sales\ army && python -c "from src.app.agents.collections.notion_adapter import NotionCollectionsAdapter; import inspect; methods = [m for m in dir(NotionCollectionsAdapter) if not m.startswith('_')]; print('methods:', methods); assert 'get_ar_aging' in methods; assert 'get_all_delinquent_accounts' in methods; assert 'get_escalation_state' in methods; assert 'update_escalation_state' in methods; assert 'create_payment_plan_page' in methods; assert 'log_collection_event' in methods; print('adapter OK')"`
  </verify>
  <done>NotionCollectionsAdapter importable, all 6 public methods present, constructor takes notion_client and 3 keyword-only DB ID args. Module-level block renderer helpers exist. No import errors.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.app.agents.collections.notion_adapter import NotionCollectionsAdapter; a = NotionCollectionsAdapter(None, ar_database_id='db1', escalation_database_id='db2', events_database_id='db3')"` — instantiates without error
2. `grep -n "NOTION_COLLECTIONS\|FINANCE_TEAM_EMAIL" src/app/config.py` — all 4 fields present
3. `python -m pytest tests/test_csm_schemas.py -q` — CSM tests unaffected by config change
4. `python -c "from src.app.agents.collections.notion_adapter import _make_heading, _make_paragraph"` — module-level helpers importable
</verification>

<success_criteria>
- NotionCollectionsAdapter has 6 async methods matching the spec
- Constructor follows NotionCSMAdapter pattern (pre-authenticated client, keyword-only DB IDs)
- All methods fail-open (log errors, don't raise, return safe defaults)
- 4 new config fields added to Settings class with empty string defaults
- FINANCE_TEAM_EMAIL in config.py for stage 5 human handoff
</success_criteria>

<output>
After completion, create `.planning/phases/15-collections-agent/15-04-SUMMARY.md`
</output>
