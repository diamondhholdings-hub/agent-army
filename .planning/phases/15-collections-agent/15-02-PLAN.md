---
phase: 15-collections-agent
plan: 02
type: tdd
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/app/agents/collections/scorer.py
  - tests/test_collections_scorer.py
autonomous: true

must_haves:
  truths:
    - "PaymentRiskScorer produces correct risk bands: GREEN for score < 30, AMBER for 30-60, RED for 60-85, CRITICAL for >= 85"
    - "should_escalate is True when score >= 60 (AMBER threshold — escalation starts at medium risk)"
    - "Days overdue is the primary driver: 120+ days → 40 points, 90 days → 35 points, 60 days → 25 points, 30 days → 12 points, 0 days → 0 points"
    - "Payment streak scoring: 12+ consecutive on-time → 0 points, mixed → 8-15 points, 3+ consecutive late → 20 points, 6+ consecutive late → 25 points"
    - "Balance scoring: <$1k → 0 pts, $1-10k → 8 pts, $10-50k → 14 pts, $50k+ → 20 pts"
    - "Renewal scoring: >90d → 0 pts, 31-90d → 5 pts, 8-30d → 10 pts, <=7d → 15 pts"
    - "compute_tone_modifier returns float in [0.6, 1.4]: ARR $500k+ gives -0.2, $100-500k gives -0.1; 3+ yr tenure gives -0.1; 3+ consecutive late gives +0.2"
  artifacts:
    - path: "src/app/agents/collections/scorer.py"
      provides: "PaymentRiskScorer and compute_tone_modifier"
      exports: ["PaymentRiskScorer", "compute_tone_modifier"]
      min_lines: 80
    - path: "tests/test_collections_scorer.py"
      provides: "TDD test suite for scorer"
      min_lines: 80
  key_links:
    - from: "tests/test_collections_scorer.py"
      to: "src/app/agents/collections/scorer.py"
      via: "imports PaymentRiskScorer, PaymentRiskSignals, compute_tone_modifier"
      pattern: "from src.app.agents.collections.scorer import"
---

<objective>
Build the PaymentRiskScorer (deterministic Python, no LLM) and compute_tone_modifier function using TDD. The scorer is the algorithmic heart of the Collections Agent — it determines risk bands and escalation triggers for every account.

Purpose: TDD forces precise specification of the scoring algorithm before implementation. The 4-signal scoring system has well-defined inputs/outputs (perfect TDD fit). Red-green-refactor produces a correct, tested scorer with no ambiguity in edge cases.
Output: `src/app/agents/collections/scorer.py` (PaymentRiskScorer class + compute_tone_modifier function) and `tests/test_collections_scorer.py` with comprehensive test cases.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md

@src/app/agents/collections/schemas.py
@src/app/agents/customer_success/health_scorer.py
@.planning/phases/15-collections-agent/15-01-SUMMARY.md
</context>

<feature>
  <name>PaymentRiskScorer + compute_tone_modifier</name>
  <files>src/app/agents/collections/scorer.py, tests/test_collections_scorer.py</files>
  <behavior>
PaymentRiskScorer.score(signals: PaymentRiskSignals) -> PaymentRiskResult

Score direction: higher = MORE RISK (inverted from CSM health scorer where higher = healthier).
Total score sums 4 components, max 100 points:

Component 1 — days_overdue (0-40 points):
  0 days    → 0 pts
  1-29 days → 0 pts (not yet overdue by any meaningful amount)
  30 days   → 12 pts
  31-59d    → 12 pts (stays at 30d level)
  60 days   → 25 pts
  61-89d    → 25 pts (stays at 60d level)
  90 days   → 35 pts
  91-119d   → 35 pts (stays at 90d level)
  120+ days → 40 pts (maximum)

Component 2 — payment_history_streak (0-25 points):
  streak >= 12   → 0 pts  (12+ consecutive on-time payments)
  streak >= 6    → 3 pts  (6-11 consecutive on-time)
  streak >= 1    → 8 pts  (1-5 consecutive on-time, mixed history)
  streak == 0    → 12 pts (neutral, no clear pattern)
  streak >= -2   → 15 pts (1-2 consecutive late)
  streak >= -5   → 20 pts (3-5 consecutive late)
  streak <= -6   → 25 pts (6+ consecutive late, chronic)

Component 3 — total_outstanding_balance_usd (0-20 points):
  < $1,000    → 0 pts
  $1-9,999    → 8 pts
  $10-49,999  → 14 pts
  $50,000+    → 20 pts

Component 4 — days_to_renewal (0-15 points):
  > 90 days → 0 pts
  31-90d    → 5 pts
  8-30d     → 10 pts
  0-7d      → 15 pts (renewal imminent, collections pressure highest)

RAG derivation (after summing all 4):
  score < 30  → GREEN
  score < 60  → AMBER
  score < 85  → RED
  score >= 85 → CRITICAL

should_escalate: True when score >= 60 (AMBER+)

Test cases:
  Clean account (0d overdue, streak=12, $500, 120d renewal) → score=0+0+0+0=0 → GREEN, should_escalate=False
  Slightly late (30d overdue, streak=0, $5k, 60d renewal) → 12+12+8+5=37 → AMBER, should_escalate=True
  Serious delinquent (90d, streak=-3, $25k, 14d renewal) → 35+20+14+10=79 → RED, should_escalate=True
  Critical (120d+, streak=-6, $75k, 5d renewal) → 40+25+20+15=100 → CRITICAL, should_escalate=True
  High ARR, clean otherwise (60d, streak=6, $500, 100d) → 25+3+0+0=28 → GREEN (just under 30), should_escalate=False

compute_tone_modifier(days_overdue, arr_usd, payment_streak, tenure_years) -> float:
  base = 1.0
  arr_mod: arr >= 500_000 → -0.2; arr >= 100_000 → -0.1; else → 0.0
  tenure_mod: tenure >= 3 years → -0.1; else → 0.0
  streak_mod: payment_streak <= -3 → +0.2; else → 0.0
  modifier = clamp(base + arr_mod + tenure_mod + streak_mod, 0.6, 1.4)

Tone modifier test cases:
  Enterprise ($600k ARR, 5yr tenure, clean history) → 1.0 - 0.2 - 0.1 + 0.0 = 0.7
  Mid-market ($150k ARR, 1yr, clean) → 1.0 - 0.1 - 0.0 + 0.0 = 0.9
  SMB chronic late ($50k ARR, 2yr, streak=-4) → 1.0 + 0.0 + 0.0 + 0.2 = 1.2
  Minimum clamp test: enterprise + chronic late → 1.0 - 0.2 - 0.1 + 0.2 = 0.9
  Default (no modifiers) → 1.0
  </behavior>
  <implementation>
scorer.py module structure:

```python
"""Deterministic payment risk scoring and tone calibration for Collections Agent."""
from __future__ import annotations
from src.app.agents.collections.schemas import PaymentRiskResult, PaymentRiskSignals

_STAGE_TIME_FLOORS: dict[int, int] = {1: 7, 2: 10, 3: 7, 4: 5}  # days per stage

class PaymentRiskScorer:
    def score(self, signals: PaymentRiskSignals) -> PaymentRiskResult:
        # Compute 4 component scores
        # Sum → raw_score
        # Derive rag from thresholds (GREEN<30, AMBER<60, RED<85, CRITICAL>=85)
        # Build score_breakdown dict
        # Return PaymentRiskResult(account_id, score, rag, score_breakdown)

def compute_tone_modifier(days_overdue, arr_usd, payment_streak, tenure_years) -> float:
    # Apply arr_mod, tenure_mod, streak_mod
    # Return clamped result
```

Export: `__all__ = ["PaymentRiskScorer", "compute_tone_modifier", "STAGE_TIME_FLOORS"]`
Also export `STAGE_TIME_FLOORS` (dict) — used by handlers and agent for escalation advancement logic.

Note: Real PaymentRiskScorer used in tests (not mocked) — pure Python, deterministic. Same pattern as CSMHealthScorer tests.
  </implementation>
</feature>

<verification>
`cd /Users/RAZER/Documents/projects/sales\ army && python -m pytest tests/test_collections_scorer.py -v` — all tests pass (GREEN phase confirmed).
</verification>

<success_criteria>
- RED phase: test file exists, tests fail (ImportError or assertion failures before implementation)
- GREEN phase: all tests pass with real scorer implementation
- REFACTOR phase: scorer code clean, no duplication, score_breakdown dict populated correctly
- Committed as 2-3 atomic commits: test(15-02), feat(15-02), optional refactor(15-02)
</success_criteria>

<output>
After completion, create `.planning/phases/15-collections-agent/15-02-SUMMARY.md`
</output>
