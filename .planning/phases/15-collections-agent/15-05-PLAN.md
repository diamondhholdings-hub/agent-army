---
phase: 15-collections-agent
plan: 05
type: execute
wave: 4
depends_on: ["15-03", "15-04"]
files_modified:
  - src/app/agents/collections/agent.py
  - src/app/agents/collections/scheduler.py
autonomous: true

must_haves:
  truths:
    - "CollectionsAgent is a BaseAgent subclass with supervisor routing 5 task types to 5 handlers"
    - "CollectionsAgent raises ValueError for unknown task types (matching TAM/PM/CSM pattern)"
    - "CollectionsAgent holds csm_agent reference for reverse cross-agent collections→CSM risk notification"
    - "CollectionsScheduler has 2 cron jobs: daily AR scan at 6am, daily escalation check at 7am"
    - "CollectionsScheduler.start() returns False gracefully if APScheduler not installed"
    - "receive_collections_risk(account_id, risk_band) method on CollectionsAgent notifies CSM agent when risk is HIGH or CRITICAL"
  artifacts:
    - path: "src/app/agents/collections/agent.py"
      provides: "CollectionsAgent class"
      exports: ["CollectionsAgent"]
      min_lines: 120
    - path: "src/app/agents/collections/scheduler.py"
      provides: "CollectionsScheduler with 2 cron jobs"
      exports: ["CollectionsScheduler"]
      min_lines: 80
  key_links:
    - from: "src/app/agents/collections/agent.py"
      to: "src/app/agents/collections/handlers.py"
      via: "all 5 handlers called from _route_task"
      pattern: "handle_ar_aging_report|handle_payment_risk|handle_generate_collection|handle_run_escalation|handle_surface_payment"
    - from: "src/app/agents/collections/agent.py"
      to: "src/app/agents/customer_success/agent.py"
      via: "csm_agent.receive_collections_risk called when risk is HIGH or CRITICAL"
      pattern: "csm_agent.*receive_collections_risk|collections_risk"
---

<objective>
Build CollectionsAgent (BaseAgent subclass with supervisor routing) and CollectionsScheduler (2 daily cron jobs). The agent wires handlers to the supervisor framework; the scheduler drives automated AR scanning and escalation.

Purpose: Agent and scheduler are the runtime entry points — the supervisor dispatches tasks to the correct handler, and the scheduler drives autonomous daily workflows without human initiation.
Output: `src/app/agents/collections/agent.py` and `src/app/agents/collections/scheduler.py`.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md

@src/app/agents/collections/schemas.py
@src/app/agents/collections/handlers.py
@src/app/agents/collections/notion_adapter.py
@src/app/agents/customer_success/agent.py
@src/app/agents/customer_success/scheduler.py
@src/app/agents/base.py
@.planning/phases/15-collections-agent/15-03-SUMMARY.md
@.planning/phases/15-collections-agent/15-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CollectionsAgent with supervisor routing and CSM cross-agent dispatch</name>
  <files>src/app/agents/collections/agent.py</files>
  <action>
Create `src/app/agents/collections/agent.py` following the CustomerSuccessAgent pattern precisely.

Module docstring: "Collections Agent: BaseAgent subclass for AR tracking, payment risk, and collection message generation."

```python
from __future__ import annotations
import json
import re
from typing import Any
import structlog
from src.app.agents.base import AgentRegistration, BaseAgent
from src.app.agents.collections.prompt_builders import COLLECTIONS_SYSTEM_PROMPT
from src.app.agents.collections.schemas import CollectionsHandoffRequest
```

**CollectionsAgent(BaseAgent) class**:

Constructor signature:
```python
def __init__(
    self,
    registration: AgentRegistration,
    llm_service: object,
    notion_collections: object | None = None,
    gmail_service: object | None = None,
    chat_service: object | None = None,
    event_bus: object | None = None,
    scorer: object | None = None,
    csm_agent: object | None = None,  # For reverse cross-agent notification
) -> None:
```

Store all as self._<name>. Call super().__init__(registration, llm_service).

**Task routing** (same pattern as CSM `_handle_process_reply` or equivalent BaseAgent task dispatch):
Map `request_type` to handler:
```python
_TASK_HANDLERS = {
    "ar_aging_report": "handle_ar_aging_report",
    "payment_risk_assessment": "handle_payment_risk_assessment",
    "generate_collection_message": "handle_generate_collection_message",
    "run_escalation_check": "handle_run_escalation_check",
    "surface_payment_plan": "handle_surface_payment_plan",
}
```

Implement `async def _execute_task(self, task: dict) -> dict` (or match the BaseAgent dispatch method name by checking base.py):
1. Extract `request_type` from task (use `task.get("request_type")`)
2. If unknown: `raise ValueError(f"Unknown Collections task type: {request_type}")`
3. Lazy import handlers: `from src.app.agents.collections import handlers`
4. Call the mapped handler with `(task, self._llm_service, self._notion_collections, self._gmail_service, self._scorer)`
5. Return handler result

**receive_collections_risk(account_id: str, risk_band: Literal["GREEN","AMBER","RED","CRITICAL"]) -> None**:
Called by handlers.py after risk assessment when risk is RED or CRITICAL. If `self._csm_agent` is None, log warning and return. Otherwise, call `await self._csm_agent.update_collections_risk(account_id, risk_band)` (if that method exists) OR build a CSM task dict and dispatch: `await self._csm_agent.process_task({"task_type": "update_health_signal", "account_id": account_id, "signal": "collections_risk", "value": risk_band})`. Log the cross-agent notification.

**IMPORTANT**: Check how BaseAgent defines its task routing method by reading `src/app/agents/base.py` before writing agent.py. Use the exact same method signature the base class expects for task routing. Do NOT guess — read the base class first.

**CRITICAL**: Collections never calls send_email. All draft generation in handlers uses gmail_service.create_draft(). Agent docstring must state this explicitly.

Export: `__all__ = ["CollectionsAgent"]`
  </action>
  <verify>
Run: `cd /Users/RAZER/Documents/projects/sales\ army && python -c "from src.app.agents.collections.agent import CollectionsAgent; from src.app.agents.base import AgentRegistration; reg = AgentRegistration(agent_id='collections', name='Collections', capabilities=[]); agent = CollectionsAgent(registration=reg, llm_service=None); print('CollectionsAgent OK', type(agent).__mro__)"`
  </verify>
  <done>CollectionsAgent instantiates without error, is a BaseAgent subclass, constructor accepts all 8 args, class importable.</done>
</task>

<task type="auto">
  <name>Task 2: Create CollectionsScheduler with 2 daily cron jobs</name>
  <files>src/app/agents/collections/scheduler.py</files>
  <action>
Create `src/app/agents/collections/scheduler.py` following the CSMScheduler pattern exactly.

Module docstring: "Background scheduler for Collections Agent: daily AR scan and daily escalation check."

```python
from __future__ import annotations
from datetime import datetime, timezone
try:
    from apscheduler.schedulers.asyncio import AsyncIOScheduler
    from apscheduler.triggers.cron import CronTrigger
except ImportError:
    AsyncIOScheduler = None
    CronTrigger = None
import structlog
logger = structlog.get_logger(__name__)
```

**CollectionsScheduler class**:

Constructor:
```python
def __init__(
    self,
    collections_agent: object,
    notion_collections: object | None = None,
) -> None:
    self._agent = collections_agent
    self._notion = notion_collections
    self._scheduler: AsyncIOScheduler | None = None
```

**start() -> bool**:
If AsyncIOScheduler is None: `logger.warning("collections_scheduler.apscheduler_unavailable"); return False`
Create `self._scheduler = AsyncIOScheduler()`
Add 2 cron jobs:
1. Daily AR scan at 6:00 AM: `CronTrigger(hour=6, minute=0)` → `self._run_daily_ar_scan`
2. Daily escalation check at 7:00 AM: `CronTrigger(hour=7, minute=0)` → `self._run_daily_escalation_check`
Start scheduler, log "collections_scheduler.started", return True.
Wrap in try/except — on error: log warning, return False.

**stop() -> None**:
If `self._scheduler` is not None and scheduler is running: call `self._scheduler.shutdown(wait=False)`. Log "collections_scheduler.stopped".

**async _run_daily_ar_scan() -> None**:
If `self._notion` is None: `logger.warning("collections_scheduler.ar_scan_skipped", reason="notion_not_configured"); return`
Get all delinquent accounts: `accounts = await self._notion.get_all_delinquent_accounts()`
For each account, dispatch ar_aging_report task to `self._agent._execute_task({"request_type": "ar_aging_report", "account_id": account["account_id"]})`. Wrap each in try/except, log errors, continue on failure.
Log scan completion with account count.

**async _run_daily_escalation_check() -> None**:
If `self._notion` is None: `logger.warning("collections_scheduler.escalation_check_skipped", reason="notion_not_configured"); return`
Get all delinquent accounts. For each, dispatch run_escalation_check task: `await self._agent._execute_task({"request_type": "run_escalation_check", "account_id": account["account_id"]})`. Wrap each in try/except. Log completion.

Export: `__all__ = ["CollectionsScheduler"]`
  </action>
  <verify>
Run: `cd /Users/RAZER/Documents/projects/sales\ army && python -c "from src.app.agents.collections.scheduler import CollectionsScheduler; s = CollectionsScheduler(collections_agent=None, notion_collections=None); result = s.start(); print('start() returned:', result)"` — returns False (APScheduler likely installed but agent=None; or returns True if APScheduler works).

Also: `python -c "from src.app.agents.collections.scheduler import CollectionsScheduler; import inspect; assert inspect.iscoroutinefunction(CollectionsScheduler._run_daily_ar_scan); print('async jobs OK')"`
  </verify>
  <done>CollectionsScheduler importable, start() returns bool (True if APScheduler installed, False if not), both scheduled methods are async, stop() callable without error.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.app.agents.collections.agent import CollectionsAgent; from src.app.agents.collections.scheduler import CollectionsScheduler; print('both import OK')"` — no errors
2. `grep -n "create_draft\|send_email" src/app/agents/collections/agent.py` — send_email must not appear; create_draft may not appear in agent.py (only in handlers)
3. `grep -n "csm_agent\|receive_collections_risk\|collections_risk" src/app/agents/collections/agent.py` — cross-agent dispatch present
4. `grep -n "hour=6\|hour=7\|ar_scan\|escalation_check" src/app/agents/collections/scheduler.py` — both cron jobs present
</verification>

<success_criteria>
- CollectionsAgent is a BaseAgent subclass, 5 task types routed via _execute_task
- ValueError raised for unknown task types (matching TAM/PM/CSM pattern)
- csm_agent reference stored; receive_collections_risk dispatches to CSM when risk is RED/CRITICAL
- CollectionsScheduler wraps APScheduler with 2 cron jobs (6am AR scan, 7am escalation check)
- CollectionsScheduler.start() returns False gracefully if APScheduler unavailable
- Both scheduler jobs are async and fail-open per account
</success_criteria>

<output>
After completion, create `.planning/phases/15-collections-agent/15-05-SUMMARY.md`
</output>
