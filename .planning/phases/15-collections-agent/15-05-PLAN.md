---
phase: 15-collections-agent
plan: 05
type: execute
wave: 4
depends_on: ["15-03", "15-04"]
files_modified:
  - src/app/agents/collections/agent.py
  - src/app/agents/collections/scheduler.py
autonomous: true

must_haves:
  truths:
    - "CollectionsAgent is a BaseAgent subclass with supervisor routing 5 task types to 5 handlers"
    - "CollectionsAgent raises ValueError for unknown task types (matching TAM/PM/CSM pattern)"
    - "CollectionsAgent stores csm_agent as self._csm_agent for reverse cross-agent collections→CSM risk notification"
    - "CollectionsScheduler has 2 cron jobs: daily AR scan at 6am, daily escalation check at 7am"
    - "CollectionsScheduler.start() returns False gracefully if APScheduler not installed"
    - "_execute_task post-checks returned result's rag field after payment_risk_assessment and calls await self.receive_collections_risk(account_id, rag) directly when rag is RED or CRITICAL"
    - "receive_collections_risk(account_id, risk_band) dispatches to self._csm_agent when called; skips gracefully with log warning if self._csm_agent is None"
  artifacts:
    - path: "src/app/agents/collections/agent.py"
      provides: "CollectionsAgent class"
      exports: ["CollectionsAgent"]
      min_lines: 130
    - path: "src/app/agents/collections/scheduler.py"
      provides: "CollectionsScheduler with 2 cron jobs"
      exports: ["CollectionsScheduler"]
      min_lines: 80
  key_links:
    - from: "src/app/agents/collections/agent.py"
      to: "src/app/agents/collections/handlers.py"
      via: "all 5 handlers called from _execute_task"
      pattern: "handle_ar_aging_report|handle_payment_risk|handle_generate_collection|handle_run_escalation|handle_surface_payment"
    - from: "src/app/agents/collections/agent.py"
      to: "src/app/agents/customer_success/agent.py"
      via: "_execute_task reads result['rag'] after payment_risk_assessment, calls self.receive_collections_risk which dispatches to self._csm_agent"
      pattern: "receive_collections_risk|self\\._csm_agent"
    - from: "src/app/agents/collections/agent._execute_task"
      to: "src/app/agents/collections/agent.receive_collections_risk"
      via: "post-check of result['rag'] after payment_risk_assessment handler returns"
      pattern: "result.*rag.*receive_collections_risk|receive_collections_risk.*result"
---

<objective>
Build CollectionsAgent (BaseAgent subclass with supervisor routing) and CollectionsScheduler (2 daily cron jobs). The agent wires handlers to the supervisor framework; the scheduler drives automated AR scanning and escalation.

Purpose: Agent and scheduler are the runtime entry points — the supervisor dispatches tasks to the correct handler, and the scheduler drives autonomous daily workflows without human initiation. The agent is also the single owner of the csm_agent reference and the CSM risk notification path — handlers never touch csm_agent directly.
Output: `src/app/agents/collections/agent.py` and `src/app/agents/collections/scheduler.py`.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md

@src/app/agents/collections/schemas.py
@src/app/agents/collections/handlers.py
@src/app/agents/collections/notion_adapter.py
@src/app/agents/customer_success/agent.py
@src/app/agents/customer_success/scheduler.py
@src/app/agents/base.py
@.planning/phases/15-collections-agent/15-03-SUMMARY.md
@.planning/phases/15-collections-agent/15-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CollectionsAgent with supervisor routing and CSM cross-agent dispatch</name>
  <files>src/app/agents/collections/agent.py</files>
  <action>
Create `src/app/agents/collections/agent.py` following the CustomerSuccessAgent pattern precisely.

Module docstring: "Collections Agent: BaseAgent subclass for AR tracking, payment risk, and collection message generation. All draft creation uses gmail_service.create_draft() — never send_email()."

```python
from __future__ import annotations
import json
import re
from typing import Any, Literal
import structlog
from src.app.agents.base import AgentRegistration, BaseAgent
from src.app.agents.collections.prompt_builders import COLLECTIONS_SYSTEM_PROMPT
from src.app.agents.collections.schemas import CollectionsHandoffRequest
```

**CollectionsAgent(BaseAgent) class**:

Constructor signature:
```python
def __init__(
    self,
    registration: AgentRegistration,
    llm_service: object,
    notion_collections: object | None = None,
    gmail_service: object | None = None,
    chat_service: object | None = None,
    event_bus: object | None = None,
    scorer: object | None = None,
    csm_agent: object | None = None,  # For reverse cross-agent risk notification
) -> None:
```

Store all as self._<name>. Call super().__init__(registration, llm_service).
Store csm_agent as `self._csm_agent = csm_agent`.

**Task routing** (same pattern as CSM `_handle_process_reply` or equivalent BaseAgent task dispatch):
Map `request_type` to handler:
```python
_TASK_HANDLERS = {
    "ar_aging_report": "handle_ar_aging_report",
    "payment_risk_assessment": "handle_payment_risk_assessment",
    "generate_collection_message": "handle_generate_collection_message",
    "run_escalation_check": "handle_run_escalation_check",
    "surface_payment_plan": "handle_surface_payment_plan",
}
```

**IMPORTANT**: Check how BaseAgent defines its task routing method by reading `src/app/agents/base.py` before writing agent.py. Use the exact same method signature the base class expects for task routing. Do NOT guess — read the base class first.

Implement `async def _execute_task(self, task: dict) -> dict` (or match the BaseAgent dispatch method name):
1. Extract `request_type` from task (use `task.get("request_type")`)
2. If unknown: `raise ValueError(f"Unknown Collections task type: {request_type}")`
3. Lazy import handlers: `from src.app.agents.collections import handlers`
4. Call the mapped handler with `(task, self._llm_service, self._notion_collections, self._gmail_service, self._scorer)`
5. Store result in local variable `result`
6. **Post-check for payment_risk_assessment**: If `request_type == "payment_risk_assessment"` AND `isinstance(result, dict)` AND `result.get("rag") in ("RED", "CRITICAL")` AND `"error" not in result`:
   - `account_id = task.get("account_id", result.get("account_id", ""))`
   - `await self.receive_collections_risk(account_id, result["rag"])`
7. Return result

**receive_collections_risk(account_id: str, risk_band: Literal["GREEN","AMBER","RED","CRITICAL"]) -> None**:
This method is the single cross-agent notification path. Handlers never call csm_agent directly — this method is the only call site.

Implementation:
```python
async def receive_collections_risk(
    self,
    account_id: str,
    risk_band: Literal["GREEN", "AMBER", "RED", "CRITICAL"],
) -> None:
    """Notify CSM agent of collections risk for an account.

    Called by _execute_task after payment_risk_assessment produces RED or CRITICAL.
    GREEN and AMBER do not trigger CSM notification.
    """
    if risk_band not in ("RED", "CRITICAL"):
        return  # Only RED/CRITICAL escalates to CSM
    if self._csm_agent is None:
        self._logger.warning(
            "collections.csm_agent_not_configured",
            account_id=account_id,
            risk_band=risk_band,
        )
        return
    try:
        # Try direct method if CSM agent exposes receive_collections_risk
        if hasattr(self._csm_agent, "receive_collections_risk"):
            await self._csm_agent.receive_collections_risk(account_id, risk_band)
        else:
            # Fall back to task dispatch
            await self._csm_agent.process_task({
                "task_type": "update_health_signal",
                "account_id": account_id,
                "signal": "collections_risk",
                "value": risk_band,
            })
        self._logger.info(
            "collections.csm_risk_notified",
            account_id=account_id,
            risk_band=risk_band,
        )
    except Exception as exc:
        self._logger.warning(
            "collections.csm_notify_failed",
            account_id=account_id,
            error=str(exc),
        )
```

**CRITICAL**: Collections never calls send_email. All draft generation in handlers uses gmail_service.create_draft(). Agent docstring must state this explicitly.

Export: `__all__ = ["CollectionsAgent"]`
  </action>
  <verify>
Run: `cd /Users/RAZER/Documents/projects/sales\ army && python -c "from src.app.agents.collections.agent import CollectionsAgent; from src.app.agents.base import AgentRegistration; reg = AgentRegistration(agent_id='collections', name='Collections', capabilities=[]); agent = CollectionsAgent(registration=reg, llm_service=None); print('CollectionsAgent OK', type(agent).__mro__)"`

Also verify CSM notification path: `cd /Users/RAZER/Documents/projects/sales\ army && python -c "from src.app.agents.collections.agent import CollectionsAgent; import inspect; src = inspect.getsource(CollectionsAgent._execute_task); assert 'receive_collections_risk' in src; assert 'payment_risk_assessment' in src; print('CSM dispatch wired in _execute_task OK')"`
  </verify>
  <done>CollectionsAgent instantiates without error, is a BaseAgent subclass, constructor accepts all 8 args including csm_agent. _execute_task post-checks rag field after payment_risk_assessment and calls self.receive_collections_risk. receive_collections_risk skips gracefully when self._csm_agent is None.</done>
</task>

<task type="auto">
  <name>Task 2: Create CollectionsScheduler with 2 daily cron jobs</name>
  <files>src/app/agents/collections/scheduler.py</files>
  <action>
Create `src/app/agents/collections/scheduler.py` following the CSMScheduler pattern exactly.

Module docstring: "Background scheduler for Collections Agent: daily AR scan and daily escalation check."

```python
from __future__ import annotations
from datetime import datetime, timezone
try:
    from apscheduler.schedulers.asyncio import AsyncIOScheduler
    from apscheduler.triggers.cron import CronTrigger
except ImportError:
    AsyncIOScheduler = None
    CronTrigger = None
import structlog
logger = structlog.get_logger(__name__)
```

**CollectionsScheduler class**:

Constructor:
```python
def __init__(
    self,
    collections_agent: object,
    notion_collections: object | None = None,
) -> None:
    self._agent = collections_agent
    self._notion = notion_collections
    self._scheduler: AsyncIOScheduler | None = None
```

**start() -> bool**:
If AsyncIOScheduler is None: `logger.warning("collections_scheduler.apscheduler_unavailable"); return False`
Create `self._scheduler = AsyncIOScheduler()`
Add 2 cron jobs:
1. Daily AR scan at 6:00 AM: `CronTrigger(hour=6, minute=0)` → `self._run_daily_ar_scan`
2. Daily escalation check at 7:00 AM: `CronTrigger(hour=7, minute=0)` → `self._run_daily_escalation_check`
Start scheduler, log "collections_scheduler.started", return True.
Wrap in try/except — on error: log warning, return False.

**stop() -> None**:
If `self._scheduler` is not None and scheduler is running: call `self._scheduler.shutdown(wait=False)`. Log "collections_scheduler.stopped".

**async _run_daily_ar_scan() -> None**:
If `self._notion` is None: `logger.warning("collections_scheduler.ar_scan_skipped", reason="notion_not_configured"); return`
Get all delinquent accounts: `accounts = await self._notion.get_all_delinquent_accounts()`
For each account, dispatch ar_aging_report task to `self._agent._execute_task({"request_type": "ar_aging_report", "account_id": account["account_id"]})`. Wrap each in try/except, log errors, continue on failure.
Log scan completion with account count.

**async _run_daily_escalation_check() -> None**:
If `self._notion` is None: `logger.warning("collections_scheduler.escalation_check_skipped", reason="notion_not_configured"); return`
Get all delinquent accounts. For each, dispatch run_escalation_check task: `await self._agent._execute_task({"request_type": "run_escalation_check", "account_id": account["account_id"]})`. Wrap each in try/except. Log completion.

Export: `__all__ = ["CollectionsScheduler"]`
  </action>
  <verify>
Run: `cd /Users/RAZER/Documents/projects/sales\ army && python -c "from src.app.agents.collections.scheduler import CollectionsScheduler; s = CollectionsScheduler(collections_agent=None, notion_collections=None); result = s.start(); print('start() returned:', result)"` — returns False (APScheduler likely installed but agent=None; or returns True if APScheduler works).

Also: `python -c "from src.app.agents.collections.scheduler import CollectionsScheduler; import inspect; assert inspect.iscoroutinefunction(CollectionsScheduler._run_daily_ar_scan); print('async jobs OK')"`
  </verify>
  <done>CollectionsScheduler importable, start() returns bool (True if APScheduler installed, False if not), both scheduled methods are async, stop() callable without error.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.app.agents.collections.agent import CollectionsAgent; from src.app.agents.collections.scheduler import CollectionsScheduler; print('both import OK')"` — no errors
2. `grep -n "create_draft\|send_email" src/app/agents/collections/agent.py` — send_email must not appear; create_draft may not appear in agent.py (only in handlers)
3. `grep -n "receive_collections_risk\|self._csm_agent" src/app/agents/collections/agent.py` — cross-agent dispatch present in both _execute_task and receive_collections_risk
4. `grep -n "hour=6\|hour=7\|ar_scan\|escalation_check" src/app/agents/collections/scheduler.py` — both cron jobs present
5. `python -c "from src.app.agents.collections.agent import CollectionsAgent; import inspect; src = inspect.getsource(CollectionsAgent._execute_task); assert 'payment_risk_assessment' in src and 'receive_collections_risk' in src; print('post-check wiring OK')"`
</verification>

<success_criteria>
- CollectionsAgent is a BaseAgent subclass, 5 task types routed via _execute_task
- ValueError raised for unknown task types (matching TAM/PM/CSM pattern)
- self._csm_agent stored on agent; _execute_task post-checks result["rag"] after payment_risk_assessment and calls await self.receive_collections_risk(account_id, rag) directly
- receive_collections_risk only dispatches to CSM when risk_band is RED or CRITICAL; skips gracefully if self._csm_agent is None
- No csm_agent reference anywhere in handlers.py (agent is the sole owner of the CSM notification path)
- CollectionsScheduler wraps APScheduler with 2 cron jobs (6am AR scan, 7am escalation check)
- CollectionsScheduler.start() returns False gracefully if APScheduler unavailable
- Both scheduler jobs are async and fail-open per account
</success_criteria>

<output>
After completion, create `.planning/phases/15-collections-agent/15-05-SUMMARY.md`
</output>
