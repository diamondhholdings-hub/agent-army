---
phase: 15-collections-agent
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/agents/collections/__init__.py
  - src/app/agents/collections/schemas.py
autonomous: true

must_haves:
  truths:
    - "CollectionsAgent has typed Pydantic models for all domain concepts: AR aging, payment risk, escalation state, collection messages, and payment plans"
    - "PaymentRiskSignals captures the 4 scoring dimensions: days_overdue, payment_history_streak, total_outstanding_balance_usd, days_to_renewal"
    - "EscalationState tracks current_stage (0-5), stage_entered_at, last_message_sent_at, messages_unanswered, stage5_notified, and payment_received_at"
    - "CSMHealthSignals is extended with collections_risk field for cross-agent health integration"
    - "All Pydantic models have docstrings and correct field validators matching CSM/TAM patterns"
  artifacts:
    - path: "src/app/agents/collections/__init__.py"
      provides: "Package init exporting CollectionsAgent"
    - path: "src/app/agents/collections/schemas.py"
      provides: "10+ Pydantic models for collections domain"
      contains: "class ARAgingBucket"
      min_lines: 200
  key_links:
    - from: "src/app/agents/collections/schemas.py"
      to: "src/app/agents/customer_success/schemas.py"
      via: "collections_risk field added to CSMHealthSignals"
      pattern: "collections_risk.*Optional.*Literal.*GREEN.*AMBER.*RED.*CRITICAL"
---

<objective>
Define all Pydantic data models for the Collections Agent domain and extend CSMHealthSignals with the collections_risk integration field.

Purpose: Schemas are the foundation every other plan depends on — handlers, scorer, adapter, and agent all import from here. Getting types right first prevents cascading rework. The CSMHealthSignals extension enables the cross-agent integration path (Collections risk feeds into CSM health).
Output: `src/app/agents/collections/schemas.py` with 10+ models, `__init__.py` package stub, and modified `src/app/agents/customer_success/schemas.py` with `collections_risk` field.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/app/agents/customer_success/schemas.py
@src/app/agents/technical_account_manager/schemas.py
@.planning/phases/14-customer-success-agent/14-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create collections package and schemas.py with all domain models</name>
  <files>src/app/agents/collections/__init__.py
src/app/agents/collections/schemas.py</files>
  <action>
Create `src/app/agents/collections/__init__.py` as a minimal package stub (exports `CollectionsAgent` with lazy import comment, like other agent `__init__.py` files).

Create `src/app/agents/collections/schemas.py` with the following 11 Pydantic models — follow the CSM/TAM pattern (from __future__ import annotations, Optional, Literal, model_validator, Field, BaseModel):

1. **ARAgingBucket** — one aging period:
   - `bucket_label: Literal["0-30", "31-60", "61-90", "90+"]`
   - `invoice_count: int = Field(ge=0)`
   - `total_amount_usd: float = Field(ge=0.0)`
   - `oldest_invoice_date: date`
   - `oldest_invoice_number: str`

2. **ARAgingReport** — full AR picture per account:
   - `account_id: str`
   - `account_name: str`
   - `total_outstanding_usd: float = Field(ge=0.0)`
   - `buckets: list[ARAgingBucket]`
   - `oldest_invoice_number: str`
   - `oldest_invoice_amount_usd: float = Field(ge=0.0)`
   - `oldest_invoice_date: date`
   - `computed_at: datetime` (default_factory=lambda: datetime.now(timezone.utc))

3. **PaymentRiskSignals** — 4 scoring inputs:
   - `account_id: str`
   - `days_overdue: int = Field(ge=0)` (primary signal — strongest weight)
   - `payment_history_streak: int` (positive = consecutive on-time, negative = consecutive late; range -12 to +12)
   - `total_outstanding_balance_usd: float = Field(ge=0.0)`
   - `days_to_renewal: int = Field(ge=0)` (0 means renewal today or past due)
   - `arr_usd: float = Field(ge=0.0, default=0.0)` (for tone modifier only, not in risk score)
   - `tenure_years: float = Field(ge=0.0, default=0.0)` (for tone modifier only)

4. **PaymentRiskResult** — scorer output:
   - `account_id: str`
   - `score: float = Field(ge=0.0, le=100.0)` (higher = more risk, inverted from CSM)
   - `rag: Literal["GREEN", "AMBER", "RED", "CRITICAL"]`
   - `should_escalate: bool = False` — auto-computed via model_validator: True when score >= 60
   - `score_breakdown: dict[str, float] = Field(default_factory=dict)`
   - `narrative: str = ""` (filled by LLM handler, empty from scorer)
   - `computed_at: datetime` (default_factory)
   - model_validator(mode="after"): `self.should_escalate = self.score >= 60.0`

5. **EscalationStage** — int Literal alias:
   - `EscalationStage = Literal[0, 1, 2, 3, 4, 5]`  (0=not started, 5=human handoff terminal)

6. **EscalationState** — per-account escalation persistence:
   - `account_id: str`
   - `current_stage: int = Field(ge=0, le=5, default=0)`
   - `stage_entered_at: Optional[datetime] = None`
   - `last_message_sent_at: Optional[datetime] = None`
   - `messages_unanswered: int = Field(ge=0, default=0)`
   - `stage5_notified: bool = False`
   - `payment_received_at: Optional[datetime] = None` (set by rep marking payment in Notion; resets escalation)
   - `response_received_at: Optional[datetime] = None` (set by rep marking response received; resets messages_unanswered)

7. **CollectionMessageStage** — stage-specific message output:
   - `account_id: str`
   - `stage: int = Field(ge=1, le=5)`
   - `subject: str`
   - `body: str`
   - `tone_modifier: float` (the computed modifier value 0.6-1.4)
   - `references_invoice: str` (oldest invoice number referenced)
   - `references_balance_usd: float`
   - `gmail_draft_id: Optional[str] = None`
   - `generated_at: datetime` (default_factory)

8. **PaymentPlanOption** — one structured option:
   - `option_type: Literal["installment_schedule", "partial_payment", "pay_or_suspend"]`
   - `description: str`
   - `proposed_amounts: list[float]` (payment installments)
   - `proposed_dates: list[date]`
   - `total_usd: float`

9. **PaymentPlanOptions** — full payment plan surface result:
   - `account_id: str`
   - `total_outstanding_usd: float`
   - `options: list[PaymentPlanOption]`
   - `llm_rationale: str`
   - `notion_page_id: Optional[str] = None`
   - `gmail_draft_id: Optional[str] = None`
   - `generated_at: datetime` (default_factory)

10. **CollectionsHandoffRequest** — inter-agent handoff payload:
    - `request_type: Literal["ar_aging_report", "payment_risk_assessment", "generate_collection_message", "run_escalation_check", "surface_payment_plan"]`
    - `account_id: str`
    - `stage_override: Optional[int] = Field(default=None, ge=1, le=5)` (force a specific stage message)
    - `metadata: dict[str, Any] = Field(default_factory=dict)`

11. **CollectionsAlertResult** — result of a completed collections action:
    - `account_id: str`
    - `action_taken: str`
    - `stage_after: int = Field(ge=0, le=5)`
    - `draft_created: bool = False`
    - `notion_updated: bool = False`
    - `error: Optional[str] = None`
    - `completed_at: datetime` (default_factory)

Export `__all__` listing all 11 class names plus `EscalationStage`. Add module-level docstring matching CSM pattern.

Include imports: `from __future__ import annotations`, `from datetime import date, datetime, timezone`, `from typing import Any, Literal, Optional`, `from pydantic import BaseModel, Field, model_validator`.
  </action>
  <verify>
Run: `cd /Users/RAZER/Documents/projects/sales\ army && python -c "from src.app.agents.collections.schemas import ARAgingReport, PaymentRiskResult, EscalationState, CollectionMessageStage, PaymentPlanOptions, CollectionsHandoffRequest, CollectionsAlertResult; r = PaymentRiskResult(account_id='a1', score=65.0, rag='RED'); assert r.should_escalate is True; r2 = PaymentRiskResult(account_id='a2', score=25.0, rag='GREEN'); assert r2.should_escalate is False; print('schemas OK')"`
  </verify>
  <done>Import succeeds, PaymentRiskResult.should_escalate auto-computes correctly (score >= 60 → True), EscalationState fields all present including payment_received_at and response_received_at.</done>
</task>

<task type="auto">
  <name>Task 2: Add collections_risk field to CSMHealthSignals</name>
  <files>src/app/agents/customer_success/schemas.py</files>
  <action>
Edit `src/app/agents/customer_success/schemas.py` — add `collections_risk` field to `CSMHealthSignals`:

In the `CSMHealthSignals` class, after the `tam_health_rag` field (line ~67), add:
```python
collections_risk: Optional[Literal["GREEN", "AMBER", "RED", "CRITICAL"]] = None
```

Update the class docstring Attributes section to document the new field:
```
collections_risk: Collections agent's latest payment risk band for this
    account. CRITICAL/RED feeds into CSM composite health as a cap
    (CRITICAL: raw * 0.80, RED: raw * 0.90). None means not yet assessed.
```

Do NOT modify any other field or method. Do NOT change the model_validator, health scoring weights, or any other class in the file.

This field is intentionally Optional with None default — existing CSMHealthSignals usages pass without it, ensuring backward compatibility.
  </action>
  <verify>
Run: `cd /Users/RAZER/Documents/projects/sales\ army && python -c "from src.app.agents.customer_success.schemas import CSMHealthSignals; s = CSMHealthSignals(feature_adoption_rate=0.8, usage_trend='growing', stakeholder_engagement='high', invoice_payment_status='current', seats_utilization_rate=0.9); assert s.collections_risk is None; s2 = CSMHealthSignals(feature_adoption_rate=0.5, usage_trend='declining', stakeholder_engagement='low', invoice_payment_status='overdue_30', seats_utilization_rate=0.6, collections_risk='RED'); assert s2.collections_risk == 'RED'; print('CSMHealthSignals collections_risk OK')"`

Then run: `cd /Users/RAZER/Documents/projects/sales\ army && python -m pytest tests/test_csm_schemas.py tests/test_csm_health_scorer.py -q` — all existing CSM tests must still pass (field is Optional with None default, backward compatible).
  </verify>
  <done>CSMHealthSignals accepts collections_risk as Optional[Literal["GREEN","AMBER","RED","CRITICAL"]] with default None. All pre-existing CSM schema/scorer tests pass (backward compatible).</done>
</task>

</tasks>

<verification>
1. `python -c "from src.app.agents.collections import schemas; print(schemas.__all__)"` — lists all 11+ names
2. `python -m pytest tests/test_csm_schemas.py tests/test_csm_health_scorer.py -q` — all existing CSM tests pass
3. `grep -n "collections_risk" src/app/agents/customer_success/schemas.py` — field present in CSMHealthSignals
4. `python -c "from src.app.agents.collections.schemas import EscalationState; s = EscalationState(account_id='x'); assert s.current_stage == 0 and s.payment_received_at is None"` — EscalationState defaults correct
</verification>

<success_criteria>
- 11 Pydantic models + EscalationStage type alias in collections/schemas.py
- PaymentRiskResult.should_escalate auto-computed via model_validator (score >= 60)
- EscalationState includes payment_received_at and response_received_at fields
- CSMHealthSignals.collections_risk field added as Optional[Literal["GREEN","AMBER","RED","CRITICAL"]] = None
- All pre-existing CSM tests still pass (backward compatible)
- No new test failures introduced
</success_criteria>

<output>
After completion, create `.planning/phases/15-collections-agent/15-01-SUMMARY.md`
</output>
