---
phase: 15-collections-agent
plan: 06
type: execute
wave: 5
depends_on: ["15-05"]
files_modified:
  - src/app/main.py
  - src/app/agents/customer_success/health_scorer.py
autonomous: true

must_haves:
  truths:
    - "CollectionsAgent is wired in main.py lifespan between Phase 14 (CSM) and Phase 5 (Deals)"
    - "CollectionsScheduler is started and stored on app.state.col_scheduler with shutdown cleanup"
    - "app.state.collections is set to CollectionsAgent instance (or None on failure)"
    - "CSMHealthScorer applies collections_risk cap: CRITICAL → raw * 0.80, RED → raw * 0.90, before existing TAM cap"
    - "CustomerSuccessAgent receives collections_agent reference for potential reverse lookup"
    - "Collections wiring follows the same try/except pattern as all other agents in main.py"
  artifacts:
    - path: "src/app/main.py"
      provides: "Phase 15 Collections wiring block"
      contains: "phase15.collections_initialized"
      min_lines: 885
    - path: "src/app/agents/customer_success/health_scorer.py"
      provides: "Updated scorer with collections_risk cap logic"
      contains: "collections_risk"
  key_links:
    - from: "src/app/main.py"
      to: "src/app/agents/collections/agent.py"
      via: "CollectionsAgent instantiated in lifespan"
      pattern: "from src.app.agents.collections import CollectionsAgent"
    - from: "src/app/agents/customer_success/health_scorer.py"
      to: "src/app/agents/customer_success/schemas.py"
      via: "reads collections_risk from CSMHealthSignals before computing score"
      pattern: "collections_risk"
---

<objective>
Wire CollectionsAgent into the main.py application lifespan and extend CSMHealthScorer to apply the collections_risk correlation cap (CRITICAL → 0.80x, RED → 0.90x).

Purpose: Without main.py wiring, the agent is code that never runs. Without the health scorer update, the Collections→CSM integration path is incomplete. These two changes activate the full cross-agent integration.
Output: Phase 15 block in `src/app/main.py` and updated `src/app/agents/customer_success/health_scorer.py`.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md

@src/app/main.py
@src/app/agents/customer_success/health_scorer.py
@src/app/agents/customer_success/schemas.py
@src/app/agents/collections/agent.py
@src/app/agents/collections/scheduler.py
@.planning/phases/15-collections-agent/15-05-SUMMARY.md
@.planning/phases/14-customer-success-agent/14-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update CSMHealthScorer with collections_risk cap</name>
  <files>src/app/agents/customer_success/health_scorer.py</files>
  <action>
Edit `src/app/agents/customer_success/health_scorer.py` to apply a collections_risk correlation cap BEFORE the existing TAM cap.

Find the section in the `score()` method where the TAM correlation cap is applied (currently checks `tam_health_rag` and multiplies by 0.85 or 0.95). Add collections_risk cap logic BEFORE the TAM cap:

```python
# Collections risk cap (applied before TAM cap)
# CRITICAL → 0.80x (severe AR delinquency depresses health score significantly)
# RED → 0.90x (elevated payment risk reduces health score)
# AMBER/GREEN/None → no cap
if signals.collections_risk == "CRITICAL":
    raw = raw * 0.80
elif signals.collections_risk == "RED":
    raw = raw * 0.90
# Then apply existing TAM cap...
```

The application order: raw score → collections_risk cap → TAM cap → derive RAG.

Update the class docstring to mention the collections_risk cap in the list of applied caps. Update the module-level docstring to mention "and collections risk cap" in the description.

Do NOT change signal weights, thresholds, churn risk logic, or any other method. Only add the collections_risk cap lines.
  </action>
  <verify>
Run: `cd /Users/RAZER/Documents/projects/sales\ army && python -c "
from src.app.agents.customer_success.health_scorer import CSMHealthScorer
from src.app.agents.customer_success.schemas import CSMHealthSignals

scorer = CSMHealthScorer()

# Test without collections_risk (backward compat)
signals_no_col = CSMHealthSignals(
    feature_adoption_rate=0.8, usage_trend='growing', stakeholder_engagement='high',
    invoice_payment_status='current', seats_utilization_rate=0.9
)
result_no_col = scorer.score('acct1', signals_no_col)

# Test with CRITICAL collections_risk
signals_critical = CSMHealthSignals(
    feature_adoption_rate=0.8, usage_trend='growing', stakeholder_engagement='high',
    invoice_payment_status='current', seats_utilization_rate=0.9,
    collections_risk='CRITICAL'
)
result_critical = scorer.score('acct2', signals_critical)

# CRITICAL cap should reduce the score
assert result_critical.score <= result_no_col.score, f'{result_critical.score} should be <= {result_no_col.score}'
print(f'No collections: {result_no_col.score:.1f}, CRITICAL: {result_critical.score:.1f}')
print('collections_risk cap OK')
"`

Then run: `cd /Users/RAZER/Documents/projects/sales\ army && python -m pytest tests/test_csm_health_scorer.py -q` — all existing tests must pass.
  </verify>
  <done>CSMHealthScorer applies collections_risk CRITICAL cap (0.80x) and RED cap (0.90x) before TAM cap. All pre-existing health scorer tests pass. No regression.</done>
</task>

<task type="auto">
  <name>Task 2: Wire CollectionsAgent into main.py lifespan</name>
  <files>src/app/main.py</files>
  <action>
Edit `src/app/main.py` to add the Phase 15 Collections Agent wiring block.

Insert after the Phase 14 CSM block (after the `log.warning("phase14.customer_success_init_failed"...)` and `app.state.csm_scheduler = None` lines) and before Phase 5 deals wiring.

The new block follows the EXACT same try/except pattern as Phase 14:

```python
# -- Phase 15: Collections Agent -----------------------------------------------
_CollectionsAgentRegistration = type(
    "_CollectionsAgentRegistration",
    (AgentRegistration,),
    {},
)
try:
    from src.app.agents.collections.agent import CollectionsAgent
    from src.app.agents.collections.scheduler import CollectionsScheduler
    from src.app.agents.collections.scorer import PaymentRiskScorer

    col_registration = _CollectionsAgentRegistration(
        agent_id="collections_agent",
        name="Collections Agent",
        capabilities=[
            "ar_aging_report",
            "payment_risk_assessment",
            "generate_collection_message",
            "run_escalation_check",
            "surface_payment_plan",
        ],
    )

    # Get CSM agent for cross-agent integration (Collections notifies CSM of risk)
    csm_agent_ref = getattr(app.state, "customer_success", None)

    col_agent = CollectionsAgent(
        registration=col_registration,
        llm_service=llm_service,
        # notion_collections=None: NotionCollectionsAdapter requires
        # NOTION_COLLECTIONS_AR_DATABASE_ID, NOTION_COLLECTIONS_ESCALATION_DATABASE_ID,
        # and NOTION_COLLECTIONS_EVENTS_DATABASE_ID to be set in environment (via .env
        # or deployment secrets) before this can be initialized. Until those env vars
        # are present, the adapter remains None and the agent runs in degraded mode
        # (scheduler jobs will skip, handlers return fail-open responses).
        notion_collections=None,
        gmail_service=gmail_service if "gmail_service" in dir() else None,
        chat_service=None,
        event_bus=event_bus if "event_bus" in dir() else None,
        scorer=PaymentRiskScorer(),
        csm_agent=csm_agent_ref,
    )

    if agent_registry is not None:
        agent_registry.register(col_registration)
        col_registration._agent_instance = col_agent
    app.state.collections = col_agent

    col_scheduler = CollectionsScheduler(
        collections_agent=col_agent,
        # notion_collections=None: same env var requirement as above.
        # Set NOTION_COLLECTIONS_* env vars and reinitialize to activate
        # the daily AR scan (6am) and escalation check (7am) cron jobs.
        notion_collections=None,
    )
    col_scheduler_started = col_scheduler.start()
    if col_scheduler_started:
        app.state.col_scheduler = col_scheduler
        log.info("phase15.col_scheduler_started")
    else:
        log.warning("phase15.col_scheduler_not_started", reason="APScheduler unavailable or start failed")

    log.info("phase15.collections_initialized")
except Exception as exc:
    log.warning("phase15.collections_init_failed", error=str(exc))
    app.state.collections = None
    app.state.col_scheduler = None
```

In the SHUTDOWN section (where csm_scheduler is stopped), add Collections scheduler cleanup AFTER CSM cleanup:
```python
# Clean up Phase 15 Collections scheduler
col_scheduler_ref = getattr(app.state, "col_scheduler", None)
if col_scheduler_ref is not None:
    col_scheduler_ref.stop()
```

**IMPORTANT**: Read the actual main.py file carefully before editing. Find the exact line numbers for:
1. End of Phase 14 block (after `app.state.csm_scheduler = None`)
2. Start of Phase 5 deals block
3. End of shutdown section (after CSM scheduler stop)

Insert the Phase 15 block in the correct position. Do NOT disrupt any existing code.
  </action>
  <verify>
Run: `cd /Users/RAZER/Documents/projects/sales\ army && python -c "import ast; ast.parse(open('src/app/main.py').read()); print('main.py syntax OK')"` — confirms no syntax errors.

Then: `cd /Users/RAZER/Documents/projects/sales\ army && python -c "from src.app.main import app; print('main.py imports OK')"` — if this fails due to missing env, try: `python -c "import ast; ast.parse(open('src/app/main.py').read()); print('syntax OK')"` and `grep -n 'phase15\|collections_initialized' src/app/main.py`.
  </verify>
  <done>Phase 15 block exists in main.py after Phase 14 block. app.state.collections set on success. app.state.col_scheduler set if scheduler starts. Shutdown section stops col_scheduler. Comment in wiring block explains the env vars required to activate NotionCollectionsAdapter. No syntax errors in main.py.</done>
</task>

</tasks>

<verification>
1. `python -c "import ast; ast.parse(open('src/app/main.py').read()); print('main.py syntax OK')"` — no syntax errors
2. `grep -n "phase15\|collections_initialized\|col_scheduler" src/app/main.py` — wiring and shutdown entries present
3. `python -m pytest tests/test_csm_health_scorer.py -q` — all existing CSM scorer tests pass
4. `grep -n "collections_risk" src/app/agents/customer_success/health_scorer.py` — cap logic present
5. `grep -n "0.80\|0.90" src/app/agents/customer_success/health_scorer.py` — correct cap multipliers
6. `grep -n "NOTION_COLLECTIONS_\|notion_collections=None" src/app/main.py` — comment documenting env var activation path present
</verification>

<success_criteria>
- Phase 15 wiring block in main.py: try/except, agent registration, scheduler start, app.state.collections set
- CollectionsScheduler stopped in shutdown section alongside CSMScheduler
- CSMHealthScorer updated with collections_risk cap (CRITICAL → 0.80x, RED → 0.90x)
- Collections cap applied BEFORE TAM cap in scorer
- All existing CSM health scorer tests still pass
- main.py has no syntax errors after edit
- Phase 15 wiring comment documents that NOTION_COLLECTIONS_* env vars are required before NotionCollectionsAdapter can be activated (notion_collections=None until then)
</success_criteria>

<output>
After completion, create `.planning/phases/15-collections-agent/15-06-SUMMARY.md`
</output>
