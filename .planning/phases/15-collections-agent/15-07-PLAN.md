---
phase: 15-collections-agent
plan: 07
type: execute
wave: 6
depends_on: ["15-06"]
files_modified:
  - tests/test_collections_schemas.py
  - tests/test_collections_handlers.py
  - tests/test_collections_notion_adapter.py
  - tests/test_collections_wiring.py
  - tests/test_collections_csm_integration.py
autonomous: true

must_haves:
  truths:
    - "PaymentRiskResult.should_escalate auto-computation verified for both True (score>=60) and False (score<60) cases"
    - "EscalationState payment_received_at and response_received_at fields tested for None default and datetime assignment"
    - "All 5 handlers return dict with 'error' key when services are None (fail-open verified)"
    - "handle_run_escalation_check deterministic advancement logic tested: both conditions required (time_floor AND non_response)"
    - "Stage 5 advancement triggers two Gmail draft calls (rep notification AND finance team)"
    - "Stages 1-4 advancement triggers handle_generate_collection_message internally to produce a Gmail draft"
    - "CSMHealthSignals.collections_risk field tested: None default, accepts GREEN/AMBER/RED/CRITICAL"
    - "CSMHealthScorer collections_risk CRITICAL cap (0.80x) and RED cap (0.90x) verified numerically"
    - "Collections→CSM integration round-trip tested at AGENT level: _execute_task post-checks rag after payment_risk_assessment and calls receive_collections_risk"
    - "receive_collections_risk on CollectionsAgent dispatches to mock csm_agent for RED/CRITICAL; skips for GREEN/AMBER; skips gracefully when csm_agent=None"
    - "CollectionsAgent wired in main.py: app.state.collections is not None after lifespan start (with mocked services)"
  artifacts:
    - path: "tests/test_collections_schemas.py"
      provides: "Pydantic model validation tests"
      min_lines: 60
    - path: "tests/test_collections_handlers.py"
      provides: "Handler mock tests (None services)"
      min_lines: 90
    - path: "tests/test_collections_notion_adapter.py"
      provides: "Adapter method tests with mocked notion client"
      min_lines: 60
    - path: "tests/test_collections_wiring.py"
      provides: "main.py wiring verification (app.state.collections set)"
      min_lines: 40
    - path: "tests/test_collections_csm_integration.py"
      provides: "Collections→CSM round-trip integration test at agent level"
      min_lines: 50
  key_links:
    - from: "tests/test_collections_csm_integration.py"
      to: "src/app/agents/collections/agent.py"
      via: "CollectionsAgent._execute_task with mock csm_agent; verify receive_collections_risk called after payment_risk_assessment returns RED/CRITICAL"
      pattern: "receive_collections_risk|_execute_task|csm_agent"
    - from: "tests/test_collections_wiring.py"
      to: "src/app/main.py"
      via: "app.state.collections verified set after lifespan"
      pattern: "app.state.collections"
    - from: "tests/test_collections_handlers.py"
      to: "src/app/agents/collections/handlers.py"
      via: "test_run_escalation_check_stages_1_to_4_produce_draft verifies handle_generate_collection_message called internally after stage advancement"
      pattern: "handle_generate_collection_message|stage.*draft|draft.*stage"
---

<objective>
Write comprehensive tests for the Collections Agent: schemas validation, handler fail-open behavior, escalation state machine logic (including draft-on-advance for stages 1-4), Notion adapter mocking, main.py wiring verification, and Collections→CSM integration round-trip at the agent level.

Purpose: Tests validate all critical behaviors and integration paths. The escalation state machine, draft-on-advance logic, and cross-agent integration are the highest-risk components — tests prevent regression and confirm the entire phase works end-to-end.
Output: 5 test files covering the full phase.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md

@src/app/agents/collections/schemas.py
@src/app/agents/collections/handlers.py
@src/app/agents/collections/agent.py
@src/app/agents/collections/scheduler.py
@src/app/agents/collections/notion_adapter.py
@src/app/agents/customer_success/health_scorer.py
@src/app/agents/customer_success/schemas.py
@tests/test_csm_handlers.py
@tests/test_csm_expansion_dispatch.py
@tests/test_csm_wiring.py
@.planning/phases/15-collections-agent/15-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write schema tests, handler fail-open tests, and notion adapter tests</name>
  <files>tests/test_collections_schemas.py
tests/test_collections_handlers.py
tests/test_collections_notion_adapter.py</files>
  <action>
**tests/test_collections_schemas.py** (follow test_csm_schemas.py pattern):

Tests:
- `test_payment_risk_result_should_escalate_true`: score=65.0, rag="RED" → should_escalate is True
- `test_payment_risk_result_should_escalate_false`: score=25.0, rag="GREEN" → should_escalate is False
- `test_payment_risk_result_boundary`: score=60.0 → should_escalate is True (boundary inclusive)
- `test_payment_risk_result_score_59`: score=59.9 → should_escalate is False
- `test_escalation_state_defaults`: EscalationState(account_id="x") → current_stage=0, messages_unanswered=0, stage5_notified=False, payment_received_at=None, response_received_at=None
- `test_escalation_state_stage5`: EscalationState(account_id="x", current_stage=5, stage5_notified=True) → stage5_notified is True
- `test_ar_aging_report_construction`: Build ARAgingReport with 2 buckets, verify total_outstanding_usd sums correctly
- `test_payment_plan_options`: Build PaymentPlanOptions with 3 options, verify option_type Literal validates correctly
- `test_collections_handoff_request_literals`: Verify all 5 request_type values are valid
- `test_csm_health_signals_collections_risk_none`: CSMHealthSignals without collections_risk → collections_risk is None (backward compat)
- `test_csm_health_signals_collections_risk_critical`: CSMHealthSignals with collections_risk="CRITICAL" → accepted correctly

**tests/test_collections_handlers.py** (follow test_csm_handlers.py pattern — all services None):

Tests (use `pytest.mark.asyncio` and real scorer instance from PaymentRiskScorer()):
- `test_ar_aging_report_no_notion_returns_safe_dict`: handle_ar_aging_report({'account_id': 'a1'}, None, None, None, None) → returns dict with 'account_id' key (not raising)
- `test_payment_risk_assessment_with_signals`: handle_payment_risk_assessment with full signals dict and real scorer, None LLM → returns dict with 'error' key (LLM fails gracefully)
- `test_payment_risk_assessment_scorer_called`: With real PaymentRiskScorer, mock LLM that raises → result has 'error' field
- `test_payment_risk_assessment_no_csm_agent_in_signature`: Confirm handler signature does NOT include csm_agent — `import inspect; sig = inspect.signature(handle_payment_risk_assessment); assert 'csm_agent' not in sig.parameters`
- `test_generate_collection_message_stage_1_to_4`: For stages 1-4, with None services → returns dict (fail-open, no raise)
- `test_generate_collection_message_stage_5_not_generated`: Stage 5 is human handoff — test that handle_generate_collection_message with stage=5 returns an error dict (no message generated)
- `test_run_escalation_check_no_advancement_time_floor_not_met`: Create escalation state where stage_entered_at was 2 days ago (floor=7 days) → no advancement
- `test_run_escalation_check_advances_when_both_conditions_met`: stage_entered_at 15 days ago (floor=7 met), messages_unanswered=1 → stage should advance
- `test_run_escalation_check_no_advance_if_only_non_response`: messages_unanswered=1 but stage_entered_at=2 days ago → no advancement (time floor not met)
- `test_run_escalation_check_stages_1_to_4_produce_draft`: Stage advancing from 0→1 (both conditions met) → mock gmail_service receives create_draft call for the collection message. Use `unittest.mock.AsyncMock` for gmail_service. Verify that create_draft was called at least once (from the internal handle_generate_collection_message call, even if LLM returns error — draft creation attempt is made).
- `test_run_escalation_check_stage5_triggers_two_drafts`: Stage advancing to 5 → mock gmail_service.create_draft called twice (once for rep notification, once for finance team). Verify call count == 2.
- `test_surface_payment_plan_fail_open`: handle_surface_payment_plan with None services → returns dict with 'error' key (LLM fails gracefully)

**tests/test_collections_notion_adapter.py** (follow test_csm_notion_adapter.py pattern with AsyncMock):

Tests (use `unittest.mock.AsyncMock` and `MagicMock`):
- `test_get_ar_aging_empty`: Mock Notion client returning 0 results → returns ARAgingReport with empty buckets
- `test_get_ar_aging_buckets_correct`: Mock Notion client returning 3 invoices (30d, 65d, 95d) → correct buckets populated
- `test_get_escalation_state_default_when_not_found`: Mock returns no results → EscalationState with stage=0
- `test_update_escalation_state_creates_when_not_found`: Mock returns no existing record → client.pages.create called
- `test_create_payment_plan_page_returns_page_id`: Mock create returns page with id → adapter returns UUID string
- `test_log_collection_event_append_only`: Mock creates page → client.pages.create called, client.pages.update NOT called
  </action>
  <verify>
Run: `cd /Users/RAZER/Documents/projects/sales\ army && python -m pytest tests/test_collections_schemas.py tests/test_collections_handlers.py tests/test_collections_notion_adapter.py -v 2>&1 | tail -30`
  </verify>
  <done>All schema tests pass. Handler fail-open tests pass, including stage advancement draft tests and stage 5 two-draft test. Notion adapter mock tests pass. No test failures. pytest reports no errors.</done>
</task>

<task type="auto">
  <name>Task 2: Write wiring test and Collections→CSM integration round-trip test</name>
  <files>tests/test_collections_wiring.py
tests/test_collections_csm_integration.py</files>
  <action>
**tests/test_collections_wiring.py** (follow test_csm_wiring.py pattern):

Tests:
- `test_collections_agent_is_base_agent_subclass`: `from src.app.agents.base import BaseAgent; from src.app.agents.collections.agent import CollectionsAgent; assert issubclass(CollectionsAgent, BaseAgent)`
- `test_collections_scheduler_has_two_jobs`: Instantiate CollectionsScheduler with mocked agent; if APScheduler available, start() and verify 2 jobs added; else verify returns False
- `test_collections_agent_unknown_task_raises`: CollectionsAgent with registration and None llm, dispatch unknown task_type → ValueError raised (matching TAM/CSM pattern)
- `test_app_state_collections_set_on_lifespan`: Use `async with LifespanManager(app)` (or equivalent) and check `app.state.collections is not None` OR mock the import path so lifespan runs without real services — follow test_csm_wiring.py approach exactly for the lifespan test
- `test_collections_scheduler_importable`: `from src.app.agents.collections.scheduler import CollectionsScheduler; assert CollectionsScheduler is not None`
- `test_csm_health_scorer_collections_risk_cap_critical`: CSMHealthScorer().score("x", signals_with_critical_collections_risk) has lower score than same signals with collections_risk=None
- `test_csm_health_scorer_collections_risk_cap_red`: RED cap (0.90x) produces higher score than CRITICAL cap (0.80x) for same base signals

**tests/test_collections_csm_integration.py** (follow test_csm_expansion_dispatch.py pattern):

Tests — Collections→CSM reverse handoff at the AGENT level (not handler level):

- `test_receive_collections_risk_calls_csm_agent_red`: Create CollectionsAgent with mock csm_agent (AsyncMock). Call `await col_agent.receive_collections_risk("acct1", "RED")`. Verify csm_agent method was called with account_id and risk_band.

- `test_receive_collections_risk_calls_csm_agent_critical`: Same as above with "CRITICAL". Verify csm_agent method was called.

- `test_receive_collections_risk_skips_if_no_csm_agent`: CollectionsAgent with csm_agent=None. Call `await col_agent.receive_collections_risk("acct1", "RED")`. No exception raised (logs warning, continues).

- `test_receive_collections_risk_green_amber_skipped`: Call `await col_agent.receive_collections_risk("acct1", "GREEN")` and `await col_agent.receive_collections_risk("acct1", "AMBER")`. CSM agent method must NOT be called for either — verify call count == 0.

- `test_execute_task_payment_risk_red_triggers_csm_notification`: Mock handler that returns `{"account_id": "acct1", "rag": "RED", "score": 75.0}`. Create CollectionsAgent with mock csm_agent. Patch `src.app.agents.collections.handlers.handle_payment_risk_assessment` to return the mock result. Call `await col_agent._execute_task({"request_type": "payment_risk_assessment", "account_id": "acct1", ...})`. Verify csm_agent's notification method was called with "acct1" and "RED". This tests the full agent-level integration path: _execute_task → post-check result["rag"] → receive_collections_risk → csm_agent.

- `test_execute_task_payment_risk_green_no_csm_notification`: Same setup but mock handler returns `{"account_id": "acct1", "rag": "GREEN", "score": 10.0}`. Verify csm_agent's notification method was NOT called.

- `test_collections_risk_feeds_csm_health_score`: Build CSMHealthSignals with collections_risk="CRITICAL" and without. CSMHealthScorer().score produces lower score with CRITICAL (cap applied). Verify score reduction is approximately 20% (0.80x cap factor).

Use `pytest.mark.asyncio` for all async tests. Use `unittest.mock.AsyncMock` for csm_agent mock.
  </action>
  <verify>
Run: `cd /Users/RAZER/Documents/projects/sales\ army && python -m pytest tests/test_collections_wiring.py tests/test_collections_csm_integration.py -v 2>&1 | tail -30`

Then run the full Phase 15 test suite: `python -m pytest tests/test_collections_schemas.py tests/test_collections_handlers.py tests/test_collections_notion_adapter.py tests/test_collections_wiring.py tests/test_collections_csm_integration.py tests/test_csm_health_scorer.py tests/test_csm_schemas.py -q`
  </verify>
  <done>All wiring tests pass. All integration tests pass including agent-level CSM dispatch tests. Full phase test suite (including regression tests for CSM schemas and scorer) passes with no failures. Total test count reported by pytest.</done>
</task>

</tasks>

<verification>
Run full test suite: `cd /Users/RAZER/Documents/projects/sales\ army && python -m pytest tests/test_collections_schemas.py tests/test_collections_handlers.py tests/test_collections_notion_adapter.py tests/test_collections_wiring.py tests/test_collections_csm_integration.py tests/test_csm_health_scorer.py tests/test_csm_schemas.py -v 2>&1 | tail -40`

All assertions:
1. test_collections_schemas.py — 11+ tests pass
2. test_collections_handlers.py — 12+ tests pass (includes draft-on-advance and two-draft-stage5 tests)
3. test_collections_notion_adapter.py — 6+ tests pass
4. test_collections_wiring.py — 7+ tests pass
5. test_collections_csm_integration.py — 7+ tests pass (includes agent-level _execute_task → receive_collections_risk tests)
6. test_csm_health_scorer.py — all pre-existing tests pass (no regression)
7. test_csm_schemas.py — all pre-existing tests pass (no regression)
</verification>

<success_criteria>
- 5 test files created, total 43+ test cases
- PaymentRiskResult.should_escalate boundary conditions tested (60.0 is True, 59.9 is False)
- Escalation state machine logic tested: BOTH conditions required for advancement
- Stage 1-4 advancement test: handle_generate_collection_message called internally, gmail_service.create_draft invoked
- Stage 5 advancement triggers exactly 2 Gmail draft calls (rep + finance)
- Collections→CSM integration tested at AGENT level: _execute_task post-checks rag, calls receive_collections_risk for RED/CRITICAL
- receive_collections_risk dispatches to csm_agent for RED/CRITICAL; skips for GREEN/AMBER; skips gracefully if csm_agent=None
- CSMHealthScorer collections_risk cap verified numerically (0.80x for CRITICAL, 0.90x for RED)
- All pre-existing CSM tests pass (no regression from collections_risk addition)
- No test failures
</success_criteria>

<output>
After completion, create `.planning/phases/15-collections-agent/15-07-SUMMARY.md`
</output>
