---
phase: 04.2-qbs-methodology-integration
plan: 02
type: execute
wave: 2
depends_on: ["04.2-01"]
files_modified:
  - src/app/agents/sales/qbs/engine.py
  - src/app/agents/sales/qbs/pain_tracker.py
  - src/app/agents/sales/qbs/expansion.py
  - tests/test_qbs_engine.py
autonomous: true

must_haves:
  truths:
    - "QBS engine analyzes conversation context via LLM and returns a structured QBSQuestionRecommendation"
    - "QBS engine falls back to rule-based recommendation when LLM fails (fail-open pattern)"
    - "QBS engine uses 'fast' model for low-latency signal analysis (~500ms target)"
    - "Pain tracker loads and saves PainFunnelState from/to ConversationState.metadata['qbs']['pain_state']"
    - "Pain tracker enforces max 10 pain topics by evicting oldest (by last_probed_at)"
    - "Pain tracker updates pain depth and detects resistance signals"
    - "Expansion detector scans conversation text for new contact mentions via LLM"
    - "Expansion detector excludes known contacts from results"
    - "Expansion detector falls back gracefully on LLM failure (returns empty list)"
  artifacts:
    - path: "src/app/agents/sales/qbs/engine.py"
      provides: "QBSQuestionEngine class with analyze_and_recommend() and rule-based fallback"
      contains: "class QBSQuestionEngine"
      exports: ["QBSQuestionEngine"]
    - path: "src/app/agents/sales/qbs/pain_tracker.py"
      provides: "PainDepthTracker class for loading, updating, and saving pain funnel state in metadata"
      contains: "class PainDepthTracker"
      exports: ["PainDepthTracker"]
    - path: "src/app/agents/sales/qbs/expansion.py"
      provides: "AccountExpansionDetector class for detecting multi-threading opportunities"
      contains: "class AccountExpansionDetector"
      exports: ["AccountExpansionDetector"]
    - path: "tests/test_qbs_engine.py"
      provides: "Unit tests for QBS engine fallback, pain tracker state management, expansion detector"
  key_links:
    - from: "src/app/agents/sales/qbs/engine.py"
      to: "instructor.from_litellm"
      via: "Structured LLM extraction for QBS analysis"
      pattern: "instructor\\.from_litellm"
    - from: "src/app/agents/sales/qbs/engine.py"
      to: "src/app/agents/sales/qbs/schemas.py"
      via: "Uses QBSQuestionRecommendation as response_model"
      pattern: "response_model=QBSQuestionRecommendation"
    - from: "src/app/agents/sales/qbs/pain_tracker.py"
      to: "ConversationState.metadata"
      via: "Reads/writes pain state from metadata['qbs']['pain_state']"
      pattern: "metadata.*qbs.*pain_state"
    - from: "src/app/agents/sales/qbs/expansion.py"
      to: "instructor.from_litellm"
      via: "Structured extraction of contact mentions"
      pattern: "instructor\\.from_litellm"
---

<objective>
Build the three core QBS components: the Question Engine (adaptive signal-based question selection via LLM), the Pain Depth Tracker (pain funnel state management persisted in ConversationState metadata), and the Account Expansion Detector (multi-threading opportunity identification from conversation text).

Purpose: These are the functional components that make QBS work. The engine produces question recommendations, the tracker maintains pain state across interactions, and the detector identifies expansion opportunities. All three use the schemas and prompts from Plan 01.

Output: Three working service classes (`QBSQuestionEngine`, `PainDepthTracker`, `AccountExpansionDetector`) with comprehensive unit tests including fallback behavior.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 4.2 context and research
@.planning/phases/04.2-qbs-methodology-integration/04.2-CONTEXT.md
@.planning/phases/04.2-qbs-methodology-integration/04.2-RESEARCH.md

# Plan 01 summary (schemas and prompts this plan depends on)
@.planning/phases/04.2-qbs-methodology-integration/04.2-01-SUMMARY.md

# QBS schemas and prompts we depend on
@src/app/agents/sales/qbs/schemas.py
@src/app/agents/sales/qbs/prompts.py

# Existing patterns to follow
@src/app/agents/sales/qualification.py
@src/app/agents/sales/actions.py
@src/app/agents/sales/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: QBS Question Engine with signal-driven selection</name>
  <files>src/app/agents/sales/qbs/engine.py</files>
  <action>
Create `src/app/agents/sales/qbs/engine.py` implementing the QBSQuestionEngine class.

**Follow the QualificationExtractor pattern** from `qualification.py` for LLM integration (instructor.from_litellm, model resolution, fail-open error handling, structured logging).

**Class: QBSQuestionEngine**

```python
class QBSQuestionEngine:
    """Adaptive QBS question selection based on conversation signals.

    Analyzes conversation context through three sensing modes:
    1. Information gap sensing: What BANT/MEDDIC data is missing?
    2. Customer engagement signals: Where is the customer's energy?
    3. Natural conversation flow: What logically follows?

    Uses the 'fast' model for low-latency signal analysis.
    Falls back to rule-based recommendation on LLM failure.
    """
```

**Constructor:** `__init__(self, llm_service: object) -> None`
- Store `_llm_service` (typed as object to avoid import cycle, same as QualificationExtractor)

**Main method:** `async def analyze_and_recommend(self, conversation_state: ConversationState, latest_message: str, conversation_history: list[str] | None = None) -> QBSQuestionRecommendation`
1. Load pain state via `_load_pain_state(conversation_state)`
2. Build qualification gaps summary from `conversation_state.qualification` (check which BANT/MEDDIC fields are not identified)
3. Build conversation state summary string (deal_stage, interaction_count, persona)
4. Build pain state summary from loaded PainFunnelState
5. Call `build_qbs_analysis_prompt()` from qbs/prompts.py to get messages
6. Create instructor client: `instructor.from_litellm(litellm.acompletion)`
7. Resolve model via `_resolve_model("fast")` (same pattern as QualificationExtractor but uses "fast" model for low latency, per RESEARCH.md Pitfall 5)
8. Call `client.chat.completions.create(model=model, response_model=QBSQuestionRecommendation, messages=messages, max_tokens=512, temperature=0.3, max_retries=2)`
9. Log recommendation via structlog
10. Return recommendation
11. On ANY exception: log warning, return `_fallback_recommendation(conversation_state, pain_state)`

**Fallback method:** `def _fallback_recommendation(self, state: ConversationState, pain_state: PainFunnelState) -> QBSQuestionRecommendation`
Rule-based fallback matching NextActionEngine's `_rule_based_actions` pattern:
- If `interaction_count == 0`: Return PAIN_FUNNEL targeting "need" with calibrated_question delivery, generic opening question
- If pain_state.depth_level == NOT_EXPLORED: Return PAIN_FUNNEL targeting "pain" with label delivery
- If pain_state.depth_level == SURFACE: Return IMPACT targeting "metrics" with calibrated_question delivery
- If pain_state.depth_level == BUSINESS_IMPACT: Return SOLUTION targeting "decision_criteria" with calibrated_question delivery
- If pain_state.depth_level == EMOTIONAL: Return CONFIRMATION targeting "champion" with mirror delivery
- Default: Return PAIN_FUNNEL targeting "need" with calibrated_question delivery
- All fallback recommendations should have `engagement_signal=EngagementSignal.FACTUAL` and `should_probe_deeper=False`

**Helper methods:**
- `_load_pain_state(state: ConversationState) -> PainFunnelState`: Read from `state.metadata.get("qbs", {}).get("pain_state", {})`. Return `PainFunnelState(**data)` if data exists, else `PainFunnelState()`.
- `_resolve_model(model_name: str) -> str`: Same pattern as QualificationExtractor but resolves "fast" model name. Default fallback: `"anthropic/claude-sonnet-4-20250514"`.
- `_build_qualification_gaps(qualification: QualificationState) -> str`: Iterate BANT dimensions (budget, authority, need, timeline) and MEDDIC dimensions (metrics, economic_buyer, decision_criteria, decision_process, pain, champion). For each not-identified dimension, add to gaps list. Return comma-separated string.
- `_build_pain_summary(pain_state: PainFunnelState) -> str`: Format pain state into readable summary including depth_level, number of topics, whether resistance detected, probe count.
  </action>
  <verify>Run `python -c "from src.app.agents.sales.qbs.engine import QBSQuestionEngine; print('QBSQuestionEngine imported OK')"` -- should import without errors.</verify>
  <done>QBSQuestionEngine class is implemented with analyze_and_recommend() method, rule-based fallback for all pain depth levels, LLM-powered signal analysis via instructor, and helper methods for state loading and gap analysis. Uses 'fast' model for low-latency analysis.</done>
</task>

<task type="auto">
  <name>Task 2: Pain Depth Tracker and Account Expansion Detector</name>
  <files>src/app/agents/sales/qbs/pain_tracker.py, src/app/agents/sales/qbs/expansion.py</files>
  <action>
Create two files implementing pain funnel state management and expansion detection.

**pain_tracker.py -- PainDepthTracker class:**

```python
class PainDepthTracker:
    """Manages pain funnel state in ConversationState.metadata.

    Tracks pain topics, depth progression, engagement signals,
    and resistance detection across conversation turns.
    State persists in metadata['qbs']['pain_state'] JSON.
    """
```

Methods:

1. `load(state: ConversationState) -> PainFunnelState` (static or classmethod)
   - Read from `state.metadata.get("qbs", {}).get("pain_state", {})`
   - If data exists, return `PainFunnelState(**data)`
   - Else return `PainFunnelState()`

2. `save(state: ConversationState, pain_state: PainFunnelState) -> None` (static or classmethod)
   - Ensure `state.metadata.setdefault("qbs", {})`
   - Set `state.metadata["qbs"]["pain_state"] = pain_state.model_dump(mode="json")`
   - Does NOT call state_repository.save_state -- caller handles persistence

3. `update_from_recommendation(pain_state: PainFunnelState, recommendation: QBSQuestionRecommendation, interaction_count: int) -> PainFunnelState` (static method)
   - Update `pain_state.depth_level` if recommendation.pain_depth is deeper than current (NOT_EXPLORED < SURFACE < BUSINESS_IMPACT < EMOTIONAL)
   - If `recommendation.engagement_signal == EngagementSignal.EMOTIONAL_LANGUAGE`: set `emotional_recognition_detected = True`
   - If `recommendation.engagement_signal == EngagementSignal.HIGH_ENERGY`: increment `self_elaboration_count`
   - If `recommendation.engagement_signal == EngagementSignal.RESISTANT`: set `resistance_detected = True`
   - Update `last_probed_topic` and `probe_count_current_topic` based on recommendation question type and target
   - Return updated PainFunnelState

4. `add_pain_topic(pain_state: PainFunnelState, topic: str, depth: PainDepthLevel, evidence: str, interaction_count: int, business_impact: str | None = None, emotional_indicator: str | None = None) -> PainFunnelState` (static method)
   - Check if topic already exists (by topic string). If yes, update its depth, evidence (append with ' | '), and last_probed_at
   - If new topic, append to pain_topics
   - **Enforce max 10 topics** (RESEARCH.md Pitfall 6): if len > 10, remove the topic with oldest `last_probed_at`
   - Return updated PainFunnelState

5. `should_back_off(pain_state: PainFunnelState) -> bool` (static method)
   - Return True if `probe_count_current_topic >= 3 AND NOT pain_state.emotional_recognition_detected AND NOT (self_elaboration_count > 0 for current topic)`
   - Return True if `resistance_detected` is True
   - Per CONTEXT.md: "Not every customer goes deep on first conversation. Note the gap, revisit later when trust builds."

**expansion.py -- AccountExpansionDetector class:**

```python
class AccountExpansionDetector:
    """Detects account expansion opportunities from conversation text.

    Scans for natural mentions of other people, teams, or roles.
    Produces expansion recommendations with QBS/Voss approaches.
    Uses 'fast' model for low-latency extraction.
    """
```

**Constructor:** `__init__(self, llm_service: object) -> None`

**Main method:** `async def detect_expansion_triggers(self, conversation_text: str, existing_contacts: list[str], interaction_count: int = 0) -> list[ExpansionTrigger]`
1. Call `build_expansion_detection_prompt(conversation_text, existing_contacts)` from qbs/prompts.py
2. Create instructor client: `instructor.from_litellm(litellm.acompletion)`
3. Resolve model via `_resolve_model("fast")`
4. Call instructor with `response_model=ExpansionRecommendation`, max_tokens=512, temperature=0.2, max_retries=1
5. Apply urgency adjustment: if `interaction_count < 3`, override any "immediate" urgency to "next_conversation" (RESEARCH.md Pitfall 4: don't expand too early)
6. Return `result.triggers`
7. On ANY exception: log warning, return empty list (fail-open per RESEARCH.md anti-pattern guidance)

**Helper:** `_resolve_model(model_name: str) -> str` -- Same pattern as QBSQuestionEngine.

**State management:** `save_expansion_state(state: ConversationState, triggers: list[ExpansionTrigger]) -> None` (static method)
- Ensure `state.metadata.setdefault("qbs", {})`
- Merge new triggers with existing: `state.metadata["qbs"].setdefault("expansion", {"detected_contacts": []})`
- Append new trigger dicts to `detected_contacts` list
- Deduplicate by `mentioned_name_or_role`
- Keep only active (not yet contacted) triggers. Total list capped at 20 entries.

Finally, **update `src/app/agents/sales/qbs/__init__.py`** to add exports:
```python
from src.app.agents.sales.qbs.engine import QBSQuestionEngine
from src.app.agents.sales.qbs.expansion import AccountExpansionDetector
from src.app.agents.sales.qbs.pain_tracker import PainDepthTracker
```
  </action>
  <verify>Run `python -c "from src.app.agents.sales.qbs import QBSQuestionEngine, PainDepthTracker, AccountExpansionDetector; print('All QBS components imported OK')"` -- should import without errors.</verify>
  <done>PainDepthTracker manages pain funnel state in metadata with max 10 topics enforcement and back-off detection. AccountExpansionDetector scans conversations for contact mentions with urgency adjustment for early interactions. Both follow established patterns (fail-open, structured logging, instructor).</done>
</task>

<task type="auto">
  <name>Task 3: Unit tests for QBS engine, pain tracker, and expansion detector</name>
  <files>tests/test_qbs_engine.py</files>
  <action>
Create `tests/test_qbs_engine.py` with comprehensive unit tests.

**QBS Engine Fallback Tests:**
- Test `_fallback_recommendation` with interaction_count=0 returns PAIN_FUNNEL targeting "need"
- Test `_fallback_recommendation` with NOT_EXPLORED pain returns PAIN_FUNNEL
- Test `_fallback_recommendation` with SURFACE pain returns IMPACT
- Test `_fallback_recommendation` with BUSINESS_IMPACT pain returns SOLUTION
- Test `_fallback_recommendation` with EMOTIONAL pain returns CONFIRMATION
- Test `_load_pain_state` with empty metadata returns default PainFunnelState
- Test `_load_pain_state` with existing metadata returns populated PainFunnelState
- Test `_build_qualification_gaps` with fully identified state returns empty string
- Test `_build_qualification_gaps` with partial state lists missing dimensions

**Pain Tracker Tests:**
- Test `PainDepthTracker.load` with empty metadata
- Test `PainDepthTracker.load` with populated metadata
- Test `PainDepthTracker.save` writes to metadata["qbs"]["pain_state"]
- Test `PainDepthTracker.save` preserves other metadata keys
- Test `update_from_recommendation` advances depth (SURFACE -> BUSINESS_IMPACT but NOT BUSINESS_IMPACT -> SURFACE)
- Test `update_from_recommendation` detects emotional recognition
- Test `update_from_recommendation` increments self-elaboration count
- Test `update_from_recommendation` detects resistance
- Test `add_pain_topic` adds new topic
- Test `add_pain_topic` updates existing topic (same topic string)
- Test `add_pain_topic` enforces max 10 topics (evicts oldest by last_probed_at)
- Test `add_pain_topic` appends evidence with ' | ' separator
- Test `should_back_off` returns True after 3 probes without elaboration
- Test `should_back_off` returns True when resistance detected
- Test `should_back_off` returns False when self_elaboration_count > 0

**Expansion Detector Tests:**
- Test `save_expansion_state` with new triggers
- Test `save_expansion_state` deduplicates by mentioned_name_or_role
- Test `save_expansion_state` caps at 20 entries
- Test urgency adjustment: interaction_count < 3 overrides "immediate" to "next_conversation"

Use the existing ConversationState from schemas.py to build test fixtures. No mocking of LLM calls needed -- test the fallback, state management, and pure functions. The LLM-dependent paths (analyze_and_recommend, detect_expansion_triggers) can be tested via integration tests in Plan 03.

Follow existing test patterns from tests/test_sales_state.py.
  </action>
  <verify>Run `python -m pytest tests/test_qbs_engine.py -v` -- all tests should pass.</verify>
  <done>All QBS engine, pain tracker, and expansion detector unit tests pass. Fallback logic covers all pain depth levels. Pain tracker enforces max 10 topics and back-off rules. Expansion state management deduplicates and caps entries.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.app.agents.sales.qbs import QBSQuestionEngine, PainDepthTracker, AccountExpansionDetector"` -- all components importable
2. `python -m pytest tests/test_qbs_engine.py -v` -- all unit tests pass
3. `python -m pytest tests/test_qbs_schemas.py tests/test_qbs_engine.py -v` -- both test files pass together
4. No regressions: `python -m pytest tests/ -x -q` -- full test suite passes
</verification>

<success_criteria>
- QBSQuestionEngine.analyze_and_recommend() returns QBSQuestionRecommendation from LLM or fallback
- Rule-based fallback covers all 5 pain depth levels with appropriate question types
- PainDepthTracker persists pain state in ConversationState.metadata["qbs"]["pain_state"]
- Pain topic limit enforced at 10 (oldest evicted by last_probed_at)
- Back-off detection prevents over-probing (3 probes without elaboration or resistance)
- AccountExpansionDetector returns expansion triggers from conversation text
- Early-interaction urgency override prevents premature expansion (interaction_count < 3)
- All components fail-open on LLM errors
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04.2-qbs-methodology-integration/04.2-02-SUMMARY.md`
</output>
