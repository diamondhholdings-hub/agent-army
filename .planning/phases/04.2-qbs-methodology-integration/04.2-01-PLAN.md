---
phase: 04.2-qbs-methodology-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/agents/sales/qbs/__init__.py
  - src/app/agents/sales/qbs/schemas.py
  - src/app/agents/sales/qbs/prompts.py
  - tests/test_qbs_schemas.py
autonomous: true

must_haves:
  truths:
    - "QBS question types (pain_funnel, impact, solution, confirmation) are defined as structured enums"
    - "Pain depth levels (surface, business_impact, emotional, not_explored) track funnel progression"
    - "QBS recommendation model captures question_type + meddic_bant_target + voss_delivery as a blended triple"
    - "Pain funnel state model stores pain topics with depth, evidence, and business impact per topic"
    - "Expansion trigger model captures mentioned contact with context and recommended approach"
    - "QBS methodology prompt defines elite salesperson principles and question type guidance"
    - "QBS analysis prompt template produces instructor-compatible messages for signal detection"
  artifacts:
    - path: "src/app/agents/sales/qbs/__init__.py"
      provides: "Module exports for QBS subpackage"
    - path: "src/app/agents/sales/qbs/schemas.py"
      provides: "QBS Pydantic models: QBSQuestionType, PainDepthLevel, EngagementSignal, QBSQuestionRecommendation, PainTopic, PainFunnelState, ExpansionTrigger, ExpansionRecommendation"
      contains: "class QBSQuestionRecommendation"
    - path: "src/app/agents/sales/qbs/prompts.py"
      provides: "QBS_METHODOLOGY_PROMPT, QBS_ANALYSIS_SYSTEM_PROMPT, build_qbs_analysis_prompt, build_qbs_prompt_section, build_expansion_detection_prompt"
      contains: "QBS_METHODOLOGY_PROMPT"
    - path: "tests/test_qbs_schemas.py"
      provides: "Unit tests for QBS schema validation and prompt template generation"
  key_links:
    - from: "src/app/agents/sales/qbs/schemas.py"
      to: "pydantic.BaseModel"
      via: "Pydantic model definitions"
      pattern: "class.*BaseModel"
    - from: "src/app/agents/sales/qbs/prompts.py"
      to: "src/app/agents/sales/qbs/schemas.py"
      via: "Import QBS types for prompt section builder"
      pattern: "from.*qbs.schemas import"
---

<objective>
Create the foundational QBS data models and prompt templates that all other QBS components depend on.

Purpose: Establishes the type system (question types, pain depth levels, engagement signals, recommendation structures) and prompt content (QBS methodology instructions, signal analysis prompts, expansion detection prompts) that the QBS Question Engine, Pain Tracker, and Expansion Detector will use. This is the schema + prompt layer -- no LLM calls or business logic yet.

Output: `src/app/agents/sales/qbs/` submodule with schemas.py and prompts.py, plus unit tests validating model construction and prompt template generation.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 4.2 context and research
@.planning/phases/04.2-qbs-methodology-integration/04.2-CONTEXT.md
@.planning/phases/04.2-qbs-methodology-integration/04.2-RESEARCH.md

# Existing schemas and prompts we extend
@src/app/agents/sales/schemas.py
@src/app/agents/sales/prompts.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: QBS Pydantic schemas</name>
  <files>src/app/agents/sales/qbs/__init__.py, src/app/agents/sales/qbs/schemas.py</files>
  <action>
Create the `src/app/agents/sales/qbs/` submodule with `__init__.py` and `schemas.py`.

**schemas.py** -- Define these Pydantic models following the existing schemas.py patterns (BaseModel, Field, Enum):

1. **QBSQuestionType(str, Enum)** -- Four question categories per Thomas Freese's QBS framework:
   - `PAIN_FUNNEL = "pain_funnel"` -- Surface problems -> business impact -> emotional depth
   - `IMPACT = "impact"` -- Business consequences of identified pain
   - `SOLUTION = "solution"` -- Connect needs to product capabilities
   - `CONFIRMATION = "confirmation"` -- Validate understanding, build commitment

2. **PainDepthLevel(str, Enum)** -- Pain funnel exploration depth:
   - `NOT_EXPLORED = "not_explored"` -- Pain not yet explored
   - `SURFACE = "surface"` -- Problem identified at surface level
   - `BUSINESS_IMPACT = "business_impact"` -- Business cost/consequences articulated
   - `EMOTIONAL = "emotional"` -- Root cause / emotional driver reached

3. **EngagementSignal(str, Enum)** -- Customer engagement signals detected in conversation:
   - `HIGH_ENERGY = "high_energy"` -- Customer elaborating, volunteering info
   - `FACTUAL = "factual"` -- Customer responding but not deeply engaged
   - `RESISTANT = "resistant"` -- Customer deflecting, giving short answers
   - `TOPIC_SHIFT = "topic_shift"` -- Customer redirecting conversation
   - `EMOTIONAL_LANGUAGE = "emotional_language"` -- Customer using emotional terms

4. **QBSQuestionRecommendation(BaseModel)** -- Structured output from QBS engine (instructor response_model):
   - `question_type: QBSQuestionType`
   - `meddic_bant_target: str` -- Field(description="Which MEDDIC/BANT dimension this question targets, e.g. 'need', 'metrics', 'budget', 'champion'")
   - `voss_delivery: str` -- Field(description="Chris Voss technique: 'mirror', 'label', 'calibrated_question', 'accusation_audit'")
   - `suggested_question: str` -- Field(description="The blended question ready for natural use in conversation")
   - `rationale: str` -- Field(description="Why this question type, target, and delivery were chosen given conversation context")
   - `information_gaps: list[str]` -- Field(default_factory=list, description="BANT/MEDDIC qualification data still missing")
   - `engagement_signal: EngagementSignal` -- Field(description="Detected customer engagement level from latest message")
   - `pain_depth: PainDepthLevel` -- Field(description="Current depth of pain exploration for primary topic")
   - `should_probe_deeper: bool` -- Field(description="Whether to continue probing current topic vs move on")
   - `natural_stopping_signals: list[str]` -- Field(default_factory=list, description="Signals detected that suggest stopping current probe")

5. **PainTopic(BaseModel)** -- A specific pain point tracked through the funnel:
   - `topic: str` -- Brief description of the pain point
   - `depth: PainDepthLevel` -- Current exploration depth
   - `evidence: str` -- Quote or summary from conversation
   - `business_impact: str | None = None` -- Articulated business cost
   - `emotional_indicator: str | None = None` -- Emotional language detected
   - `first_mentioned_at: int` -- Interaction number when first raised
   - `last_probed_at: int` -- Interaction number of most recent probe

6. **PainFunnelState(BaseModel)** -- Pain funnel progression across conversation turns:
   - `depth_level: PainDepthLevel = PainDepthLevel.NOT_EXPLORED` -- Overall deepest depth reached
   - `pain_topics: list[PainTopic] = Field(default_factory=list)` -- Tracked pain points (max 10, per RESEARCH.md Pitfall 6)
   - `emotional_recognition_detected: bool = False` -- Whether customer showed emotional weight
   - `self_elaboration_count: int = 0` -- Times customer volunteered detail unprompted
   - `resistance_detected: bool = False` -- Whether customer showed resistance to probing
   - `revisit_later: list[str] = Field(default_factory=list)` -- Pain gaps to revisit in future conversations
   - `last_probed_topic: str | None = None` -- Most recently probed topic
   - `probe_count_current_topic: int = 0` -- Probes on current topic (back off after 2-3 without elaboration per CONTEXT.md)

7. **ExpansionTrigger(BaseModel)** -- A detected mention of another person in conversation:
   - `mentioned_name_or_role: str` -- "my boss", "the finance team", "Sarah from procurement"
   - `context_quote: str` -- The sentence where they were mentioned
   - `relationship_to_contact: str` -- Inferred relationship to current contact
   - `expansion_approach: str` -- Recommended QBS approach for engagement
   - `urgency: str` -- "immediate", "next_conversation", "after_trust_builds"

8. **ExpansionRecommendation(BaseModel)** -- Expansion recommendation for instructor extraction:
   - `triggers: list[ExpansionTrigger] = Field(default_factory=list)` -- Detected expansion triggers
   - `primary_recommendation: str = ""` -- Best next step for multi-threading
   - `resistance_assessment: str = ""` -- Likelihood of resistance and handling approach
   - `political_context: str = ""` -- How this fits political mapping context

**__init__.py** -- Export all schema classes:
```python
from src.app.agents.sales.qbs.schemas import (
    EngagementSignal,
    ExpansionRecommendation,
    ExpansionTrigger,
    PainDepthLevel,
    PainFunnelState,
    PainTopic,
    QBSQuestionRecommendation,
    QBSQuestionType,
)
```
Leave engine/tracker/expansion imports for Plans 02 and 03 (those files don't exist yet).
  </action>
  <verify>Run `python -c "from src.app.agents.sales.qbs.schemas import QBSQuestionType, PainDepthLevel, EngagementSignal, QBSQuestionRecommendation, PainTopic, PainFunnelState, ExpansionTrigger, ExpansionRecommendation; print('All QBS schemas imported OK')"` -- should print success message without errors.</verify>
  <done>All 8 QBS schema classes are importable and properly typed. QBSQuestionRecommendation captures the blended triple (question_type + meddic_bant_target + voss_delivery). PainFunnelState tracks pain depth progression. ExpansionTrigger captures contact mentions with approach recommendations.</done>
</task>

<task type="auto">
  <name>Task 2: QBS prompt templates and section builders</name>
  <files>src/app/agents/sales/qbs/prompts.py</files>
  <action>
Create `src/app/agents/sales/qbs/prompts.py` with QBS-specific prompt constants and builder functions.

**Constants:**

1. **QBS_METHODOLOGY_PROMPT: str** -- Core QBS methodology instructions injected into system prompts. Content must include:
   - QBS question type definitions (pain funnel, impact, solution, confirmation) with examples
   - Elite salesperson principles from CONTEXT.md: listen actively, follow energy, natural flow, gap sensing, context over checklist
   - Methodology blending guidance: each question blends QBS structure + MEDDIC/BANT targeting + Voss empathy delivery
   - Anti-interrogation rule: "Never ask more than one probing question per message. Balance every question with acknowledgment, value, or insight."
   - Give-value-first rule: "Before asking a QBS question, lead with value: mirror what they said, label an emotion, or share a relevant insight."
   - Pain funnel pacing: "Respect the customer's pace. Not every customer goes deep in one conversation. Note gaps for later."

2. **QBS_ANALYSIS_SYSTEM_PROMPT: str** -- System prompt for the QBS engine's signal analysis LLM call (used with instructor). Content must instruct the LLM to:
   - Analyze conversation through three sensing modes: information gap sensing, engagement signal detection, natural conversation flow
   - Select the optimal QBS question type based on signals (NOT following a fixed sequence)
   - Identify the MEDDIC/BANT dimension with the biggest gap that this question should target
   - Choose the Chris Voss delivery technique that fits the engagement level
   - Generate a natural, blended question (not template-stitched)
   - Assess pain depth level and whether to probe deeper
   - Detect natural stopping signals (customer shifting focus, giving complete answers, showing resistance)

3. **EXPANSION_DETECTION_PROMPT: str** -- System prompt for expansion trigger detection. Content must instruct the LLM to:
   - Scan for mentions of other people, teams, or roles in conversation text
   - For each mention: extract name/role, context quote, relationship, and recommended QBS approach
   - Assess urgency (immediate vs next_conversation vs after_trust_builds based on trust level)
   - Only flag NEW contacts not already in the known contacts list

**Builder Functions:**

4. **build_qbs_analysis_prompt(conversation_state_summary: str, latest_message: str, conversation_history_summary: str, pain_state_summary: str, qualification_gaps: str) -> list[dict[str, str]]** -- Build messages list for the QBS engine's instructor call. Uses QBS_ANALYSIS_SYSTEM_PROMPT as system message. User message includes all the context summaries. Return format: `[{"role": "system", "content": ...}, {"role": "user", "content": ...}]`.

5. **build_qbs_prompt_section(qbs_recommendation: QBSQuestionRecommendation, pain_state: PainFunnelState, expansion_triggers: list[ExpansionTrigger]) -> str** -- Build the dynamic QBS guidance section that gets injected into the main system prompt (called from agent.py before build_system_prompt or between prompt sections). This should format:
   - Primary question type and target
   - Suggested question text
   - Information gaps to fill
   - Pain funnel guidance (depth, whether to probe, when to back off)
   - Account expansion opportunities (if any triggers detected)
   Must be formatted as a string section, NOT as messages list -- it's injected INTO the system prompt.

6. **build_expansion_detection_prompt(conversation_text: str, existing_contacts: list[str]) -> list[dict[str, str]]** -- Build messages list for expansion trigger detection. Uses EXPANSION_DETECTION_PROMPT as system message with existing contacts appended. User message is the conversation text.

Important: Import QBS schema types from `src.app.agents.sales.qbs.schemas` (the sibling module). Do NOT import from the parent `prompts.py` -- this module is self-contained for its prompt content.
  </action>
  <verify>Run `python -c "from src.app.agents.sales.qbs.prompts import QBS_METHODOLOGY_PROMPT, QBS_ANALYSIS_SYSTEM_PROMPT, EXPANSION_DETECTION_PROMPT, build_qbs_analysis_prompt, build_qbs_prompt_section, build_expansion_detection_prompt; print(f'QBS_METHODOLOGY_PROMPT: {len(QBS_METHODOLOGY_PROMPT)} chars'); print(f'Functions imported OK')"` -- should print prompt lengths and success.</verify>
  <done>QBS_METHODOLOGY_PROMPT contains elite salesperson principles and question type guidance. QBS_ANALYSIS_SYSTEM_PROMPT provides signal detection instructions for instructor calls. Builder functions produce properly formatted messages and prompt sections. All constants include anti-interrogation, give-value-first, and pain pacing rules from CONTEXT.md.</done>
</task>

<task type="auto">
  <name>Task 3: Unit tests for QBS schemas and prompts</name>
  <files>tests/test_qbs_schemas.py</files>
  <action>
Create `tests/test_qbs_schemas.py` with unit tests covering:

1. **Schema Construction Tests:**
   - Test QBSQuestionRecommendation can be constructed with all required fields and validates correctly
   - Test PainFunnelState defaults (NOT_EXPLORED depth, empty lists, zero counts)
   - Test PainTopic with evidence and business impact
   - Test ExpansionTrigger with all urgency levels
   - Test ExpansionRecommendation with multiple triggers
   - Test enum values for QBSQuestionType, PainDepthLevel, EngagementSignal

2. **Prompt Template Tests:**
   - Test QBS_METHODOLOGY_PROMPT contains key phrases: "pain funnel", "impact", "solution", "confirmation", "never ask more than one", "give value first"
   - Test QBS_ANALYSIS_SYSTEM_PROMPT contains "information gap", "engagement signal", "natural conversation flow"
   - Test build_qbs_analysis_prompt returns list of 2 dicts with "role" and "content" keys, system role first
   - Test build_qbs_prompt_section returns a string containing the question type and suggested question
   - Test build_qbs_prompt_section with empty expansion triggers does NOT include expansion section
   - Test build_qbs_prompt_section with expansion triggers includes expansion guidance
   - Test build_expansion_detection_prompt includes existing contacts in system message

3. **Edge Cases:**
   - Test PainFunnelState with max 10 pain_topics (boundary)
   - Test QBSQuestionRecommendation with empty information_gaps and natural_stopping_signals
   - Test build_qbs_prompt_section with NOT_EXPLORED pain state (early conversation)

Use pytest. Follow existing test patterns from tests/test_sales_state.py and tests/test_sales_integration.py. No fixtures needed beyond basic model construction.
  </action>
  <verify>Run `python -m pytest tests/test_qbs_schemas.py -v` -- all tests should pass.</verify>
  <done>All QBS schema and prompt tests pass. Schema construction is validated. Prompt templates contain required methodology content. Builder functions produce correctly structured output.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.app.agents.sales.qbs import QBSQuestionType, PainDepthLevel, QBSQuestionRecommendation, PainFunnelState, ExpansionTrigger"` -- all exports work
2. `python -c "from src.app.agents.sales.qbs.prompts import QBS_METHODOLOGY_PROMPT, build_qbs_prompt_section"` -- prompt module loads
3. `python -m pytest tests/test_qbs_schemas.py -v` -- all unit tests pass
4. No import errors in existing test suite: `python -m pytest tests/ -x --ignore=tests/test_qbs_schemas.py -q` (existing tests unaffected)
</verification>

<success_criteria>
- QBS submodule (`src/app/agents/sales/qbs/`) exists with __init__.py, schemas.py, prompts.py
- All 8 schema classes are importable and properly typed with Pydantic validation
- QBSQuestionRecommendation captures the blended triple: question_type + meddic_bant_target + voss_delivery
- PainFunnelState tracks progressive pain depth with max 10 topics
- QBS_METHODOLOGY_PROMPT encodes elite salesperson principles and anti-interrogation rules
- Builder functions produce correctly formatted prompt structures
- All unit tests pass
- Existing test suite unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/04.2-qbs-methodology-integration/04.2-01-SUMMARY.md`
</output>
