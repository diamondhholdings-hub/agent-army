---
phase: 04.2-qbs-methodology-integration
plan: 03
type: execute
wave: 3
depends_on: ["04.2-01", "04.2-02"]
files_modified:
  - src/app/agents/sales/prompts.py
  - src/app/agents/sales/agent.py
  - src/app/agents/sales/qbs/__init__.py
  - tests/test_qbs_integration.py
autonomous: true

must_haves:
  truths:
    - "build_system_prompt() accepts optional qbs_guidance parameter and injects QBS methodology + dynamic guidance into the system prompt"
    - "build_email_prompt() and build_chat_prompt() pass qbs_guidance through to build_system_prompt()"
    - "SalesAgent._compile_sales_context() runs QBS engine analysis and stores recommendation in context"
    - "SalesAgent._handle_send_email() and _handle_send_chat() inject QBS guidance into prompts before LLM call"
    - "SalesAgent._handle_process_reply() updates pain state and detects expansion triggers from customer reply"
    - "SalesAgent._format_context_summary() includes pain state and expansion opportunities when present"
    - "QBS outcomes are recorded via OutcomeTracker with action_type='qbs_{question_type}' for learning integration"
    - "Integration tests verify end-to-end QBS flow: engine -> prompt injection -> state persistence"
  artifacts:
    - path: "src/app/agents/sales/prompts.py"
      provides: "Updated build_system_prompt with QBS injection, updated build_email_prompt and build_chat_prompt with qbs_guidance passthrough"
      contains: "QBS_METHODOLOGY_PROMPT"
    - path: "src/app/agents/sales/agent.py"
      provides: "Updated SalesAgent with QBS engine integration in _compile_sales_context, handlers, and context formatting"
      contains: "QBSQuestionEngine"
    - path: "tests/test_qbs_integration.py"
      provides: "Integration tests for QBS flow through SalesAgent pipeline"
  key_links:
    - from: "src/app/agents/sales/agent.py"
      to: "src/app/agents/sales/qbs/engine.py"
      via: "QBSQuestionEngine injected in constructor and called in _compile_sales_context"
      pattern: "qbs_engine.*analyze_and_recommend"
    - from: "src/app/agents/sales/agent.py"
      to: "src/app/agents/sales/qbs/pain_tracker.py"
      via: "PainDepthTracker.update_from_recommendation called in _handle_process_reply"
      pattern: "PainDepthTracker"
    - from: "src/app/agents/sales/agent.py"
      to: "src/app/agents/sales/qbs/expansion.py"
      via: "AccountExpansionDetector.detect_expansion_triggers called in _handle_process_reply"
      pattern: "expansion_detector.*detect"
    - from: "src/app/agents/sales/prompts.py"
      to: "src/app/agents/sales/qbs/prompts.py"
      via: "QBS_METHODOLOGY_PROMPT imported and injected into system prompt"
      pattern: "QBS_METHODOLOGY_PROMPT"
    - from: "src/app/agents/sales/agent.py"
      to: "src/app/agents/sales/qbs/prompts.py"
      via: "build_qbs_prompt_section called to generate dynamic QBS guidance"
      pattern: "build_qbs_prompt_section"
---

<objective>
Wire QBS methodology into the existing SalesAgent pipeline so every generated message naturally incorporates QBS-guided questioning, pain tracking persists across interactions, and expansion opportunities are detected from customer replies.

Purpose: This is where QBS becomes functional. Plans 01 and 02 built the components; this plan connects them to the live agent flow. After this plan, the SalesAgent generates QBS-enriched messages, tracks pain depth progressively, detects expansion opportunities, and records outcomes for learning.

Output: Updated `prompts.py` with QBS prompt injection, updated `agent.py` with QBS engine integration, and integration tests proving the full pipeline works.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 4.2 context and research
@.planning/phases/04.2-qbs-methodology-integration/04.2-CONTEXT.md
@.planning/phases/04.2-qbs-methodology-integration/04.2-RESEARCH.md

# Prior plan summaries (schemas, prompts, engine, tracker, detector)
@.planning/phases/04.2-qbs-methodology-integration/04.2-01-SUMMARY.md
@.planning/phases/04.2-qbs-methodology-integration/04.2-02-SUMMARY.md

# Files being modified
@src/app/agents/sales/prompts.py
@src/app/agents/sales/agent.py
@src/app/agents/sales/schemas.py

# QBS components created in prior plans
@src/app/agents/sales/qbs/__init__.py
@src/app/agents/sales/qbs/schemas.py
@src/app/agents/sales/qbs/prompts.py
@src/app/agents/sales/qbs/engine.py
@src/app/agents/sales/qbs/pain_tracker.py
@src/app/agents/sales/qbs/expansion.py

# Learning integration target
@src/app/learning/outcomes.py

# Existing test patterns
@tests/test_sales_integration.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update prompts.py with QBS methodology injection</name>
  <files>src/app/agents/sales/prompts.py</files>
  <action>
Modify the existing `src/app/agents/sales/prompts.py` to integrate QBS methodology into the prompt system. All changes are additive -- existing behavior is preserved with QBS layered on top.

**Step 1: Add QBS import at module top:**
```python
from src.app.agents.sales.qbs.prompts import QBS_METHODOLOGY_PROMPT
```

**Step 2: Update `build_system_prompt()` signature and body:**

Change the function signature to accept an optional `qbs_guidance` parameter:
```python
def build_system_prompt(
    persona: PersonaType,
    channel: Channel,
    deal_stage: DealStage,
    qbs_guidance: str | None = None,
) -> str:
```

In the return statement, insert `QBS_METHODOLOGY_PROMPT` after `VOSS_METHODOLOGY_PROMPT` (the base QBS methodology is always included), and inject the dynamic `qbs_guidance` if provided:

The current return is:
```python
return (
    "You are a top 1% enterprise sales professional. ..."
    f"{VOSS_METHODOLOGY_PROMPT}\n\n"
    f"{persona_section}\n\n"
    ...
)
```

Change to:
```python
parts = [
    "You are a top 1% enterprise sales professional. You combine deep "
    "product expertise with masterful relationship-building skills. You "
    "are executing the ESW (Enterprise Sales Workflow) methodology, which "
    "integrates BANT and MEDDIC qualification frameworks with Chris Voss's "
    "tactical empathy approach from 'Never Split the Difference.'",
    VOSS_METHODOLOGY_PROMPT,
    QBS_METHODOLOGY_PROMPT,
]

if qbs_guidance:
    parts.append(qbs_guidance)

parts.extend([
    persona_section,
    channel_section,
    f"**Current Deal Stage:**\n{stage_guidance}",
    rules_section,
])

return "\n\n".join(parts)
```

**Step 3: Update `build_email_prompt()` to accept and pass `qbs_guidance`:**

Add parameter `qbs_guidance: str | None = None` to signature. Pass it through to `build_system_prompt()`:
```python
system_prompt = build_system_prompt(persona, Channel.EMAIL, deal_stage, qbs_guidance=qbs_guidance)
```

Also update the user message to mention QBS:
```python
"Compose the email following the system prompt guidelines. "
"Ensure the tone, formality, and style match the persona and "
"deal stage. Apply Chris Voss methodology and QBS questioning throughout."
```

**Step 4: Update `build_chat_prompt()` similarly:**

Add parameter `qbs_guidance: str | None = None`. Pass to `build_system_prompt()`. Update user message to mention QBS.

**Step 5: Update module docstring** to mention QBS methodology export.

Important: The `build_qualification_extraction_prompt` and `build_next_action_prompt` functions remain UNCHANGED -- they serve different purposes (extraction, not generation).
  </action>
  <verify>Run `python -c "from src.app.agents.sales.prompts import build_system_prompt; prompt = build_system_prompt('manager', 'email', 'discovery'); assert 'QBS' in prompt or 'Question Based Selling' in prompt or 'pain funnel' in prompt.lower(); print('QBS injected into system prompt OK')"` -- verifies QBS methodology is in the base system prompt. Also run `python -c "from src.app.agents.sales.prompts import build_system_prompt; prompt = build_system_prompt('manager', 'email', 'discovery', qbs_guidance='TEST_QBS_SECTION'); assert 'TEST_QBS_SECTION' in prompt; print('Dynamic QBS guidance injection OK')"` -- verifies dynamic guidance passthrough.</verify>
  <done>build_system_prompt includes QBS_METHODOLOGY_PROMPT always and accepts optional qbs_guidance for dynamic injection. build_email_prompt and build_chat_prompt pass qbs_guidance through. Existing callers that don't pass qbs_guidance continue to work unchanged (backward compatible via None default).</done>
</task>

<task type="auto">
  <name>Task 2: Integrate QBS engine into SalesAgent pipeline</name>
  <files>src/app/agents/sales/agent.py, src/app/agents/sales/qbs/__init__.py</files>
  <action>
Modify `src/app/agents/sales/agent.py` to integrate QBS engine, pain tracking, and expansion detection into the agent's execution flow.

**Step 1: Add imports:**
```python
from src.app.agents.sales.qbs import (
    QBSQuestionEngine,
    AccountExpansionDetector,
    PainDepthTracker,
)
from src.app.agents.sales.qbs.prompts import build_qbs_prompt_section
```

**Step 2: Update SalesAgent.__init__() to accept optional QBS components:**

Add three optional parameters with None defaults (backward compatible):
```python
def __init__(
    self,
    registration: AgentRegistration,
    llm_service: object,
    gmail_service: object,
    chat_service: object,
    rag_pipeline: object,
    conversation_store: object,
    session_manager: object,
    state_repository: ConversationStateRepository,
    qualification_extractor: QualificationExtractor,
    action_engine: NextActionEngine,
    escalation_manager: EscalationManager,
    qbs_engine: QBSQuestionEngine | None = None,
    expansion_detector: AccountExpansionDetector | None = None,
) -> None:
```
Store as `self._qbs_engine` and `self._expansion_detector`. (PainDepthTracker is stateless/static, no instance needed.)

**Step 3: Add `_get_qbs_guidance()` private method:**

```python
async def _get_qbs_guidance(
    self, sales_ctx: dict[str, Any]
) -> str | None:
    """Run QBS engine analysis and return dynamic prompt guidance.

    Returns None if QBS engine is not configured or analysis fails.
    """
    if self._qbs_engine is None:
        return None

    state: ConversationState = sales_ctx["conversation_state"]
    history = sales_ctx.get("conversation_history", [])

    try:
        # Get latest message context
        latest_msg = ""
        if history:
            latest_msg = str(history[0]) if history else ""

        recommendation = await self._qbs_engine.analyze_and_recommend(
            conversation_state=state,
            latest_message=latest_msg,
            conversation_history=[str(h) for h in history[:5]] if history else None,
        )

        # Load pain state and expansion triggers for prompt section
        pain_state = PainDepthTracker.load(state)
        expansion_triggers = []
        expansion_data = state.metadata.get("qbs", {}).get("expansion", {})
        if expansion_data.get("detected_contacts"):
            from src.app.agents.sales.qbs.schemas import ExpansionTrigger
            expansion_triggers = [
                ExpansionTrigger(**t) for t in expansion_data["detected_contacts"][:3]
            ]

        # Update pain state from recommendation
        updated_pain = PainDepthTracker.update_from_recommendation(
            pain_state, recommendation, state.interaction_count
        )
        PainDepthTracker.save(state, updated_pain)

        # Build the dynamic QBS guidance section
        return build_qbs_prompt_section(
            recommendation, updated_pain, expansion_triggers
        )
    except Exception as exc:
        logger.warning("qbs_guidance_failed", error=str(exc))
        return None
```

**Step 4: Update `_handle_send_email()` to inject QBS guidance:**

After `context_summary = self._format_context_summary(sales_ctx)`, add:
```python
# Get QBS guidance for prompt injection
qbs_guidance = await self._get_qbs_guidance(sales_ctx)
```

Update the `build_email_prompt` call to pass `qbs_guidance`:
```python
messages = build_email_prompt(
    persona=state.persona_type,
    deal_stage=state.deal_stage,
    context_summary=context_summary,
    task_description=task.get("description", "Send an outreach email"),
    qbs_guidance=qbs_guidance,
)
```

**Step 5: Update `_handle_send_chat()` similarly:**

Add `qbs_guidance = await self._get_qbs_guidance(sales_ctx)` and pass to `build_chat_prompt()`.

**Step 6: Update `_handle_process_reply()` to update QBS state:**

After qualification extraction and state update, add QBS processing:

```python
# Update QBS pain state from reply content
if self._qbs_engine is not None:
    try:
        qbs_recommendation = await self._qbs_engine.analyze_and_recommend(
            conversation_state=state,
            latest_message=reply_text,
        )
        pain_state = PainDepthTracker.load(state)
        updated_pain = PainDepthTracker.update_from_recommendation(
            pain_state, qbs_recommendation, state.interaction_count
        )
        PainDepthTracker.save(state, updated_pain)
    except Exception as exc:
        logger.warning("qbs_reply_analysis_failed", error=str(exc))

# Detect expansion triggers from reply
if self._expansion_detector is not None:
    try:
        existing_contacts = [state.contact_name, state.contact_email]
        expansion_triggers = await self._expansion_detector.detect_expansion_triggers(
            conversation_text=reply_text,
            existing_contacts=[c for c in existing_contacts if c],
            interaction_count=state.interaction_count,
        )
        if expansion_triggers:
            AccountExpansionDetector.save_expansion_state(state, expansion_triggers)
    except Exception as exc:
        logger.warning("qbs_expansion_detection_failed", error=str(exc))
```

Place this BEFORE the `await self._state_repository.save_state(state)` call so QBS metadata is persisted with the state save.

**Step 7: Update `_format_context_summary()` to include QBS state:**

After the existing parts list, add:

```python
# Add QBS pain state if present
qbs_data = state.metadata.get("qbs", {})
pain_data = qbs_data.get("pain_state", {})
if pain_data:
    pain_topics = pain_data.get("pain_topics", [])
    if pain_topics:
        topic_summaries = []
        for topic in pain_topics[:3]:  # Top 3 most recent
            summary = f"- {topic.get('topic', 'Unknown')} (depth: {topic.get('depth', 'unknown')})"
            if topic.get("business_impact"):
                summary += f" -- impact: {topic['business_impact']}"
            topic_summaries.append(summary)
        parts.append("\nIdentified Pain Points:\n" + "\n".join(topic_summaries))

# Add expansion opportunities if present
expansion_data = qbs_data.get("expansion", {})
detected = expansion_data.get("detected_contacts", [])
if detected:
    parts.append(
        f"\nExpansion Opportunities: {len(detected)} contact(s) "
        f"detected for multi-threading"
    )
```

**Step 8: Update module docstring** to mention QBS engine integration.
  </action>
  <verify>Run `python -c "from src.app.agents.sales.agent import SalesAgent; print('SalesAgent with QBS imports OK')"` -- verifies import chain works. Run `python -m pytest tests/test_sales_integration.py -v -x` -- existing integration tests still pass (backward compatible since QBS params default to None).</verify>
  <done>SalesAgent integrates QBSQuestionEngine, PainDepthTracker, and AccountExpansionDetector. QBS guidance is injected into email/chat prompt generation. Reply processing updates pain state and detects expansion triggers. Context summary includes pain points and expansion opportunities. All changes are backward compatible (None defaults).</done>
</task>

<task type="auto">
  <name>Task 3: Integration tests for QBS pipeline</name>
  <files>tests/test_qbs_integration.py</files>
  <action>
Create `tests/test_qbs_integration.py` with integration tests verifying the full QBS pipeline.

Follow the existing patterns from `tests/test_sales_integration.py` (InMemoryStateRepository, mock services).

**Test Fixtures:**

Create a mock QBSQuestionEngine that returns predictable recommendations without LLM calls:
```python
class MockQBSEngine:
    """Mock QBS engine returning predictable recommendations."""

    async def analyze_and_recommend(self, conversation_state, latest_message, conversation_history=None):
        from src.app.agents.sales.qbs.schemas import (
            QBSQuestionRecommendation, QBSQuestionType, PainDepthLevel, EngagementSignal,
        )
        return QBSQuestionRecommendation(
            question_type=QBSQuestionType.PAIN_FUNNEL,
            meddic_bant_target="need",
            voss_delivery="calibrated_question",
            suggested_question="What challenges are you facing with your current approach?",
            rationale="First interaction discovery",
            engagement_signal=EngagementSignal.FACTUAL,
            pain_depth=PainDepthLevel.SURFACE,
            should_probe_deeper=True,
        )
```

Create a mock AccountExpansionDetector:
```python
class MockExpansionDetector:
    """Mock expansion detector returning predictable triggers."""

    async def detect_expansion_triggers(self, conversation_text, existing_contacts, interaction_count=0):
        from src.app.agents.sales.qbs.schemas import ExpansionTrigger
        if "boss" in conversation_text.lower() or "team" in conversation_text.lower():
            return [ExpansionTrigger(
                mentioned_name_or_role="their boss",
                context_quote="My boss mentioned this last week",
                relationship_to_contact="manager",
                expansion_approach="QBS value-based: understand their boss's priorities",
                urgency="next_conversation" if interaction_count < 3 else "immediate",
            )]
        return []

    @staticmethod
    def save_expansion_state(state, triggers):
        from src.app.agents.sales.qbs.expansion import AccountExpansionDetector
        AccountExpansionDetector.save_expansion_state(state, triggers)
```

**Integration Tests:**

1. **test_qbs_guidance_injected_in_email_prompt**: Create SalesAgent with MockQBSEngine. Call `_compile_sales_context()` then `_get_qbs_guidance()`. Verify the returned guidance string contains "pain_funnel" and "calibrated_question" and the suggested question.

2. **test_qbs_pain_state_persists_across_interactions**: Call `_handle_process_reply()` twice. After first call, load pain state from metadata and verify it was updated. After second call, verify pain state accumulated (not reset).

3. **test_qbs_expansion_detected_from_reply**: Call `_handle_process_reply()` with reply_text containing "My boss mentioned this last week". Verify expansion triggers saved in `state.metadata["qbs"]["expansion"]["detected_contacts"]`.

4. **test_qbs_no_expansion_without_mentions**: Call `_handle_process_reply()` with reply_text not mentioning anyone. Verify no expansion data in metadata.

5. **test_qbs_format_context_summary_includes_pain**: Create a ConversationState with pain topics in metadata. Call `_format_context_summary()`. Verify output contains "Identified Pain Points".

6. **test_qbs_format_context_summary_includes_expansion**: Create a ConversationState with expansion data in metadata. Call `_format_context_summary()`. Verify output contains "Expansion Opportunities".

7. **test_qbs_backward_compatible_without_engine**: Create SalesAgent without QBS engine (qbs_engine=None). Call `_get_qbs_guidance()`. Verify returns None. Existing email/chat flow works unchanged.

8. **test_prompt_includes_qbs_methodology**: Import `build_system_prompt` and call with default params. Verify result contains QBS methodology keywords (pain funnel, impact, solution, confirmation).

9. **test_prompt_includes_dynamic_qbs_guidance**: Call `build_system_prompt` with `qbs_guidance="Focus on IMPACT questions targeting metrics"`. Verify result contains that exact string.

Use `unittest.mock.AsyncMock` for gmail_service, chat_service, rag_pipeline, conversation_store, session_manager, and llm_service (return `{"content": "mock email response"}` for completion calls). Use `InMemoryStateRepository` from the existing test file if available, or create a simple dict-based one.
  </action>
  <verify>Run `python -m pytest tests/test_qbs_integration.py -v` -- all tests pass. Run `python -m pytest tests/ -x -q` -- full test suite passes with no regressions.</verify>
  <done>Integration tests verify: QBS guidance injected into prompts, pain state persists across interactions, expansion triggers detected from replies, context summary includes QBS data, backward compatibility without QBS engine, and prompt templates include QBS methodology.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.app.agents.sales.prompts import build_system_prompt; p = build_system_prompt('manager', 'email', 'discovery'); assert 'pain funnel' in p.lower() or 'Pain Funnel' in p; print('QBS in base prompt OK')"` -- QBS methodology always present
2. `python -c "from src.app.agents.sales.prompts import build_system_prompt; p = build_system_prompt('manager', 'email', 'discovery', qbs_guidance='CUSTOM'); assert 'CUSTOM' in p; print('Dynamic injection OK')"` -- dynamic guidance works
3. `python -c "from src.app.agents.sales.agent import SalesAgent; print('Agent imports OK')"` -- no import errors
4. `python -m pytest tests/test_qbs_integration.py -v` -- all integration tests pass
5. `python -m pytest tests/ -x -q` -- full test suite passes, no regressions
</verification>

<success_criteria>
- build_system_prompt always includes QBS_METHODOLOGY_PROMPT (base QBS guidance)
- build_system_prompt accepts and injects dynamic qbs_guidance parameter
- build_email_prompt and build_chat_prompt pass qbs_guidance through
- SalesAgent integrates QBSQuestionEngine, PainDepthTracker, AccountExpansionDetector
- Email/chat handlers inject QBS guidance before LLM message generation
- Reply handler updates pain state and detects expansion triggers
- Context summary includes pain points and expansion opportunities
- All changes are backward compatible (None defaults on new params)
- Integration tests cover full QBS pipeline flow
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04.2-qbs-methodology-integration/04.2-03-SUMMARY.md`
</output>
