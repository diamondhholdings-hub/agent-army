---
phase: 09-production-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/v1/health.py
  - src/app/config.py
  - src/app/main.py
autonomous: true

must_haves:
  truths:
    - "Health endpoint /health/ready returns status for all 4 dependencies: database, redis, qdrant, litellm"
    - "Settings class accepts NOTION_TOKEN, NOTION_DATABASE_ID, and GOOGLE_SERVICE_ACCOUNT_JSON_B64 from environment"
    - "NotionAdapter is instantiated and wired into the CRM SyncEngine when NOTION_TOKEN is configured"
    - "GSuiteAuthManager can load credentials from base64-encoded JSON (not just file path)"
  artifacts:
    - path: "src/app/api/v1/health.py"
      provides: "Extended health check with Qdrant and LiteLLM"
      contains: "qdrant"
    - path: "src/app/config.py"
      provides: "Production-ready settings with Notion and base64 credential support"
      contains: "NOTION_TOKEN"
    - path: "src/app/main.py"
      provides: "NotionAdapter wired into SyncEngine"
      contains: "NotionAdapter"
  key_links:
    - from: "src/app/api/v1/health.py"
      to: "src/knowledge/config.py"
      via: "KnowledgeBaseConfig import for Qdrant URL"
      pattern: "KnowledgeBaseConfig"
    - from: "src/app/main.py"
      to: "src/app/deals/crm/notion.py"
      via: "NotionAdapter instantiation when NOTION_TOKEN is set"
      pattern: "NotionAdapter.*token"
    - from: "src/app/main.py"
      to: "src/app/config.py"
      via: "get_service_account_path for GSuite credential loading"
      pattern: "get_service_account_path"
---

<objective>
Fix production-blocking code gaps: extend the health endpoint to check Qdrant and LiteLLM, add missing Notion and base64 service account env vars to Settings, and wire the NotionAdapter into the CRM SyncEngine in main.py.

Purpose: Without these code fixes, SC2 (health endpoint), SC3 (Google Workspace), and SC4 (Notion CRM) cannot pass in production. These are foundational changes that the CI/CD pipeline and deployment depend on.

Output: Three updated Python files ready for production deployment.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-production-deployment/09-RESEARCH.md

@src/app/api/v1/health.py
@src/app/config.py
@src/app/main.py
@src/knowledge/config.py
@src/app/deals/crm/notion.py
@src/app/services/gsuite/auth.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend health endpoint with Qdrant and LiteLLM checks</name>
  <files>src/app/api/v1/health.py</files>
  <action>
Add Qdrant and LiteLLM connectivity checks to the `_check_dependencies()` function. The current function only checks database and redis.

**Qdrant check:**
- Import `KnowledgeBaseConfig` from `src.knowledge.config`
- If `config.qdrant_url` is set (production mode), create a `QdrantClient(url=config.qdrant_url, api_key=config.qdrant_api_key)` and call `client.get_collections()` as a connectivity test. Close the client after.
- If `qdrant_url` is not set, report status as `"local"` (dev mode, not a real remote check).
- On exception, set `checks["qdrant"] = "error"` with error detail.
- Use synchronous `QdrantClient` (not async) since the existing health checks use sync patterns wrapped in async functions.

**LiteLLM check:**
- Get settings via `get_settings()`
- Check that at least one LLM provider key is configured (`settings.ANTHROPIC_API_KEY` or `settings.OPENAI_API_KEY`)
- If keys exist, set `checks["litellm"] = "ok"`
- If no keys, set `checks["litellm"] = "no_keys"`
- On exception, set `checks["litellm"] = "error"` with error detail.

**Update `all_healthy` logic** in both `readiness_check` and `startup_check`:
- Change from checking only database + redis to checking all 4: `all(v == "ok" for k, v in checks.items() if not k.endswith("_error"))` -- or more explicitly, check that database, redis, qdrant, and litellm are all `"ok"`.
- Note: `"local"` for qdrant should count as healthy (it means dev mode, Qdrant is embedded).

**Important:** Keep the existing database and redis checks exactly as they are. Only ADD the new checks below them.
  </action>
  <verify>
Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "from src.app.api.v1.health import _check_dependencies; print('Import OK')"`
Verify the function signature hasn't changed and imports work.
Run existing tests: `cd "/Users/RAZER/Documents/projects/sales army" && python -m pytest tests/ -k "health" -x --no-header -q 2>/dev/null || echo "No health tests or tests need fixtures"`
  </verify>
  <done>
`_check_dependencies()` returns a dict with keys: database, redis, qdrant, litellm. The readiness endpoint returns 200 only when all 4 checks pass (where "local" counts as passing for qdrant). Existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add production env vars to Settings and wire NotionAdapter in main.py</name>
  <files>src/app/config.py, src/app/main.py, src/app/services/gsuite/auth.py</files>
  <action>
**config.py changes:**

1. Add Notion CRM settings after the existing Google Workspace section:
```python
# Notion CRM Integration (Phase 5 adapter, wired in Phase 9)
NOTION_TOKEN: str = ""  # Notion internal integration token
NOTION_DATABASE_ID: str = ""  # Notion database ID for deals pipeline
```

2. Add base64 service account support after `GOOGLE_SERVICE_ACCOUNT_FILE`:
```python
GOOGLE_SERVICE_ACCOUNT_JSON_B64: str = ""  # Base64-encoded service account JSON (for production)
```

3. Add a method to `Settings` class:
```python
def get_service_account_path(self) -> str | None:
    """Return path to service account file, decoding from base64 if needed.

    In development, GOOGLE_SERVICE_ACCOUNT_FILE points to a local JSON file.
    In production (Cloud Run), GOOGLE_SERVICE_ACCOUNT_JSON_B64 contains the
    base64-encoded JSON, which is decoded to a temp file.
    """
    if self.GOOGLE_SERVICE_ACCOUNT_FILE:
        return self.GOOGLE_SERVICE_ACCOUNT_FILE
    if self.GOOGLE_SERVICE_ACCOUNT_JSON_B64:
        import base64
        import tempfile
        import os
        decoded = base64.b64decode(self.GOOGLE_SERVICE_ACCOUNT_JSON_B64)
        tmp_path = os.path.join(tempfile.gettempdir(), "gcp-service-account.json")
        with open(tmp_path, "wb") as f:
            f.write(decoded)
        return tmp_path
    return None
```

**main.py changes:**

1. In the Phase 4 Sales Agent initialization block, replace the condition:
```python
if settings.GOOGLE_SERVICE_ACCOUNT_FILE:
```
with:
```python
sa_path = settings.get_service_account_path()
if sa_path:
```
And use `sa_path` instead of `settings.GOOGLE_SERVICE_ACCOUNT_FILE` when constructing `GSuiteAuthManager`.

2. Apply the same change in the Phase 6 Meeting Capabilities block -- every place that checks `settings.GOOGLE_SERVICE_ACCOUNT_FILE` should instead use `settings.get_service_account_path()`. There are 3 occurrences in Phase 6 (calendar service, Gmail service for minutes, and the main GSuite auth).

3. In the Phase 5 Deal Management block, after the existing `SyncEngine` initialization (which currently sets `external=None`), add Notion wiring:
```python
# Wire NotionAdapter when Notion credentials are configured
if settings.NOTION_TOKEN and settings.NOTION_DATABASE_ID:
    try:
        from src.app.deals.crm.notion import NotionAdapter
        notion_adapter = NotionAdapter(
            token=settings.NOTION_TOKEN,
            database_id=settings.NOTION_DATABASE_ID,
        )
        app.state.sync_engine = SyncEngine(
            primary=PostgresAdapter(repository=deal_repository, tenant_id=""),
            external=notion_adapter,
            field_ownership=DEFAULT_FIELD_OWNERSHIP,
        )
        log.info("phase5.notion_adapter_wired")
    except Exception:
        log.warning("phase5.notion_adapter_init_failed", exc_info=True)
```

**auth.py changes:**

No changes needed to auth.py -- `GSuiteAuthManager.__init__` already accepts `service_account_file: str` and uses `from_service_account_file()`. The `get_service_account_path()` method returns a file path (either the original or a temp file from base64), so the existing auth code works unchanged.
  </action>
  <verify>
Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "from src.app.config import get_settings; s = get_settings(); print('NOTION_TOKEN' in s.model_fields, 'GOOGLE_SERVICE_ACCOUNT_JSON_B64' in s.model_fields, hasattr(s, 'get_service_account_path'))"`
Expected: `True True True`

Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "from src.app.main import create_app; print('App factory OK')"`
Run existing tests: `cd "/Users/RAZER/Documents/projects/sales army" && python -m pytest tests/ -x --no-header -q --timeout=30 2>&1 | tail -5`
  </verify>
  <done>
Settings class has `NOTION_TOKEN`, `NOTION_DATABASE_ID`, `GOOGLE_SERVICE_ACCOUNT_JSON_B64` fields and a `get_service_account_path()` method. main.py uses `get_service_account_path()` instead of `GOOGLE_SERVICE_ACCOUNT_FILE` for all GSuite auth construction. NotionAdapter is wired into SyncEngine when NOTION_TOKEN and NOTION_DATABASE_ID are set. Existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.app.api.v1.health import _check_dependencies"` -- imports without error
2. `python -c "from src.app.config import Settings; s = Settings(); assert hasattr(s, 'NOTION_TOKEN'); assert hasattr(s, 'get_service_account_path')"` -- new fields exist
3. `python -c "from src.app.main import create_app"` -- app factory loads without error
4. `python -m pytest tests/ -x -q` -- existing test suite passes
</verification>

<success_criteria>
- Health endpoint checks 4 dependencies (database, redis, qdrant, litellm)
- Settings accepts all production env vars including Notion and base64 service account
- NotionAdapter is wired into SyncEngine when Notion credentials are present
- GSuite services use get_service_account_path() supporting both file and base64 modes
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-production-deployment/09-01-SUMMARY.md`
</output>
