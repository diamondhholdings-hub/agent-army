---
phase: 06-meeting-capabilities
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/app/meetings/calendar/__init__.py
  - src/app/meetings/calendar/monitor.py
  - src/app/meetings/calendar/briefing.py
  - tests/test_calendar_briefing.py
autonomous: true

must_haves:
  truths:
    - "CalendarMonitor detects meetings where the agent is explicitly invited and have a Google Meet link"
    - "BriefingGenerator creates pre-meeting briefings 2 hours before meetings in structured, bullet, and adaptive formats"
    - "Briefings include account context, attendee profiles, objectives, and suggested talk tracks"
    - "Last-minute meetings (added <2h before start) get immediate briefing generation"
  artifacts:
    - path: "src/app/meetings/calendar/monitor.py"
      provides: "CalendarMonitor service that watches for agent meeting invites"
      exports: ["CalendarMonitor"]
      min_lines: 80
    - path: "src/app/meetings/calendar/briefing.py"
      provides: "BriefingGenerator for multi-format pre-meeting briefings"
      exports: ["BriefingGenerator"]
      min_lines: 100
  key_links:
    - from: "src/app/meetings/calendar/monitor.py"
      to: "src/app/services/gsuite/calendar.py"
      via: "GoogleCalendarService for calendar event fetching"
      pattern: "GoogleCalendarService"
    - from: "src/app/meetings/calendar/monitor.py"
      to: "src/app/meetings/repository.py"
      via: "MeetingRepository for persisting discovered meetings"
      pattern: "MeetingRepository"
    - from: "src/app/meetings/calendar/briefing.py"
      to: "src/app/meetings/repository.py"
      via: "MeetingRepository for saving generated briefings"
      pattern: "save_briefing"
---

<objective>
Build the pre-meeting pipeline -- CalendarMonitor watches for agent meeting invites and BriefingGenerator creates multi-format briefings 2 hours before meetings.

Purpose: Per CONTEXT.md locked decisions, the agent must detect explicit invites (opt-in model) and generate briefings with account context, attendee profiles, objectives, and talk tracks 2 hours before meeting start. This plan delivers the entire pre-meeting preparation flow.

Output: CalendarMonitor service + BriefingGenerator service with unit tests.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-meeting-capabilities/06-CONTEXT.md
@.planning/phases/06-meeting-capabilities/06-RESEARCH.md
@.planning/phases/06-meeting-capabilities/06-01-SUMMARY.md

@src/app/meetings/schemas.py
@src/app/meetings/repository.py
@src/app/services/gsuite/calendar.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: CalendarMonitor service</name>
  <files>
    src/app/meetings/calendar/__init__.py
    src/app/meetings/calendar/monitor.py
  </files>
  <action>
    1. Create `src/app/meetings/calendar/__init__.py` (empty module marker).

    2. Create `src/app/meetings/calendar/monitor.py` with `CalendarMonitor`:
       - Constructor takes: `calendar_service: GoogleCalendarService`, `repository: MeetingRepository`, `briefing_generator` (will be BriefingGenerator), `bot_manager` (optional, for triggering bot joins -- None until Plan 06-03)
       - Constants: `BRIEFING_LEAD_TIME_HOURS = 2`, `EARLY_JOIN_MINUTES = 3`, `POLL_INTERVAL_SECONDS = 60`

       - `async check_upcoming_meetings(agent_email: str, tenant_id: str) -> list[Meeting]`:
         - Query calendar for events in window: now to now + BRIEFING_LEAD_TIME_HOURS + 1 hour
         - Filter: agent explicitly invited AND has Google Meet link (using GoogleCalendarService methods)
         - For each qualifying event, check if already tracked in repository via `get_meeting_by_event_id`
         - If not tracked, create meeting record via `repository.create_meeting`
         - Return list of upcoming meetings

       - `async process_upcoming_meetings(agent_email: str, tenant_id: str) -> None`:
         - Call `check_upcoming_meetings` to get upcoming meetings
         - For each meeting with status SCHEDULED:
           - If meeting starts within BRIEFING_LEAD_TIME_HOURS and no briefing exists: trigger briefing generation
           - If meeting starts within EARLY_JOIN_MINUTES: trigger bot join (if bot_manager available)
         - For meetings added less than 2 hours before start: generate briefing immediately (CONTEXT.md: degraded lead time > no briefing)

       - `async run_poll_loop(agent_email: str, tenant_id: str) -> None`:
         - Async loop that calls `process_upcoming_meetings` every `POLL_INTERVAL_SECONDS`
         - Log each poll cycle with structlog
         - Graceful error handling: log and continue on individual meeting failures

       - `_classify_attendees(event: dict, internal_domain: str) -> list[Participant]`:
         - Parse attendees from event, classify as INTERNAL (email matches internal_domain) or EXTERNAL
         - Return list of Participant schemas

       - Idempotent briefing keyed by (meeting_id, scheduled_time) per Research Pitfall 8
       - If meeting is rescheduled (different start time for same event_id), generate new briefing
  </action>
  <verify>
    Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "from src.app.meetings.calendar.monitor import CalendarMonitor; print('CalendarMonitor OK')"`
  </verify>
  <done>
    CalendarMonitor polls Google Calendar, detects explicit agent invites, creates meeting records, and triggers briefing generation within the 2-hour lead time window. Last-minute meetings get immediate briefing generation.
  </done>
</task>

<task type="auto">
  <name>Task 2: BriefingGenerator and unit tests</name>
  <files>
    src/app/meetings/calendar/briefing.py
    tests/test_calendar_briefing.py
  </files>
  <action>
    1. Create `src/app/meetings/calendar/briefing.py` with `BriefingGenerator`:
       - Constructor takes: `repository: MeetingRepository`, `llm_service` (optional, for LLM-powered content), `deal_repository` (optional, from Phase 5 for deal context)

       - `async generate_briefing(meeting: Meeting, tenant_id: str, format: str = "structured") -> Briefing`:
         - Gathers context from multiple sources:
           a. Account context: company name from participants, any known deal info from deal_repository
           b. Attendee profiles: names, titles, roles from participant data
           c. Objectives: inferred from meeting title, deal stage, and recent conversation context
           d. Talk tracks: suggested conversation topics based on deal stage and QBS methodology
         - Uses instructor + litellm pattern (existing from Phase 4) for LLM-powered content generation
         - Uses `model='reasoning'` (quality model) since briefings are not latency-sensitive
         - Saves briefing to repository and returns it

       - `async generate_all_formats(meeting: Meeting, tenant_id: str) -> list[Briefing]`:
         - Generate briefings in all 3 formats per CONTEXT.md: "structured", "bullet", "adaptive"
         - Save all to repository
         - Return list of briefings

       - `_build_structured_briefing(content: BriefingContent) -> str`:
         - Renders BriefingContent as a structured Markdown document
         - Sections: Meeting Overview, Attendee Profiles, Account Context, Deal Status, Objectives, Suggested Talk Tracks

       - `_build_bullet_briefing(content: BriefingContent) -> str`:
         - Renders BriefingContent as a concise bullet-point summary
         - Quick-scan format for fast consumption

       - `_build_adaptive_briefing(content: BriefingContent, meeting: Meeting) -> str`:
         - Detailed for new customer contacts (first meeting with this attendee set)
         - Brief for ongoing relationships (previous meetings with same attendees)
         - Check repository for prior meetings with overlapping attendees

       - Pydantic model for LLM extraction: `BriefingExtraction(BaseModel)` with fields for objectives (list[str]) and talk_tracks (list[str])
       - Falls back to rule-based content if LLM is unavailable (deal stage -> default objectives)

    2. Create `tests/test_calendar_briefing.py` with unit tests:
       - Test CalendarMonitor.check_upcoming_meetings with mock calendar service returning events
       - Test CalendarMonitor._classify_attendees with internal and external attendees
       - Test CalendarMonitor skips already-tracked meetings (idempotent)
       - Test CalendarMonitor handles last-minute meetings (generates briefing immediately)
       - Test BriefingGenerator.generate_briefing produces valid Briefing schema
       - Test BriefingGenerator._build_structured_briefing renders all sections
       - Test BriefingGenerator._build_bullet_briefing produces concise output
       - Test BriefingGenerator._build_adaptive_briefing varies by meeting history
       - Test BriefingGenerator falls back to rule-based when LLM unavailable
       - Use mock/in-memory repository doubles for all repository interactions
       - Minimum 10 tests
  </action>
  <verify>
    Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -m pytest tests/test_calendar_briefing.py -v`
    All tests pass.
  </verify>
  <done>
    BriefingGenerator creates pre-meeting briefings in all 3 formats (structured, bullet, adaptive) with account context, attendee profiles, objectives, and talk tracks. CalendarMonitor and BriefingGenerator are tested with mocks. Rule-based fallback works without LLM.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.app.meetings.calendar.monitor import CalendarMonitor; from src.app.meetings.calendar.briefing import BriefingGenerator; print('Pre-meeting pipeline OK')"` succeeds
2. `python -m pytest tests/test_calendar_briefing.py -v` -- all tests pass
3. CalendarMonitor detects explicit invites only (opt-in model per CONTEXT.md)
4. BriefingGenerator produces all 3 format variants per CONTEXT.md
</verification>

<success_criteria>
Pre-meeting pipeline is complete -- CalendarMonitor watches for invites, BriefingGenerator creates multi-format briefings 2 hours before meetings. Briefings include account context, attendee profiles, objectives, and suggested talk tracks.
</success_criteria>

<output>
After completion, create `.planning/phases/06-meeting-capabilities/06-02-SUMMARY.md`
</output>
