---
phase: 06-meeting-capabilities
plan: 06
type: execute
wave: 4
depends_on: ["06-01", "06-02", "06-03", "06-04", "06-05"]
files_modified:
  - src/app/api/v1/meetings.py
  - src/app/api/v1/router.py
  - src/app/main.py
  - tests/test_meeting_integration.py
autonomous: true

must_haves:
  truths:
    - "User can list upcoming meetings, view details, and check bot status via REST API"
    - "User can request a pre-meeting briefing and receive it in their chosen format"
    - "User can manually trigger bot join and see it appear in the Google Meet"
    - "User can retrieve meeting transcript and generate structured minutes after meeting ends"
    - "User can manually share meeting minutes to selected recipients (no automatic external distribution)"
    - "WebSocket endpoint enables real-time communication between Output Media webapp and backend pipeline"
    - "All Phase 6 services are wired into main.py lifespan following the per-module try/except pattern"
    - "Application starts successfully with Phase 6 components (or gracefully degrades if API keys missing)"
  artifacts:
    - path: "src/app/api/v1/meetings.py"
      provides: "Meeting API endpoints: briefings, minutes, bot status, webhook, WebSocket"
      min_lines: 150
    - path: "src/app/main.py"
      provides: "Phase 6 module initialization in lifespan"
      contains: "phase6"
    - path: "tests/test_meeting_integration.py"
      provides: "Integration tests for Phase 6 meeting capabilities"
      min_lines: 100
  key_links:
    - from: "src/app/api/v1/meetings.py"
      to: "src/app/meetings/repository.py"
      via: "Request.app.state dependency injection for repository"
      pattern: "app\\.state"
    - from: "src/app/api/v1/meetings.py"
      to: "src/app/meetings/bot/manager.py"
      via: "BotManager from app.state for bot operations"
      pattern: "bot_manager"
    - from: "src/app/api/v1/router.py"
      to: "src/app/api/v1/meetings.py"
      via: "Router inclusion for meeting endpoints"
      pattern: "meetings"
    - from: "src/app/main.py"
      to: "src/app/meetings"
      via: "Lifespan initialization of all Phase 6 services"
      pattern: "phase6"
---

<objective>
Wire all Phase 6 services together -- API endpoints, WebSocket for real-time pipeline communication, main.py lifespan initialization, router registration, and integration tests.

Purpose: This final plan connects all Phase 6 components into the running application. API endpoints expose meeting capabilities to the frontend. The WebSocket endpoint bridges the Output Media webapp to the backend pipeline. main.py initialization follows the established per-module try/except pattern. Integration tests verify end-to-end flows.

Output: Complete Phase 6 wiring with API endpoints, WebSocket, main.py initialization, and integration tests.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-meeting-capabilities/06-CONTEXT.md
@.planning/phases/06-meeting-capabilities/06-RESEARCH.md
@.planning/phases/06-meeting-capabilities/06-01-SUMMARY.md
@.planning/phases/06-meeting-capabilities/06-02-SUMMARY.md
@.planning/phases/06-meeting-capabilities/06-03-SUMMARY.md
@.planning/phases/06-meeting-capabilities/06-04-SUMMARY.md
@.planning/phases/06-meeting-capabilities/06-05-SUMMARY.md

@src/app/main.py
@src/app/api/v1/router.py
@src/app/api/v1/sales.py
@src/app/api/v1/deals.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Meeting API endpoints with WebSocket and webhook handler</name>
  <files>
    src/app/api/v1/meetings.py
    src/app/api/v1/router.py
  </files>
  <action>
    1. Create `src/app/api/v1/meetings.py` following the sales.py and deals.py auth+tenant dependency pattern:
       - Import: FastAPI Router, WebSocket, Depends, HTTPException, Request
       - Router: `router = APIRouter(prefix="/api/v1/meetings", tags=["meetings"])`

       Helper functions (following sales.py pattern):
       - `_get_meeting_repository(request: Request) -> MeetingRepository`: reads from request.app.state with 503 fallback
       - `_get_bot_manager(request: Request) -> BotManager`: reads from request.app.state with 503 fallback
       - `_get_briefing_generator(request: Request) -> BriefingGenerator`: reads from request.app.state with 503 fallback
       - `_get_minutes_generator(request: Request) -> MinutesGenerator`: reads from request.app.state with 503 fallback
       - `_get_minutes_distributor(request: Request) -> MinutesDistributor`: reads from request.app.state with 503 fallback

       REST endpoints (all require tenant auth):

       a. `GET /api/v1/meetings/` -- List upcoming meetings for tenant
          - Query params: status (optional), from_date (optional), to_date (optional)
          - Returns: list of Meeting schemas

       b. `GET /api/v1/meetings/{meeting_id}` -- Get meeting details
          - Returns: Meeting schema with status, participants, bot_id

       c. `POST /api/v1/meetings/{meeting_id}/briefing` -- Generate or retrieve briefing
          - Body: MeetingBriefingRequest (format)
          - If briefing exists for format: return cached
          - If not: generate via BriefingGenerator
          - Returns: Briefing schema

       d. `GET /api/v1/meetings/{meeting_id}/briefing/{format}` -- Get specific format briefing
          - Returns: Briefing schema or 404

       e. `POST /api/v1/meetings/{meeting_id}/bot/start` -- Manually trigger bot join
          - Creates Recall.ai bot via BotManager
          - Returns: { bot_id, status }

       f. `GET /api/v1/meetings/{meeting_id}/bot/status` -- Get bot status
          - Returns: { bot_id, status, joined_at, participants_count }

       g. `GET /api/v1/meetings/{meeting_id}/transcript` -- Get meeting transcript
          - Returns: Transcript schema or 404

       h. `GET /api/v1/meetings/{meeting_id}/minutes` -- Get meeting minutes
          - Returns: MeetingMinutes schema or 404

       i. `POST /api/v1/meetings/{meeting_id}/minutes/generate` -- Trigger minutes generation
          - Loads transcript, generates minutes via MinutesGenerator
          - Returns: MeetingMinutes schema

       j. `POST /api/v1/meetings/{meeting_id}/minutes/share` -- Manually share minutes externally
          - Body: MinutesShareRequest (recipient_emails, include_transcript)
          - Per CONTEXT.md: manual share only, no automatic distribution
          - Returns: { shared_to, shared_at }

       k. `POST /api/v1/meetings/webhook` -- Recall.ai webhook receiver
          - Receives bot lifecycle events and transcript data
          - Validates webhook signature/token
          - Routes events to BotManager.handle_bot_event
          - Returns: 200 OK (always, per webhook best practice)

       WebSocket endpoint:

       l. `WebSocket /ws/meeting/{meeting_id}` -- Real-time pipeline bridge
          - Accepts WebSocket connection from Output Media webapp
          - Receives transcript data from webapp: { type: "transcript", text: "...", is_final: bool, speaker_id: "..." }
          - Routes to RealtimePipeline.handle_stt_transcript
          - Sends back: { type: "speak", text: "...", confidence: float } or { type: "silence" }
          - Also sends: { type: "reaction", reaction: "nod|interested|thinking" } for avatar idle behavior
          - Maintains connection for duration of meeting
          - Graceful disconnect on meeting end

    2. Update `src/app/api/v1/router.py`:
       - Add import: `from src.app.api.v1 import meetings`
       - Add: `router.include_router(meetings.router)`
  </action>
  <verify>
    Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "from src.app.api.v1.meetings import router; print(f'Meeting router OK: {len(router.routes)} routes')"`
  </verify>
  <done>
    Meeting API provides 11 REST endpoints + 1 WebSocket for CRUD operations, briefing management, bot control, minutes access, manual share, Recall.ai webhook handling, and real-time pipeline communication. Router registered in v1 router.
  </done>
</task>

<task type="auto">
  <name>Task 2: main.py wiring and integration tests</name>
  <files>
    src/app/main.py
    tests/test_meeting_integration.py
  </files>
  <action>
    1. Add Phase 6 initialization to `src/app/main.py` lifespan function:
       - Insert AFTER Phase 5 deal management block, BEFORE yield
       - Follow existing per-module try/except pattern

       ```python
       # ── Phase 6: Meeting Capabilities ──────────────────────────────
       try:
           from src.app.meetings.repository import MeetingRepository
           from src.app.meetings.calendar.monitor import CalendarMonitor
           from src.app.meetings.calendar.briefing import BriefingGenerator
           from src.app.meetings.bot.recall_client import RecallClient
           from src.app.meetings.bot.manager import BotManager
           from src.app.meetings.realtime.stt import DeepgramSTT
           from src.app.meetings.realtime.tts import ElevenLabsTTS
           from src.app.meetings.realtime.avatar import HeyGenAvatar
           from src.app.meetings.realtime.pipeline import RealtimePipeline
           from src.app.meetings.realtime.silence_checker import SilenceChecker
           from src.app.meetings.realtime.turn_detector import TurnDetector
           from src.app.meetings.minutes.generator import MinutesGenerator
           from src.app.meetings.minutes.distributor import MinutesDistributor
           from src.app.services.gsuite.calendar import GoogleCalendarService
           from src.app.core.database import get_tenant_session as _get_meeting_session

           meeting_repo = MeetingRepository(session_factory=_get_meeting_session)
           app.state.meeting_repository = meeting_repo

           # Calendar service (uses existing GSuiteAuthManager)
           calendar_service = None
           if gsuite_auth:
               calendar_service = GoogleCalendarService(auth_manager=gsuite_auth)

           # Briefing generator
           deal_repo = getattr(app.state, "deal_repository", None)
           briefing_gen = BriefingGenerator(
               repository=meeting_repo,
               llm_service=llm_service,
               deal_repository=deal_repo,
           )
           app.state.briefing_generator = briefing_gen

           # Recall.ai bot management
           recall_client = None
           bot_manager = None
           if settings.RECALL_AI_API_KEY:
               recall_client = RecallClient(
                   api_key=settings.RECALL_AI_API_KEY,
                   region=settings.RECALL_AI_REGION,
               )
               bot_manager = BotManager(
                   recall_client=recall_client,
                   repository=meeting_repo,
                   settings=settings,
               )
           app.state.bot_manager = bot_manager

           # Real-time pipeline components (created per-meeting, stored as factories)
           app.state.deepgram_api_key = settings.DEEPGRAM_API_KEY
           app.state.elevenlabs_api_key = settings.ELEVENLABS_API_KEY
           app.state.elevenlabs_voice_id = settings.ELEVENLABS_VOICE_ID
           app.state.heygen_api_key = settings.HEYGEN_API_KEY
           app.state.heygen_avatar_id = settings.HEYGEN_AVATAR_ID

           # Minutes pipeline
           minutes_gen = MinutesGenerator(repository=meeting_repo, llm_service=llm_service)
           gmail_svc = getattr(app.state, "gmail_service", gmail_service)
           minutes_dist = MinutesDistributor(
               repository=meeting_repo,
               gmail_service=gmail_svc,
           )
           app.state.minutes_generator = minutes_gen
           app.state.minutes_distributor = minutes_dist

           # Calendar monitor with poll loop (background task)
           if calendar_service:
               calendar_monitor = CalendarMonitor(
                   calendar_service=calendar_service,
                   repository=meeting_repo,
                   briefing_generator=briefing_gen,
                   bot_manager=bot_manager,
               )
               app.state.calendar_monitor = calendar_monitor
               # Start poll loop as background task (same pattern as Phase 4.1 scheduler)
               # Note: actual polling requires agent_email and tenant_id from configuration
               log.info("phase6.calendar_monitor_ready")
           else:
               app.state.calendar_monitor = None

           log.info("phase6.meeting_capabilities_initialized")
       except Exception as exc:
           log.warning("phase6.meeting_capabilities_init_failed", error=str(exc))
           app.state.meeting_repository = None
           app.state.briefing_generator = None
           app.state.bot_manager = None
           app.state.minutes_generator = None
           app.state.minutes_distributor = None
           app.state.calendar_monitor = None
       ```

       NOTE: Reference `gsuite_auth` and `gmail_service` from Phase 4 init block. If they're scoped inside Phase 4 try/except, they may not be visible. In that case, use getattr(app.state, ...) or restructure access. Check main.py and adjust accordingly -- the pattern is: services initialized in Phase 4 block can be read via app.state.

    2. Create `tests/test_meeting_integration.py` with integration tests:
       Using the test client and mock services:

       a. Test meeting list endpoint returns empty list for new tenant
       b. Test meeting creation via CalendarMonitor flow (mock calendar events)
       c. Test briefing generation endpoint returns valid briefing (mock LLM)
       d. Test briefing caching (same request returns cached briefing)
       e. Test bot start endpoint creates bot (mock RecallClient)
       f. Test bot status endpoint returns current status
       g. Test webhook endpoint processes transcript events correctly
       h. Test minutes generation endpoint produces structured minutes (mock LLM)
       i. Test minutes share endpoint sends email to specified recipients only (mock Gmail)
       j. Test minutes share endpoint does NOT auto-share (verify no unsolicited sends)
       k. Test WebSocket connection accepts and processes transcript messages
       l. Test Phase 6 init in main.py succeeds with mock services
       m. Test Phase 6 init gracefully fails (sets None) without API keys

       - Use httpx.AsyncClient with TestClient for REST endpoints
       - Use WebSocket test client for WebSocket endpoint
       - Mock all external services (Recall.ai, Deepgram, ElevenLabs, HeyGen, Google Calendar)
       - Use InMemoryMeetingRepository for database operations
       - Minimum 13 tests
  </action>
  <verify>
    Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -m pytest tests/test_meeting_integration.py -v`
    All tests pass.
    Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "from src.app.main import create_app; app = create_app(); print('App creates successfully with Phase 6')"`
  </verify>
  <done>
    All Phase 6 services wired into main.py lifespan with graceful failure handling. API endpoints registered in v1 router. WebSocket endpoint bridges Output Media webapp to backend pipeline. Integration tests verify end-to-end flows with mocked external services. Application starts successfully with Phase 6 components.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_meeting_integration.py -v` -- all tests pass
2. `python -c "from src.app.main import create_app; app = create_app(); print('OK')"` -- app starts
3. Meeting routes registered: `python -c "from src.app.api.v1.router import router; print([r.path for r in router.routes])"` shows meeting endpoints
4. main.py has Phase 6 initialization block with try/except pattern
5. No automatic external minutes distribution in any code path
6. WebSocket endpoint exists at /ws/meeting/{meeting_id}
</verification>

<success_criteria>
Phase 6 is fully wired -- all meeting capabilities accessible via REST API and WebSocket. main.py initializes all Phase 6 services with graceful fallback. Integration tests verify briefing generation, bot management, minutes generation, and controlled external sharing. The application starts and runs with all Phase 6 components.
</success_criteria>

<output>
After completion, create `.planning/phases/06-meeting-capabilities/06-06-SUMMARY.md`
</output>
