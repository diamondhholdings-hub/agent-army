---
phase: 06-meeting-capabilities
plan: 05
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/app/meetings/minutes/__init__.py
  - src/app/meetings/minutes/generator.py
  - src/app/meetings/minutes/distributor.py
  - tests/test_minutes.py
autonomous: true

must_haves:
  truths:
    - "MinutesGenerator extracts structured minutes from meeting transcripts with all 4 content types: verbatim transcript, executive summary, action items with owners, and decisions/commitments"
    - "Map-reduce handles long transcripts exceeding single LLM context window"
    - "MinutesDistributor saves minutes internally by default and provides manual share endpoint for controlled external distribution"
    - "No automatic external distribution -- rep controls what goes to customers"
  artifacts:
    - path: "src/app/meetings/minutes/generator.py"
      provides: "MinutesGenerator with map-reduce for long transcripts"
      exports: ["MinutesGenerator"]
      min_lines: 120
    - path: "src/app/meetings/minutes/distributor.py"
      provides: "MinutesDistributor for internal save and manual external sharing"
      exports: ["MinutesDistributor"]
      min_lines: 60
  key_links:
    - from: "src/app/meetings/minutes/generator.py"
      to: "instructor"
      via: "Structured LLM extraction for minutes (existing Phase 4 pattern)"
      pattern: "instructor\\.from_litellm"
    - from: "src/app/meetings/minutes/generator.py"
      to: "src/app/meetings/repository.py"
      via: "MeetingRepository for saving generated minutes"
      pattern: "save_minutes"
    - from: "src/app/meetings/minutes/distributor.py"
      to: "src/app/services/gsuite/gmail.py"
      via: "GmailService for sending minutes via email"
      pattern: "GmailService"
---

<objective>
Build the post-meeting pipeline -- MinutesGenerator extracts structured meeting minutes from transcripts and MinutesDistributor handles internal storage with controlled manual external sharing.

Purpose: Per CONTEXT.md locked decisions, minutes must include all 4 content types (verbatim transcript, executive summary, action items with owners, decisions/commitments). Minutes are internal-only by default -- reps control what gets shared externally. This plan uses the existing instructor+litellm pattern from Phase 4 for structured extraction.

Output: MinutesGenerator + MinutesDistributor services with unit tests.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-meeting-capabilities/06-CONTEXT.md
@.planning/phases/06-meeting-capabilities/06-RESEARCH.md
@.planning/phases/06-meeting-capabilities/06-01-SUMMARY.md

@src/app/meetings/schemas.py
@src/app/meetings/repository.py
@src/app/services/gsuite/gmail.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: MinutesGenerator with map-reduce for long transcripts</name>
  <files>
    src/app/meetings/minutes/__init__.py
    src/app/meetings/minutes/generator.py
  </files>
  <action>
    1. Create `src/app/meetings/minutes/__init__.py` (empty module marker).

    2. Create `src/app/meetings/minutes/generator.py` with `MinutesGenerator`:
       - Uses existing instructor + litellm pattern (Phase 4: QualificationExtractor, Phase 5: OpportunityDetector)
       - Uses model='reasoning' (quality model -- minutes are not latency-sensitive, RESEARCH.md)

       Constants:
       - MAX_TOKENS_PER_CHUNK = 12000 (~15 minutes of conversation)
       - MODEL_REASONING = "anthropic/claude-sonnet-4-20250514" (quality model)
       - CHARS_PER_TOKEN = 4.0 (per 03-02 decision for token estimation)

       Pydantic response models for instructor:
       - `ExtractedActionItem(BaseModel)`: owner (str), action (str), due_date (str|None), context (str)
       - `ExtractedDecision(BaseModel)`: decision (str), participants (list[str]), context (str)
       - `ExtractedMinutes(BaseModel)`: executive_summary (str), key_topics (list[str]), action_items (list[ExtractedActionItem]), decisions (list[ExtractedDecision]), follow_up_date (str|None)
       - `ChunkSummary(BaseModel)`: summary (str), action_items (list[ExtractedActionItem]), decisions (list[ExtractedDecision])

       Constructor takes: `repository: MeetingRepository`, `llm_service` (optional)

       - `async generate(transcript: Transcript, attendees: list[Participant], meeting_metadata: dict, tenant_id: str) -> MeetingMinutes`:
         - If transcript token count < MAX_TOKENS_PER_CHUNK: single-pass extraction
         - If transcript exceeds limit: map-reduce
           a. MAP: chunk transcript at ~15-minute segment boundaries
           b. For each chunk: extract ChunkSummary (summary + action items + decisions)
           c. REDUCE: synthesize all ChunkSummaries into final ExtractedMinutes
         - Build MeetingMinutes schema from extracted data
         - Include verbatim full_text from Transcript (first of 4 content types)
         - Save to repository via save_minutes
         - Update meeting status to MINUTES_GENERATED
         - Return MeetingMinutes

       - `async _extract_minutes_single_pass(transcript_text: str, attendees: list[Participant], metadata: dict) -> ExtractedMinutes`:
         - Uses instructor.from_litellm(litellm.acompletion) pattern
         - System prompt: "You are analyzing a sales meeting transcript to generate structured meeting minutes. Extract: 1) Executive summary (2-3 paragraphs), 2) Key topics discussed, 3) Action items with specific owners and due dates, 4) Decisions and commitments made. Note absence of items rather than making assumptions. Be precise about who said what and who committed to what."
         - User message: meeting title, date, attendees, transcript text
         - response_model=ExtractedMinutes, temperature=0.1, max_tokens=4096

       - `async _summarize_chunk(chunk_text: str) -> ChunkSummary`:
         - Extract summary, action items, and decisions from a single chunk
         - Uses response_model=ChunkSummary

       - `_chunk_transcript(transcript_text: str) -> list[str]`:
         - Split transcript at speaker change boundaries near MAX_TOKENS_PER_CHUNK token limit
         - Prefer splitting at speaker turns (not mid-sentence)
         - Overlap: include last 2 speaker turns from previous chunk for context continuity

       - `_estimate_tokens(text: str) -> int`:
         - Simple estimation: len(text) / CHARS_PER_TOKEN (matching 03-02 pattern)

       - Falls back gracefully if instructor/litellm unavailable: returns MeetingMinutes with transcript only and empty extracted fields
  </action>
  <verify>
    Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "from src.app.meetings.minutes.generator import MinutesGenerator; print('MinutesGenerator OK')"`
  </verify>
  <done>
    MinutesGenerator extracts structured minutes (executive summary, key topics, action items with owners, decisions) from transcripts using instructor+litellm. Map-reduce handles long transcripts by chunking at speaker boundaries. Falls back gracefully without LLM.
  </done>
</task>

<task type="auto">
  <name>Task 2: MinutesDistributor and unit tests</name>
  <files>
    src/app/meetings/minutes/distributor.py
    tests/test_minutes.py
  </files>
  <action>
    1. Create `src/app/meetings/minutes/distributor.py` with `MinutesDistributor`:
       - Constructor takes: `repository: MeetingRepository`, `gmail_service` (optional, from Phase 4), `notification_service` (optional, for internal alerts)

       - `async save_internally(minutes: MeetingMinutes, tenant_id: str) -> None`:
         - Save minutes to repository (already done by generator, this ensures persistence)
         - Update meeting status to MINUTES_GENERATED
         - Emit internal notification: "Meeting minutes ready for [meeting title]"
         - Per CONTEXT.md: internal-only by default, rep/manager notified when ready

       - `async notify_internal(meeting: Meeting, minutes: MeetingMinutes, tenant_id: str) -> None`:
         - Send internal email notification to meeting organizer and internal attendees
         - Email includes: meeting title, date, executive summary, link to full minutes in system
         - Uses GmailService.send_email if available, falls back to logging
         - Per CONTEXT.md: rep/manager notified when ready

       - `async share_externally(meeting_id: UUID, tenant_id: str, recipient_emails: list[str], include_transcript: bool = False) -> dict`:
         - Manual share endpoint -- rep explicitly chooses what to send
         - Loads minutes from repository
         - Builds customer-appropriate email: executive summary + action items only (NOT internal notes or competitive info)
         - If include_transcript=True: append sanitized transcript (no internal-only markers)
         - Sends via GmailService to specified recipients
         - Marks minutes as shared_externally in repository
         - Per CONTEXT.md: no automatic external distribution, rep controls sharing
         - Returns dict with sent_to and share_time

       - `_build_internal_email(meeting: Meeting, minutes: MeetingMinutes) -> str`:
         - Full content: executive summary, all action items, all decisions, link to transcript
         - HTML formatted for easy reading

       - `_build_external_email(meeting: Meeting, minutes: MeetingMinutes, include_transcript: bool) -> str`:
         - Customer-appropriate: executive summary + action items + decisions (no internal strategy)
         - Professional formatting, company branding

       - Per RESEARCH Pitfall 7: NEVER automatically share with external participants

    2. Create `tests/test_minutes.py` with unit tests:
       - Test MinutesGenerator._estimate_tokens returns reasonable count
       - Test MinutesGenerator._chunk_transcript splits at speaker boundaries
       - Test MinutesGenerator._chunk_transcript includes overlap for context
       - Test MinutesGenerator generates valid MeetingMinutes schema (mock LLM)
       - Test MinutesGenerator map-reduce for long transcript (mock LLM)
       - Test MinutesGenerator graceful fallback without LLM
       - Test MinutesDistributor.save_internally updates meeting status
       - Test MinutesDistributor.notify_internal sends email to internal attendees only
       - Test MinutesDistributor.share_externally sends customer-appropriate content
       - Test MinutesDistributor._build_external_email excludes internal notes
       - Test MinutesDistributor does NOT auto-share (no external recipients without explicit call)
       - Use mock repository, mock gmail_service for all tests
       - Minimum 12 tests
  </action>
  <verify>
    Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -m pytest tests/test_minutes.py -v`
    All tests pass.
  </verify>
  <done>
    MinutesDistributor saves minutes internally by default, notifies internal stakeholders, and provides a manual share endpoint for controlled external distribution. Customer-facing emails exclude internal strategy and notes. All unit tests pass confirming no automatic external distribution.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.app.meetings.minutes.generator import MinutesGenerator; from src.app.meetings.minutes.distributor import MinutesDistributor; print('Minutes pipeline OK')"` succeeds
2. `python -m pytest tests/test_minutes.py -v` -- all tests pass
3. MinutesGenerator uses instructor+litellm pattern (existing from Phase 4)
4. Map-reduce handles long transcripts with chunking at speaker boundaries
5. MinutesDistributor is internal-only by default -- no automatic external sharing
6. External sharing requires explicit manual call with recipient list
</verification>

<success_criteria>
Post-meeting pipeline is complete -- MinutesGenerator extracts all 4 content types (verbatim transcript, executive summary, action items with owners, decisions/commitments) from transcripts. MinutesDistributor ensures internal-only default with manual external sharing. Long meetings handled via map-reduce.
</success_criteria>

<output>
After completion, create `.planning/phases/06-meeting-capabilities/06-05-SUMMARY.md`
</output>
