---
phase: 04-sales-agent-core
plan: 04
type: execute
wave: 3
depends_on: ["04-01", "04-02", "04-03"]
files_modified:
  - src/app/agents/sales/agent.py
  - src/app/agents/sales/capabilities.py
  - src/app/agents/sales/actions.py
  - src/app/agents/sales/escalation.py
  - src/app/agents/sales/__init__.py
  - tests/test_sales_agent.py
autonomous: true

must_haves:
  truths:
    - "SalesAgent extends BaseAgent and registers with capabilities (email_outreach, chat_messaging, qualification, escalation)"
    - "SalesAgent generates persona-adapted emails using compiled context from RAG + conversation history + methodology"
    - "SalesAgent generates persona-adapted chat messages with channel-appropriate formatting"
    - "After each interaction, qualification signals are extracted and merged into conversation state"
    - "Next-action engine recommends follow-ups based on deal stage, qualification gaps, and engagement signals"
    - "Escalation fires when confidence < 0.7, high-stakes detected, customer requests human, or complexity threshold exceeded"
    - "Escalation produces structured EscalationReport and publishes event via TenantEventBus"
  artifacts:
    - path: "src/app/agents/sales/agent.py"
      provides: "SalesAgent class composing GSuite, RAG, prompts, qualification, state, actions, escalation"
      exports: ["SalesAgent"]
    - path: "src/app/agents/sales/actions.py"
      provides: "Next-action recommendation engine"
      exports: ["NextActionEngine"]
    - path: "src/app/agents/sales/escalation.py"
      provides: "Escalation trigger evaluation and report generation"
      exports: ["EscalationManager"]
    - path: "src/app/agents/sales/capabilities.py"
      provides: "AgentCapability declarations for registry"
      exports: ["SALES_AGENT_CAPABILITIES", "create_sales_registration"]
  key_links:
    - from: "src/app/agents/sales/agent.py"
      to: "src/app/services/gsuite/gmail.py"
      via: "GmailService for sending emails"
      pattern: "gmail_service\\.send_email"
    - from: "src/app/agents/sales/agent.py"
      to: "src/knowledge/rag/pipeline.py"
      via: "AgenticRAGPipeline for context compilation"
      pattern: "rag_pipeline\\.run"
    - from: "src/app/agents/sales/agent.py"
      to: "src/app/agents/sales/qualification.py"
      via: "QualificationExtractor for signal extraction after interactions"
      pattern: "qualification_extractor\\.extract_signals"
    - from: "src/app/agents/sales/escalation.py"
      to: "src/app/events/"
      via: "TenantEventBus for escalation notifications"
      pattern: "event_bus\\.publish"
    - from: "src/app/agents/sales/actions.py"
      to: "src/app/agents/sales/schemas.py"
      via: "ConversationState and NextAction for recommendation logic"
      pattern: "ConversationState|NextAction"
---

<objective>
Build the SalesAgent class (BaseAgent subclass), the next-action recommendation engine, and the escalation manager -- composing all prior components into the functional sales agent.

Purpose: This is the core composition plan. SA-01 (text conversation), SA-04 (context compilation), SA-09 (next-action), and SA-10 (escalation) are delivered here. The SalesAgent class wires together GSuite services (Plan 01), schemas/prompts (Plan 02), and state/qualification (Plan 03) into a working agent that can be invoked via the supervisor topology.
Output: SalesAgent, NextActionEngine, EscalationManager, and agent capabilities registration.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-sales-agent-core/04-CONTEXT.md
@.planning/phases/04-sales-agent-core/04-RESEARCH.md

@src/app/agents/base.py
@src/app/agents/registry.py
@src/app/services/gsuite/__init__.py
@src/app/agents/sales/schemas.py
@src/app/agents/sales/prompts.py
@src/app/agents/sales/state_repository.py
@src/app/agents/sales/qualification.py
@src/knowledge/rag/__init__.py
@src/knowledge/conversations/__init__.py
@src/knowledge/methodology/__init__.py
@src/app/context/__init__.py
@src/app/events/__init__.py
@src/app/services/llm.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create next-action engine and escalation manager</name>
  <files>
    src/app/agents/sales/actions.py
    src/app/agents/sales/escalation.py
  </files>
  <action>
    **src/app/agents/sales/actions.py** -- NextActionEngine class:

    - __init__(llm_service: LLMService): Stores LLM service reference.

    - async recommend_actions(state: ConversationState, recent_interactions: list[str] | None = None) -> list[NextAction]:
      Recommends 1-3 next actions based on conversation state analysis.

      Implementation approach -- HYBRID (rule-based fast path + LLM for nuanced situations):

      a. **Rule-based fast path** (no LLM call needed):
         - If state.escalated: return [NextAction(action_type="escalate", description="Pending human escalation", priority="urgent")]
         - If state.deal_stage == CLOSED_WON or CLOSED_LOST: return [NextAction(action_type="wait", description="Deal closed")]
         - If state.interaction_count == 0: return [NextAction(action_type="send_email", description="Initial outreach email", priority="high")]
         - If state.last_interaction is more than 7 days ago and deal_stage not STALLED: return [NextAction(action_type="follow_up", description="Re-engage - no activity in 7+ days", priority="high")]
         - If state.qualification.combined_completion < 0.3 and deal_stage in (DISCOVERY, QUALIFICATION): return [NextAction(action_type="send_email", description=f"Discovery email focusing on {_biggest_gaps(state.qualification)}", priority="medium")]

      b. **LLM-powered nuanced recommendation** (when rules don't produce clear result):
         - Use build_next_action_prompt() from prompts.py
         - Pass serialized conversation state and recent interactions
         - Extract structured list[NextAction] via instructor
         - Fallback: if LLM fails, return generic follow-up action based on deal stage

    - _biggest_gaps(qualification: QualificationState) -> str:
      Returns human-readable string of the biggest qualification gaps (e.g., "budget and timeline not yet identified").

    - _days_since_last_interaction(state: ConversationState) -> int | None:
      Returns days since last interaction, or None if no interactions.

    **src/app/agents/sales/escalation.py** -- EscalationManager class:

    - __init__(event_bus: TenantEventBus, llm_service: LLMService): Stores event bus and LLM service.

    - CONFIDENCE_THRESHOLD: float = 0.7 (locked decision from CONTEXT.md: conservative 70% for Phase 4)

    - HIGH_STAKES_KEYWORDS: list[str] = ["pricing", "contract", "negotiate", "competitor", "budget approval", "executive", "legal", "procurement", "discount", "renewal"]

    - async evaluate_escalation(state: ConversationState, latest_message: str = "") -> EscalationReport | None:
      Checks all escalation triggers (locked decision from CONTEXT.md):
      a. **Confidence threshold**: state.confidence_score < CONFIDENCE_THRESHOLD -> trigger "confidence_low"
      b. **High-stakes detection**: Check latest_message for HIGH_STAKES_KEYWORDS AND deal_stage in (NEGOTIATION, EVALUATION) -> trigger "high_stakes"
      c. **Customer request**: Check latest_message for phrases like "speak to someone", "talk to a human", "call me", "schedule a call", "real person" -> trigger "customer_request"
      d. **Complexity threshold**: state.qualification.meddic.decision_criteria has 3+ items AND multiple stakeholders mentioned in evidence -> trigger "complexity"
      Returns None if no triggers met. Returns EscalationReport if any trigger fires.

    - async _build_escalation_report(state: ConversationState, trigger: str, latest_message: str) -> EscalationReport:
      Constructs the full escalation report with:
      - account_context: summarize from state (deal stage, qualification progress, interaction count)
      - what_agent_tried: describe recent actions based on state.last_channel and state.interaction_count
      - why_escalating: specific explanation based on trigger type
      - recommended_next_action: LLM-generated recommendation using state context (use model='fast' for speed). On LLM failure, use rule-based fallback.
      - relevant_conversation_excerpts: extract from qualification evidence fields
      - notification_targets: look in state.metadata for rep_email and manager_email, default to empty list

    - async publish_escalation(report: EscalationReport) -> None:
      Publishes escalation event via TenantEventBus with:
      - event_type: EventType.AGENT (from existing event schemas)
      - source: "sales_agent"
      - data: serialized EscalationReport
      - tenant_id: from report
      Logs escalation via structlog with escalation_id, trigger, account_id.
  </action>
  <verify>
    `python -c "from src.app.agents.sales.actions import NextActionEngine; print('Actions import OK')"` succeeds.
    `python -c "from src.app.agents.sales.escalation import EscalationManager; print('Escalation import OK')"` succeeds.
    `python -c "
from src.app.agents.sales.schemas import ConversationState, DealStage
from src.app.agents.sales.actions import NextActionEngine
# Test rule-based fast path (no LLM needed)
state = ConversationState(state_id='t', tenant_id='t', account_id='a', contact_id='c', contact_email='x@y.com', interaction_count=0)
# NextActionEngine needs LLM but rule-based path shouldn't call it for interaction_count=0
print('Schema integration OK')
"` succeeds.
  </verify>
  <done>
    NextActionEngine uses hybrid rule-based + LLM approach: fast path for obvious situations (no interactions, stale deals, closed deals), LLM for nuanced recommendations. EscalationManager checks all 4 escalation triggers from CONTEXT.md (confidence < 0.7, high-stakes, customer request, complexity) and produces structured EscalationReport published via TenantEventBus. Both fail gracefully on LLM errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SalesAgent class, capabilities registration, and tests</name>
  <files>
    src/app/agents/sales/agent.py
    src/app/agents/sales/capabilities.py
    src/app/agents/sales/__init__.py
    tests/test_sales_agent.py
  </files>
  <action>
    **src/app/agents/sales/capabilities.py** -- Agent capability declarations:

    Define SALES_AGENT_CAPABILITIES as list[AgentCapability]:
    - AgentCapability(name="email_outreach", description="Send contextual sales emails via Gmail, adapted to customer persona and deal stage")
    - AgentCapability(name="chat_messaging", description="Send sales messages via Google Chat, adapted to customer persona and deal stage")
    - AgentCapability(name="qualification", description="Execute BANT and MEDDIC qualification by extracting signals from conversations")
    - AgentCapability(name="next_action", description="Recommend next sales actions based on deal state and engagement signals")
    - AgentCapability(name="escalation", description="Evaluate when to escalate to human sales rep and generate structured handoff reports")

    create_sales_registration() -> AgentRegistration:
    Returns AgentRegistration(
        agent_id="sales_agent",
        name="Sales Agent",
        description="Enterprise sales agent that conducts text-based interactions via email and chat, executes BANT/MEDDIC qualification, and manages deal progression",
        capabilities=SALES_AGENT_CAPABILITIES,
        backup_agent_id=None,  # No backup for v1
        tags=["sales", "email", "chat", "qualification", "bant", "meddic"],
        max_concurrent_tasks=3,
    )

    **src/app/agents/sales/agent.py** -- SalesAgent(BaseAgent):

    Constructor __init__:
    - registration: AgentRegistration
    - llm_service: LLMService
    - gmail_service: GmailService
    - chat_service: ChatService
    - rag_pipeline: AgenticRAGPipeline
    - conversation_store: ConversationStore
    - session_manager: SessionManager
    - state_repository: ConversationStateRepository
    - qualification_extractor: QualificationExtractor
    - action_engine: NextActionEngine
    - escalation_manager: EscalationManager
    Call super().__init__(registration).

    async execute(task: dict, context: dict) -> dict:
    Route by task["type"]:
    - "send_email" -> _handle_send_email(task, context)
    - "send_chat" -> _handle_send_chat(task, context)
    - "process_reply" -> _handle_process_reply(task, context)
    - "qualify" -> _handle_qualification(task, context)
    - "recommend_action" -> _handle_recommend_action(task, context)
    - Unknown -> raise ValueError

    async _compile_sales_context(task: dict, context: dict) -> dict:
    Compile rich context from all sources (Pattern 2 from research):
    1. Get tenant_id from context
    2. Load conversation state via state_repository.get_state(tenant_id, account_id, contact_id). Create new state if not found.
    3. Get conversation history from conversation_store.search_conversations(tenant_id, query=f"account:{account_id}", top_k=10)
    4. Get product/methodology knowledge via rag_pipeline.run(query=task.get("description", ""), tenant_id=tenant_id)
    5. Return compiled dict with: conversation_state, conversation_history, rag_response, persona, deal_stage, channel

    async _handle_send_email(task: dict, context: dict) -> dict:
    1. Compile context via _compile_sales_context()
    2. Build email prompt via build_email_prompt(persona, deal_stage, context_summary, task["description"])
    3. Call LLM to generate email content (subject + body_html)
    4. Send via gmail_service.send_email(EmailMessage(...))
    5. Update conversation state (increment interaction_count, set last_channel="email", last_interaction=now)
    6. Extract qualification signals from the generated email + any prior context
    7. Save updated state via state_repository.save_state()
    8. Check escalation via escalation_manager.evaluate_escalation(). If triggered, publish.
    9. Return {"status": "sent", "message_id": result.message_id, "thread_id": result.thread_id, "escalation": escalation_report or None}

    async _handle_send_chat(task: dict, context: dict) -> dict:
    Same flow as _handle_send_email but:
    - Uses build_chat_prompt() instead of build_email_prompt()
    - Sends via chat_service.send_message(ChatMessage(...))
    - Sets last_channel="chat"

    async _handle_process_reply(task: dict, context: dict) -> dict:
    For processing an incoming customer reply:
    1. Compile context
    2. Extract qualification signals from the customer reply text (task["reply_text"])
    3. Merge signals into existing state
    4. Evaluate escalation on the reply content
    5. Get recommended next actions via action_engine.recommend_actions()
    6. Save updated state
    7. Return {"status": "processed", "qualification_update": signals_dict, "next_actions": actions_list, "escalation": escalation_report or None}

    async _handle_qualification(task: dict, context: dict) -> dict:
    Force a qualification extraction on provided conversation text:
    1. Load state
    2. Extract signals from task["conversation_text"]
    3. Merge and save
    4. Return updated qualification state

    async _handle_recommend_action(task: dict, context: dict) -> dict:
    1. Load state
    2. Get recommendations via action_engine.recommend_actions(state)
    3. Return {"next_actions": [action.model_dump() for action in actions]}

    **src/app/agents/sales/__init__.py** -- Update exports:
    Export SalesAgent, create_sales_registration, SALES_AGENT_CAPABILITIES, and all schema types.

    **tests/test_sales_agent.py** -- Tests with mocked dependencies:
    - Mock all services (GmailService, ChatService, AgenticRAGPipeline, ConversationStore, SessionManager, ConversationStateRepository, QualificationExtractor, NextActionEngine, EscalationManager, LLMService)
    - Test execute() routes "send_email" task to _handle_send_email
    - Test execute() routes "send_chat" task to _handle_send_chat
    - Test execute() routes "process_reply" task to _handle_process_reply
    - Test execute() routes "recommend_action" to _handle_recommend_action
    - Test execute() raises ValueError for unknown task type
    - Test _handle_send_email calls gmail_service.send_email with EmailMessage
    - Test _handle_send_email updates conversation state (interaction_count, last_channel, last_interaction)
    - Test _handle_process_reply extracts qualification signals from reply text
    - Test _handle_process_reply gets next-action recommendations
    - Test escalation is checked after send_email and process_reply
    - Test create_sales_registration returns valid AgentRegistration with 5 capabilities
    - At least 10 tests
  </action>
  <verify>
    `python -c "from src.app.agents.sales import SalesAgent, create_sales_registration; print('SalesAgent import OK')"` succeeds.
    `python -c "from src.app.agents.sales.capabilities import create_sales_registration; r = create_sales_registration(); assert len(r.capabilities) == 5; print(f'{r.agent_id} with {len(r.capabilities)} capabilities')"` prints "sales_agent with 5 capabilities".
    `python -m pytest tests/test_sales_agent.py -v` passes all tests.
  </verify>
  <done>
    SalesAgent extends BaseAgent with execute() routing to send_email, send_chat, process_reply, qualify, and recommend_action handlers. Each handler compiles context from RAG + conversation history, generates persona-adapted messages via LLM, sends via GSuite, updates state with qualification extraction, checks escalation triggers, and returns structured results. create_sales_registration provides 5 capabilities for the agent registry. All 10+ tests pass with mocked dependencies.
  </done>
</task>

</tasks>

<verification>
1. SalesAgent extends BaseAgent and implements execute() with task routing
2. All 5 task types handled (send_email, send_chat, process_reply, qualify, recommend_action)
3. Context compilation uses RAG pipeline, conversation store, and state repository
4. Qualification signals extracted after every interaction (send_email, send_chat, process_reply)
5. Escalation checked after every interaction
6. NextActionEngine provides hybrid rule-based + LLM recommendations
7. EscalationManager checks all 4 triggers from CONTEXT.md
8. EscalationReport published via TenantEventBus
9. Tests pass with mocked dependencies
10. Agent registration provides 5 typed capabilities
</verification>

<success_criteria>
- SalesAgent class in src/app/agents/sales/agent.py composing all prior plan outputs
- NextActionEngine in actions.py with hybrid rule-based + LLM recommendation
- EscalationManager in escalation.py with 4 trigger types and structured reports
- 5 AgentCapability declarations in capabilities.py
- create_sales_registration() for agent registry integration
- Updated __init__.py with full exports
- 10+ tests passing with mocked dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/04-sales-agent-core/04-04-SUMMARY.md`
</output>
