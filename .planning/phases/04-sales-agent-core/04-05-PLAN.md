---
phase: 04-sales-agent-core
plan: 05
type: execute
wave: 4
depends_on: ["04-04"]
files_modified:
  - src/app/api/v1/sales.py
  - src/app/api/v1/__init__.py
  - src/app/main.py
  - tests/test_sales_integration.py
autonomous: true

must_haves:
  truths:
    - "Sales Agent is registered in the AgentRegistry on application startup"
    - "API endpoints exist for sending emails, sending chats, processing replies, and getting recommendations"
    - "All API endpoints require authentication and tenant context"
    - "SalesAgent can be invoked through the supervisor topology (not just direct API calls)"
    - "Integration test proves end-to-end flow: send email -> process reply -> extract qualification -> recommend action"
  artifacts:
    - path: "src/app/api/v1/sales.py"
      provides: "REST API endpoints for Sales Agent operations"
      exports: ["router"]
    - path: "tests/test_sales_integration.py"
      provides: "Integration tests for Sales Agent end-to-end flows"
      min_lines: 80
  key_links:
    - from: "src/app/api/v1/sales.py"
      to: "src/app/agents/sales/agent.py"
      via: "SalesAgent.invoke() for task execution"
      pattern: "sales_agent\\.invoke"
    - from: "src/app/main.py"
      to: "src/app/agents/sales/capabilities.py"
      via: "Agent registration during lifespan startup"
      pattern: "create_sales_registration|register"
    - from: "src/app/api/v1/sales.py"
      to: "src/app/api/deps.py"
      via: "Authentication and tenant context dependencies"
      pattern: "Depends.*get_current_user|get_tenant"
---

<objective>
Wire the Sales Agent into the FastAPI application with REST API endpoints and register it in the agent registry. Create integration tests proving the end-to-end flow works.

Purpose: This plan makes the Sales Agent accessible -- via API endpoints for direct use and via the supervisor topology for orchestrated use. SA-01 through SA-10 are validated through integration tests that exercise the complete pipeline.
Output: API router at /api/v1/sales/, agent registration in main.py lifespan, and integration tests.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-sales-agent-core/04-RESEARCH.md

@src/app/main.py
@src/app/api/v1/__init__.py
@src/app/api/deps.py
@src/app/agents/sales/__init__.py
@src/app/agents/sales/agent.py
@src/app/agents/sales/capabilities.py
@src/app/agents/registry.py
@src/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Sales API endpoints and request/response schemas</name>
  <files>
    src/app/api/v1/sales.py
    src/app/api/v1/__init__.py
  </files>
  <action>
    **src/app/api/v1/sales.py** -- FastAPI router for Sales Agent operations:

    Define request schemas (Pydantic):
    - SendEmailRequest: account_id (str), contact_id (str), contact_email (str), contact_name (str = ""), persona (str = "manager"), deal_stage (str = "discovery"), description (str), thread_id (str | None = None), in_reply_to (str | None = None)
    - SendChatRequest: account_id (str), contact_id (str), contact_name (str = ""), persona (str = "manager"), deal_stage (str = "discovery"), description (str), space_name (str), thread_key (str | None = None)
    - ProcessReplyRequest: account_id (str), contact_id (str), contact_email (str), reply_text (str), channel (str = "email")
    - GetRecommendationsRequest: account_id (str), contact_id (str)

    Define response schemas (Pydantic):
    - SendEmailResponse: status (str), message_id (str), thread_id (str), escalation (dict | None = None)
    - SendChatResponse: status (str), message_name (str), escalation (dict | None = None)
    - ProcessReplyResponse: status (str), qualification_update (dict), next_actions (list[dict]), escalation (dict | None = None)
    - RecommendationsResponse: next_actions (list[dict])
    - ConversationStateResponse: Mirrors ConversationState schema fields for GET endpoint

    Create router = APIRouter(prefix="/sales", tags=["sales"]):

    POST /sales/send-email:
    - Auth required (use existing deps)
    - Validates SendEmailRequest
    - Builds task dict: {"type": "send_email", "account_id": ..., "contact_id": ..., ...}
    - Builds context dict: {"tenant_id": from auth context}
    - Calls sales_agent.invoke(task, context)
    - Returns SendEmailResponse

    POST /sales/send-chat:
    - Same pattern, task type "send_chat"

    POST /sales/process-reply:
    - Same pattern, task type "process_reply"
    - Request includes reply_text from customer

    POST /sales/recommend-actions:
    - Same pattern, task type "recommend_action"
    - Returns RecommendationsResponse

    GET /sales/conversation-state/{account_id}/{contact_id}:
    - Auth required
    - Loads ConversationState from state_repository
    - Returns ConversationStateResponse (or 404 if not found)

    GET /sales/pipeline:
    - Auth required
    - Lists all conversation states for tenant, optionally filtered by deal_stage query param
    - Returns list[ConversationStateResponse]

    The SalesAgent instance should be obtained from a dependency function (e.g., get_sales_agent()) that returns the registered instance. This dependency can be set up in deps.py or as a module-level function that retrieves from AgentRegistry.

    **src/app/api/v1/__init__.py** -- Update to include sales router:
    Import and include the sales router in the v1 router. Follow existing pattern for other routers in this file.
  </action>
  <verify>
    `python -c "from src.app.api.v1.sales import router; print(f'{len(router.routes)} routes registered')"` prints route count (should be 6: POST send-email, POST send-chat, POST process-reply, POST recommend-actions, GET conversation-state, GET pipeline).
  </verify>
  <done>
    6 API endpoints registered under /api/v1/sales/. All endpoints require authentication and tenant context. Request/response schemas validated via Pydantic. Sales agent obtained via dependency injection from registry.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register Sales Agent in main.py lifespan and create integration tests</name>
  <files>
    src/app/main.py
    tests/test_sales_integration.py
  </files>
  <action>
    **src/app/main.py** -- Add Sales Agent initialization to lifespan:

    In the existing lifespan async context manager (follow the per-module try/except pattern from 02-06):
    1. Import create_sales_registration, SalesAgent, and all required service constructors
    2. Wrap in try/except for Phase 4 init resilience:
       ```python
       try:
           # Sales Agent initialization
           from src.app.agents.sales import SalesAgent, create_sales_registration
           from src.app.agents.sales.qualification import QualificationExtractor
           from src.app.agents.sales.actions import NextActionEngine
           from src.app.agents.sales.escalation import EscalationManager
           from src.app.agents.sales.state_repository import ConversationStateRepository
           from src.app.services.gsuite import GSuiteAuthManager, GmailService, ChatService

           settings = get_settings()
           registration = create_sales_registration()

           # GSuite services (may not be configured in dev - graceful handling)
           gsuite_auth = None
           gmail_service = None
           chat_service = None
           if settings.GOOGLE_SERVICE_ACCOUNT_FILE:
               gsuite_auth = GSuiteAuthManager(
                   service_account_file=settings.GOOGLE_SERVICE_ACCOUNT_FILE,
                   delegated_user_email=settings.GOOGLE_DELEGATED_USER_EMAIL,
               )
               gmail_service = GmailService(auth_manager=gsuite_auth, default_user_email=settings.GOOGLE_DELEGATED_USER_EMAIL)
               chat_service = ChatService(auth_manager=gsuite_auth)

           # State, qualification, actions, escalation
           state_repo = ConversationStateRepository(session_factory=get_session_factory())
           qual_extractor = QualificationExtractor(llm_service=llm_service)
           action_engine = NextActionEngine(llm_service=llm_service)
           escalation_mgr = EscalationManager(event_bus=event_bus, llm_service=llm_service)

           sales_agent = SalesAgent(
               registration=registration,
               llm_service=llm_service,
               gmail_service=gmail_service,
               chat_service=chat_service,
               rag_pipeline=rag_pipeline,
               conversation_store=conversation_store,
               session_manager=session_manager,
               state_repository=state_repo,
               qualification_extractor=qual_extractor,
               action_engine=action_engine,
               escalation_manager=escalation_mgr,
           )

           # Register in agent registry
           agent_registry.register(registration)
           registration._agent_instance = sales_agent  # Per 02-05 pattern
           logger.info("sales_agent_initialized")
       except Exception as exc:
           logger.warning("sales_agent_init_failed", error=str(exc))
       ```

    IMPORTANT: Follow existing per-module try/except pattern. If GSuite credentials not configured, still initialize the agent but gmail_service/chat_service will be None -- agent methods should handle gracefully (return error for send tasks if services unavailable).

    IMPORTANT: Reference existing variables from prior init blocks (llm_service, event_bus, rag_pipeline, conversation_store, session_manager, agent_registry). Check main.py for their actual variable names.

    **tests/test_sales_integration.py** -- Integration tests (mocked external services):

    Test setup: Create SalesAgent with mocked GmailService, ChatService, RAG pipeline, ConversationStore, and LLMService. Use real (or in-memory mock) state repository.

    Tests:
    1. **test_send_email_flow**: Create SalesAgent with mocks. Call invoke({"type": "send_email", ...}, {"tenant_id": "test"}). Verify:
       - gmail_service.send_email was called with EmailMessage
       - State was saved (interaction_count > 0, last_channel = "email")
       - Qualification extraction was attempted
       - Result has "status": "sent"

    2. **test_send_chat_flow**: Same as above but type="send_chat", verify chat_service.send_message called

    3. **test_process_reply_extracts_qualification**: Call invoke({"type": "process_reply", "reply_text": "Our budget is around $200k and we need this by Q3", ...}). Verify:
       - Qualification extractor was called with the reply text
       - Result contains qualification_update
       - Result contains next_actions

    4. **test_escalation_triggers_on_low_confidence**: Set up state with confidence_score=0.5 (below 0.7 threshold). Process a reply. Verify escalation_manager.evaluate_escalation was called and escalation event published.

    5. **test_escalation_triggers_on_customer_request**: Process reply with text containing "can I speak to someone on your team?". Verify escalation triggered.

    6. **test_recommend_action_for_new_conversation**: Call invoke({"type": "recommend_action", ...}) with fresh state (interaction_count=0). Verify returns initial outreach action.

    7. **test_recommend_action_for_stale_deal**: Set up state with last_interaction 10 days ago. Verify returns follow-up action.

    8. **test_agent_registration**: Verify create_sales_registration() produces valid registration with 5 capabilities, correct agent_id, correct tags.

    9. **test_persona_affects_email_content**: Mock LLM to return different content. Verify build_system_prompt is called with correct persona (IC vs C_SUITE).

    10. **test_context_compilation**: Verify _compile_sales_context calls rag_pipeline.run, conversation_store.search_conversations, and state_repository.get_state.

    At least 10 integration tests covering the major flows.
  </action>
  <verify>
    `python -m pytest tests/test_sales_integration.py -v` passes all tests.
    `python -m pytest tests/ -v --timeout=60` -- All existing tests still pass (no regressions).
    `python -c "from src.app.main import create_app; print('App creation OK')"` succeeds (agent init may warn if no GSuite creds, but app creates).
  </verify>
  <done>
    Sales Agent registered in main.py lifespan with per-module try/except resilience. GSuite services gracefully handle missing credentials (None services, agent methods return error). 10+ integration tests prove: email sending, chat sending, reply processing with qualification extraction, escalation triggers (low confidence, customer request), next-action recommendations (new conversation, stale deal), agent registration, persona differentiation, and context compilation. All existing tests continue to pass.
  </done>
</task>

</tasks>

<verification>
1. Sales API endpoints registered at /api/v1/sales/
2. All endpoints require auth and tenant context
3. SalesAgent registered in AgentRegistry during lifespan
4. App starts successfully even without GSuite credentials (graceful degradation)
5. Integration tests cover: send_email, send_chat, process_reply, escalation, next_actions
6. No regression in existing test suite
7. Sales agent accessible via both direct API and supervisor topology
</verification>

<success_criteria>
- 6 API endpoints in src/app/api/v1/sales.py (2 GET, 4 POST)
- Sales router included in v1 API router
- SalesAgent initialized and registered in main.py lifespan
- Graceful handling when GSuite credentials not configured
- 10+ integration tests passing
- All existing tests passing (no regressions)
- Full pipeline proven: email -> reply -> qualification -> recommendation -> escalation
</success_criteria>

<output>
After completion, create `.planning/phases/04-sales-agent-core/04-05-SUMMARY.md`
</output>
