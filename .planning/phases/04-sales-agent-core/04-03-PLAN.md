---
phase: 04-sales-agent-core
plan: 03
type: execute
wave: 2
depends_on: ["04-02"]
files_modified:
  - src/app/models/sales.py
  - alembic/versions/add_sales_conversation_state.py
  - src/app/agents/sales/state_repository.py
  - src/app/agents/sales/qualification.py
  - tests/test_sales_state.py
autonomous: true

must_haves:
  truths:
    - "Conversation state persists to PostgreSQL and survives application restarts"
    - "Qualification signals merge incrementally -- new extraction does not overwrite existing evidence"
    - "State can be loaded by tenant_id + account_id + contact_id for conversation continuity"
    - "Structured LLM extraction via instructor produces valid BANTSignals + MEDDICSignals from conversation text"
    - "Deal stage transitions follow defined rules (e.g., cannot jump from PROSPECTING to NEGOTIATION)"
  artifacts:
    - path: "src/app/models/sales.py"
      provides: "SQLAlchemy ConversationStateModel for tenant-scoped persistence"
      contains: "class ConversationStateModel"
    - path: "src/app/agents/sales/state_repository.py"
      provides: "CRUD + merge operations for conversation state"
      exports: ["ConversationStateRepository"]
    - path: "src/app/agents/sales/qualification.py"
      provides: "LLM-powered qualification signal extraction and merge logic"
      exports: ["QualificationExtractor", "merge_qualification_signals"]
  key_links:
    - from: "src/app/agents/sales/state_repository.py"
      to: "src/app/models/sales.py"
      via: "SQLAlchemy queries on ConversationStateModel"
      pattern: "ConversationStateModel"
    - from: "src/app/agents/sales/qualification.py"
      to: "src/app/agents/sales/schemas.py"
      via: "Returns QualificationState with BANTSignals + MEDDICSignals"
      pattern: "QualificationState|BANTSignals|MEDDICSignals"
    - from: "src/app/agents/sales/qualification.py"
      to: "instructor"
      via: "Structured LLM output extraction"
      pattern: "instructor"
---

<objective>
Create conversation state persistence (PostgreSQL + repository) and qualification signal extraction (instructor + LiteLLM) for the Sales Agent.

Purpose: SA-08 (conversation state tracking) requires persistent state across interactions. SA-06 (BANT) and SA-07 (MEDDIC) require extracting qualification signals from conversations. This plan delivers the state persistence layer and the LLM-powered qualification extraction that the SalesAgent class will compose in Plan 04.
Output: ConversationStateModel (SQLAlchemy), ConversationStateRepository (async CRUD), QualificationExtractor (instructor-based), and merge logic.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-sales-agent-core/04-RESEARCH.md

@src/app/models/tenant.py
@src/app/core/database.py
@src/app/agents/sales/schemas.py
@src/app/services/llm.py
@src/app/agents/sales/prompts.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conversation state database model and Alembic migration</name>
  <files>
    src/app/models/sales.py
    alembic/versions/add_sales_conversation_state.py
    src/app/agents/sales/state_repository.py
    tests/test_sales_state.py
  </files>
  <action>
    **src/app/models/sales.py** -- SQLAlchemy model for conversation state persistence:

    Create ConversationStateModel(TenantBase) following the pattern in src/app/models/tenant.py:
    - __tablename__ = "conversation_states"
    - __table_args__ = (UniqueConstraint("tenant_id", "account_id", "contact_id", name="uq_conversation_state_tenant_account_contact"), {"schema": "tenant"})
    - id: UUID primary key with gen_random_uuid() default
    - tenant_id: UUID, not null
    - account_id: String(100), not null
    - contact_id: String(100), not null
    - contact_email: String(255), not null
    - contact_name: String(200), nullable
    - deal_stage: String(50), default="prospecting"
    - persona_type: String(20), default="manager"
    - qualification_data: JSON, default={} (stores serialized QualificationState)
    - interaction_count: Integer, default=0
    - last_interaction: DateTime(timezone=True), nullable
    - last_channel: String(20), nullable
    - escalated: Boolean, default=False
    - escalation_reason: String(500), nullable
    - confidence_score: Float, default=0.5
    - next_actions: JSON, default=[] (stores serialized list of NextAction dicts)
    - follow_up_scheduled: DateTime(timezone=True), nullable
    - metadata_json: JSON, default={} (avoid name collision with SQLAlchemy metadata)
    - created_at: DateTime(timezone=True), server_default=func.now()
    - updated_at: DateTime(timezone=True), onupdate=func.now(), nullable

    **alembic/versions/add_sales_conversation_state.py** -- Migration:
    - Branch label: "tenant" (consistent with existing tenant migration chain)
    - Depends on: the last tenant migration revision (check alembic/versions/ for latest)
    - Creates conversation_states table in tenant schema
    - Adds index on (tenant_id, account_id) for fast lookup
    - Adds index on (tenant_id, deal_stage) for pipeline queries

    **src/app/agents/sales/state_repository.py** -- ConversationStateRepository:
    - __init__(session_factory): Takes async SQLAlchemy session factory
    - async get_state(tenant_id: str, account_id: str, contact_id: str) -> ConversationState | None:
      Queries ConversationStateModel by tenant_id + account_id + contact_id. Converts DB model to Pydantic ConversationState (deserialize qualification_data into QualificationState, next_actions into list[NextAction]).
    - async save_state(state: ConversationState) -> ConversationState:
      Upserts ConversationStateModel. Serializes QualificationState to JSON for qualification_data field. Uses merge() for upsert semantics.
    - async list_states_by_tenant(tenant_id: str, deal_stage: str | None = None) -> list[ConversationState]:
      Lists all conversation states for a tenant, optionally filtered by deal stage.
    - async update_qualification(tenant_id: str, account_id: str, contact_id: str, new_signals: QualificationState) -> ConversationState:
      Loads existing state, calls merge_qualification_signals (from qualification.py), saves merged result. This avoids Pitfall 3 (overwriting existing signals).
    - Helper _model_to_state(model: ConversationStateModel) -> ConversationState: Converts DB row to Pydantic model.
    - Helper _state_to_model(state: ConversationState) -> dict: Converts Pydantic model to DB-ready dict.

    **tests/test_sales_state.py** -- Unit tests (mock database):
    - Test ConversationStateModel can be instantiated with all fields
    - Test _model_to_state correctly deserializes qualification_data JSON into QualificationState
    - Test _state_to_model correctly serializes QualificationState to JSON
    - Test DealStage transitions are valid (define VALID_TRANSITIONS dict in state_repository.py):
      - PROSPECTING -> DISCOVERY
      - DISCOVERY -> QUALIFICATION
      - QUALIFICATION -> EVALUATION
      - EVALUATION -> NEGOTIATION
      - NEGOTIATION -> CLOSED_WON, CLOSED_LOST
      - Any stage -> STALLED
      - STALLED -> any previous stage (resume)
      Cannot skip stages (PROSPECTING cannot jump to NEGOTIATION)
    - Test list_states_by_tenant filters by deal_stage correctly
    - At least 6 tests
  </action>
  <verify>
    `python -c "from src.app.models.sales import ConversationStateModel; print('Model import OK')"` succeeds.
    `python -c "from src.app.agents.sales.state_repository import ConversationStateRepository; print('Repo import OK')"` succeeds.
    `python -m pytest tests/test_sales_state.py -v` passes all tests.
  </verify>
  <done>
    ConversationStateModel persists to tenant-scoped PostgreSQL table with qualification_data JSON, indexed on (tenant_id, account_id) and (tenant_id, deal_stage). ConversationStateRepository provides get/save/list/update_qualification operations with proper JSON serialization/deserialization. Deal stage transitions are validated. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create qualification signal extraction with instructor + merge logic</name>
  <files>
    src/app/agents/sales/qualification.py
  </files>
  <action>
    **src/app/agents/sales/qualification.py** -- Structured LLM extraction for qualification signals:

    1. **merge_bant_signals(existing: BANTSignals, new: BANTSignals) -> BANTSignals**:
       For each field (budget, authority, need, timeline): Only update if new value has higher confidence OR new value is identified and existing is not. Always append new evidence (don't replace). This prevents Pitfall 3 (overwriting existing qualification data).

    2. **merge_meddic_signals(existing: MEDDICSignals, new: MEDDICSignals) -> MEDDICSignals**:
       Same merge logic as BANT. For list fields (decision_criteria), extend with new unique items. For contact fields (economic_buyer_contact, champion_contact), prefer non-None.

    3. **merge_qualification_signals(existing: QualificationState, new: QualificationState) -> QualificationState**:
       Merges BANT and MEDDIC separately. Takes max of confidence scores. Extends key_insights (deduplicate). Replaces recommended_next_questions with new ones (these are always fresh). Updates last_updated timestamp.

    4. **QualificationExtractor** class:
       - __init__(llm_service: LLMService): Stores reference to existing LLM service from Phase 1.
       - async extract_signals(conversation_text: str, existing_state: QualificationState | None = None) -> QualificationState:
         Uses instructor library with LiteLLM to extract structured QualificationState from conversation text.

         Implementation:
         a. Build extraction prompt using build_qualification_extraction_prompt() from prompts.py
         b. Create instructor client: `instructor.from_litellm(litellm.acompletion)` (async)
         c. Call client.chat.completions.create() with:
            - model: use LLM service's model config (Claude Sonnet 4 via LiteLLM)
            - response_model: QualificationState
            - messages: from build_qualification_extraction_prompt()
            - Pass existing_state as context in the prompt so LLM knows what's already known
         d. If existing_state provided, merge new extraction with existing using merge_qualification_signals()
         e. On extraction failure (LLM error, schema violation after retries), return existing_state unchanged (fail-open, consistent with 02-03 pattern)
         f. Log extraction results and any merge operations via structlog

    IMPORTANT: Use a single LLM call to extract ALL BANT + MEDDIC signals simultaneously (anti-pattern from research: do NOT make separate calls per field).

    IMPORTANT: instructor works with LiteLLM via `instructor.from_litellm(litellm.acompletion)`. Check the instructor docs pattern. The model string should be the LiteLLM model identifier (e.g., "anthropic/claude-sonnet-4-20250514"). Use the model from Settings or a parameter.
  </action>
  <verify>
    `python -c "from src.app.agents.sales.qualification import QualificationExtractor, merge_qualification_signals, merge_bant_signals, merge_meddic_signals; print('All qualification imports OK')"` succeeds.
    `python -c "
from src.app.agents.sales.schemas import BANTSignals
from src.app.agents.sales.qualification import merge_bant_signals
existing = BANTSignals(budget_identified=True, budget_range='100k', budget_confidence=0.8)
new = BANTSignals(budget_identified=True, budget_range='200k', budget_confidence=0.6, need_identified=True, need_description='Reduce costs')
merged = merge_bant_signals(existing, new)
assert merged.budget_range == '100k', 'Should keep higher confidence budget'
assert merged.need_identified == True, 'Should add new need signal'
print('Merge logic OK')
"` prints "Merge logic OK".
  </verify>
  <done>
    QualificationExtractor uses instructor + LiteLLM to extract structured BANT + MEDDIC signals in a single LLM call. merge_qualification_signals implements incremental merge: new signals only override existing when confidence is higher, evidence is never lost, list fields extend rather than replace. Fail-open on LLM errors returns existing state unchanged. All merge functions are pure and independently testable.
  </done>
</task>

</tasks>

<verification>
1. ConversationStateModel follows existing TenantBase pattern with schema="tenant"
2. Alembic migration creates table with proper indexes
3. Repository serializes/deserializes QualificationState to/from JSON correctly
4. merge_qualification_signals preserves existing high-confidence data
5. QualificationExtractor uses instructor + LiteLLM for structured extraction
6. Fail-open pattern: LLM errors return existing state unchanged
7. Deal stage transitions are validated (no illegal jumps)
8. Tests pass
</verification>

<success_criteria>
- ConversationStateModel in src/app/models/sales.py with all state fields
- Alembic migration for conversation_states table
- ConversationStateRepository with get/save/list/update_qualification
- QualificationExtractor extracts BANT + MEDDIC in single LLM call via instructor
- merge_qualification_signals merges incrementally (never overwrites higher-confidence data)
- Fail-open on LLM extraction errors
- Valid deal stage transitions enforced
- Tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/04-sales-agent-core/04-03-SUMMARY.md`
</output>
