---
phase: 13-technical-account-manager-agent
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/app/agents/technical_account_manager/notion_tam.py
  - src/app/agents/technical_account_manager/health_scorer.py
  - src/app/agents/technical_account_manager/ticket_client.py
  - src/app/agents/technical_account_manager/scheduler.py
  - src/app/services/gsuite/gmail.py
autonomous: true

must_haves:
  truths:
    - "NotionTAMAdapter creates relationship profile sub-pages under account pages"
    - "Block renderers are module-level functions decoupled from adapter class"
    - "HealthScorer computes deterministic 0-100 score from 3 signal categories (no LLM)"
    - "TicketClient abstracts Notion DB queries for ticket data"
    - "TAMScheduler runs daily health scan at 7am and monthly check-ins on 1st"
    - "GmailService.create_draft creates email drafts (not sends)"
  artifacts:
    - path: "src/app/agents/technical_account_manager/notion_tam.py"
      provides: "NotionTAMAdapter + module-level block renderers for relationship profiles"
      exports: ["NotionTAMAdapter", "render_relationship_profile_blocks", "render_health_dashboard_blocks", "render_communication_log_blocks"]
      min_lines: 150
    - path: "src/app/agents/technical_account_manager/health_scorer.py"
      provides: "Pure Python health scoring algorithm with configurable thresholds"
      exports: ["HealthScorer"]
    - path: "src/app/agents/technical_account_manager/ticket_client.py"
      provides: "Ticket data access abstraction reading from Notion DB"
      exports: ["TicketClient"]
    - path: "src/app/agents/technical_account_manager/scheduler.py"
      provides: "APScheduler wrapper for daily scan + monthly check-ins"
      exports: ["TAMScheduler"]
    - path: "src/app/services/gsuite/gmail.py"
      provides: "New create_draft method on existing GmailService"
      contains: "create_draft"
  key_links:
    - from: "src/app/agents/technical_account_manager/notion_tam.py"
      to: "src/app/agents/technical_account_manager/schemas.py"
      via: "imports domain models for block rendering"
      pattern: "from src.app.agents.technical_account_manager.schemas import"
    - from: "src/app/agents/technical_account_manager/health_scorer.py"
      to: "src/app/agents/technical_account_manager/schemas.py"
      via: "returns HealthScoreResult"
      pattern: "HealthScoreResult"
    - from: "src/app/agents/technical_account_manager/ticket_client.py"
      to: "src/app/agents/technical_account_manager/schemas.py"
      via: "returns list[TicketSummary]"
      pattern: "TicketSummary"
    - from: "src/app/services/gsuite/gmail.py"
      to: "Gmail API drafts.create"
      via: "asyncio.to_thread wrapper"
      pattern: "drafts.*create"
---

<objective>
Build the TAM agent's supporting infrastructure: NotionTAMAdapter for relationship profiles, HealthScorer for deterministic health scoring, TicketClient for ticket data abstraction, TAMScheduler for background tasks, and the new GmailService.create_draft method.

Purpose: These are the specialized building blocks the TAM agent handlers depend on. The health scorer is the critical differentiator (pure Python, no LLM), and create_draft is the new Gmail capability that enables the TAM's draft-only communication pattern.
Output: notion_tam.py, health_scorer.py, ticket_client.py, scheduler.py, updated gmail.py
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-technical-account-manager-agent/13-CONTEXT.md
@.planning/phases/13-technical-account-manager-agent/13-RESEARCH.md

# Pattern references -- clone these structures
@src/app/agents/project_manager/notion_pm.py
@src/app/agents/project_manager/scheduler.py
@src/app/agents/business_analyst/notion_ba.py
@src/app/services/gsuite/gmail.py

# Dependencies from plan 01
@src/app/agents/technical_account_manager/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HealthScorer, TicketClient, and GmailService.create_draft</name>
  <files>
    src/app/agents/technical_account_manager/health_scorer.py
    src/app/agents/technical_account_manager/ticket_client.py
    src/app/services/gsuite/gmail.py
  </files>
  <action>
**health_scorer.py** -- CRITICAL: Pure Python only. No LLM calls.

```python
"""Pure Python health scoring algorithm for TAM agent.

Computes a deterministic 0-100 health score from three signal categories:
1. P1/P2 ticket age
2. Open ticket volume
3. Integration heartbeat silence

IMPORTANT: Do NOT use LLM for score computation. The score is a deterministic
numeric calculation. LLM adds latency, cost, and non-determinism for zero benefit.
"""
```

Define `HealthScorer` class with configurable thresholds:
- `P1_P2_AGE_THRESHOLD_DAYS: int = 3` (P1/P2 tickets older than this = at risk)
- `OPEN_TICKET_COUNT_THRESHOLD: int = 5` (more than this = at risk)
- `HEARTBEAT_SILENCE_HOURS: int = 72` (no heartbeat for this long = at risk)
- `RED_THRESHOLD: int = 40`
- `AMBER_THRESHOLD: int = 70`
- `ESCALATION_THRESHOLD: int = 40`

Constructor accepts optional keyword overrides for all thresholds: `__init__(self, *, p1_p2_age_threshold_days: int = 3, ...)` so thresholds can be customized per-tenant.

Method `compute_score(self, p1_p2_ticket_count: int, oldest_p1_p2_age_days: float, total_open_tickets: int, hours_since_heartbeat: float | None) -> tuple[int, str]`:
- Start at 100 (perfect health)
- P1/P2 ticket age penalty: if oldest_p1_p2_age_days > threshold, deduct p1_p2_ticket_count * 20 points
- Open ticket volume penalty: deduct (excess tickets) * 5 where excess = max(0, total_open - threshold)
- Heartbeat silence penalty: if hours_since_heartbeat is None, no penalty (not monitored). If > 2x threshold, deduct 30. If > threshold, deduct 15.
- Floor at 0, ceiling at 100
- Derive RAG: score < RED_THRESHOLD -> "Red", score < AMBER_THRESHOLD -> "Amber", else "Green"
- Return (score, rag_status)

Method `should_escalate(self, current_score: int, current_rag: str, previous_rag: str | None) -> bool`:
- Returns True if: current_score < ESCALATION_THRESHOLD, OR (previous_rag != "Red" and current_rag == "Red"), OR (previous_rag == "Green" and current_rag == "Amber")
- Returns False otherwise

Include `__all__ = ["HealthScorer"]`.

**ticket_client.py** -- Abstraction layer for ticket data. Reads from Notion DB (pre-synced approach per RESEARCH.md decision).

```python
"""Ticket data access abstraction for TAM agent.

Reads from a Notion "Support Tickets" database where tickets are pre-synced
from Kayako/Jira via an external process. This avoids new external API
dependencies and keeps all data in Notion (unified data layer).

The sync script that populates this Notion database is outside TAM agent scope.
"""
```

Define `TicketClient` class:
- Constructor: `__init__(self, notion_client: AsyncClient, tickets_database_id: str)` -- takes pre-authenticated AsyncClient (same pattern as NotionPMAdapter/NotionBAAdapter). Graceful import of AsyncClient with fallback placeholder if notion_client not installed.
- `async def get_open_tickets(self, account_id: str) -> list[TicketSummary]`:
  - Query Notion DB with filter: Account == account_id AND Status in ["open", "pending"]
  - Parse results into TicketSummary models
  - Return sorted by created_at descending
  - Retry-wrapped with tenacity: `@retry(retry=retry_if_exception_type(Exception), stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=1, max=10))`
- `async def get_p1_p2_tickets(self, account_id: str) -> list[TicketSummary]`:
  - Query Notion DB with filter: Account == account_id AND Priority in ["P1", "P2"] AND Status in ["open", "pending"]
  - Parse results into TicketSummary models
  - Return sorted by age_days descending
  - Retry-wrapped
- `async def get_ticket_count_by_account(self, account_id: str) -> int`:
  - Query count of open tickets for account
  - Retry-wrapped

Import TicketSummary from schemas. Handle datetime parsing for age_days computation (age_days = (now_utc - created_at).total_seconds() / 86400).

Include `__all__ = ["TicketClient"]`.

**gmail.py** -- Add `create_draft` method to the EXISTING GmailService class. Read the file first, then add the method AFTER the existing `send_email` method.

New method follows the same pattern as `send_email` but uses `drafts().create()` instead of `messages().send()`:

```python
async def create_draft(
    self,
    email: EmailMessage,
    user_email: str | None = None,
) -> dict[str, Any]:
    """Create a Gmail draft in the user's inbox.

    TAM agent uses this for all communications -- drafts are reviewed by
    the rep before sending. This ensures TAM never sends autonomously.

    Args:
        email: The EmailMessage with content and headers.
        user_email: Sender email (for delegation). Defaults to
            the configured default_user_email.

    Returns:
        Dict with draft_id and message dict from Gmail API.
    """
    sender = user_email or self._default_user_email
    service = self._auth.get_gmail_service(sender)
    raw = self._build_mime_message(email)

    body: dict[str, Any] = {"message": {"raw": raw}}
    if email.thread_id:
        body["message"]["threadId"] = email.thread_id

    def _create() -> dict:
        return (
            service.users()
            .drafts()
            .create(userId="me", body=body)
            .execute()
        )

    logger.info(
        "creating_draft",
        to=email.to,
        subject=email.subject,
        thread_id=email.thread_id,
    )
    result = await asyncio.to_thread(_create)

    return {
        "draft_id": result.get("id", ""),
        "message": result.get("message", {}),
    }
```

Do NOT change any existing methods in gmail.py. Only ADD the new `create_draft` method.
  </action>
  <verify>
Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "
from src.app.agents.technical_account_manager.health_scorer import HealthScorer
scorer = HealthScorer()

# Test perfect health
score, rag = scorer.compute_score(0, 0.0, 3, 48.0)
assert score == 100 and rag == 'Green', f'Expected 100/Green, got {score}/{rag}'

# Test P1/P2 ticket penalty
score, rag = scorer.compute_score(2, 5.0, 3, 48.0)
assert score == 60, f'Expected 60 (100 - 2*20), got {score}'

# Test heartbeat silence penalty
score, rag = scorer.compute_score(0, 0.0, 3, 150.0)
assert score == 70, f'Expected 70 (100 - 30 for 2x silence), got {score}'

# Test None heartbeat = no penalty
score, rag = scorer.compute_score(0, 0.0, 3, None)
assert score == 100, f'Expected 100 with None heartbeat, got {score}'

# Test escalation logic
assert scorer.should_escalate(35, 'Red', 'Amber') == True
assert scorer.should_escalate(60, 'Amber', 'Green') == True
assert scorer.should_escalate(85, 'Green', 'Green') == False
print('HealthScorer all tests pass')
"` -- must succeed.

Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "
from src.app.agents.technical_account_manager.ticket_client import TicketClient
import inspect
assert inspect.iscoroutinefunction(TicketClient.get_open_tickets)
assert inspect.iscoroutinefunction(TicketClient.get_p1_p2_tickets)
print('TicketClient imports OK, async methods present')
"` -- must succeed.

Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "
from src.app.services.gsuite.gmail import GmailService
assert hasattr(GmailService, 'create_draft'), 'GmailService missing create_draft'
assert hasattr(GmailService, 'send_email'), 'send_email still exists'
import inspect
assert inspect.iscoroutinefunction(GmailService.create_draft)
print('GmailService.create_draft exists and is async')
"` -- must succeed.
  </verify>
  <done>
HealthScorer computes deterministic 0-100 score with configurable thresholds (no LLM). TicketClient queries Notion DB for ticket data with retry. GmailService has new create_draft method for TAM's draft-only communication pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create NotionTAMAdapter and TAMScheduler</name>
  <files>
    src/app/agents/technical_account_manager/notion_tam.py
    src/app/agents/technical_account_manager/scheduler.py
  </files>
  <action>
**notion_tam.py** -- Follow the NotionBAAdapter pattern with module-level block renderers.

**Imports and graceful notion-client handling** -- same pattern as notion_ba.py:
```python
from __future__ import annotations
from datetime import datetime, timezone
from typing import Any
import structlog
from tenacity import retry, retry_if_exception_type, stop_after_attempt, wait_exponential

from src.app.agents.technical_account_manager.schemas import (
    StakeholderProfile, IntegrationStatus, FeatureAdoption,
    CommunicationRecord, CoDevOpportunity, RelationshipProfile,
    HealthScoreResult,
)

try:
    from notion_client import AsyncClient
except ImportError as _import_err:
    # Placeholder so the module can be imported without notion-client installed
    class AsyncClient:  # type: ignore[no-redef]
        pass
```

**Module-level block renderer functions** (decoupled from adapter class):

1. `render_relationship_profile_blocks(profile: RelationshipProfile) -> list[dict]`:
   - Heading 2: f"Technical Relationship Profile - {profile.account_name}"
   - Heading 3: "Stakeholder Map" -- table or bulleted list of stakeholders with name, role, maturity
   - Heading 3: "Integration Depth" -- bulleted list of integrations with active/inactive status
   - Heading 3: "Feature Adoption" -- bulleted list of features with adopted status and source
   - Heading 3: "Customer Environment" -- bulleted list of known apps/systems
   - Heading 3: "Co-Development Opportunities" -- bulleted list with status

2. `render_health_dashboard_blocks(health_score: HealthScoreResult) -> list[dict]`:
   - Heading 3: "Health Dashboard"
   - Paragraph: f"Current Score: {health_score.score}/100 | Status: {health_score.rag_status}"
   - Paragraph: f"Last Scan: {health_score.scan_timestamp.strftime('%Y-%m-%d %H:%M UTC')}"
   - If previous_score: Paragraph with trend (improving/stable/declining based on score delta)
   - Callout block for escalation warning if should_escalate is True

3. `render_communication_log_blocks(records: list[CommunicationRecord]) -> list[dict]`:
   - Heading 3: "Communication History"
   - Bulleted list: each record as "{date} | {type} | {subject} | Outcome: {outcome}"

**Notion block helpers** (internal, same as notion_ba.py):
- `_heading_block(text, level)`, `_paragraph_block(text)`, `_bulleted_list_block(text)`, `_callout_block(text, emoji)`

**NotionTAMAdapter class:**

Constructor: `__init__(self, client: AsyncClient, accounts_database_id: str | None = None)` -- pre-authenticated AsyncClient.

Methods (all retry-wrapped with tenacity):

1. `async def create_relationship_profile(self, account_page_id: str, profile: RelationshipProfile) -> str`:
   - Create sub-page under account page with relationship profile content
   - Use render_relationship_profile_blocks + render_health_dashboard_blocks
   - Handle 100-block limit: create page with first 100 blocks, append rest in batches
   - Return page_id (UUID), matching NotionPMAdapter/NotionBAAdapter return pattern

2. `async def update_health_score(self, account_page_id: str, score: int, rag_status: str) -> None`:
   - Update account page properties: "Health Score" (number), "Health Status" (select), "Last Health Scan" (date)
   - Uses `self._client.pages.update(page_id=account_page_id, properties={...})`

3. `async def append_communication_log(self, profile_page_id: str, record: CommunicationRecord) -> None`:
   - Append communication record blocks to the relationship profile sub-page
   - Uses render_communication_log_blocks for a single record

4. `async def query_all_accounts(self) -> list[dict]`:
   - Query accounts database for all active accounts
   - Returns list of account dicts with id, name, properties (health_score, health_rag, last_heartbeat, hours_since_heartbeat)
   - Used by the daily health scan

5. `async def get_relationship_profile_page(self, account_page_id: str) -> str | None`:
   - Find the "Technical Relationship Profile" sub-page under an account page
   - Returns page_id if found, None otherwise

Include `__all__` listing all exports.

**scheduler.py** -- Clone PMScheduler pattern exactly.

```python
"""Background scheduler for TAM agent health scans and health check-ins.

Provides a lightweight APScheduler wrapper:
- Daily health scan at 7:00 AM (iterates all accounts)
- Monthly health check-ins on 1st of month at 10:00 AM

APScheduler is an optional dependency -- if not installed, start() returns False.
"""
```

Define `TAMScheduler` class:

Constructor: `__init__(self, tam_agent: object, notion_tam: object | None = None)`.

`start(self) -> bool`:
- Same graceful APScheduler import pattern as PMScheduler
- Add two cron jobs:
  1. Daily health scan: `CronTrigger(hour=7, minute=0)`, id="tam_daily_health_scan", misfire_grace_time=3600
  2. Monthly health check-ins: `CronTrigger(day=1, hour=10, minute=0)`, id="tam_monthly_health_checkins", misfire_grace_time=7200
- Return True if started, False if APScheduler not available

`async def _daily_health_scan(self)`:
- Log "tam_daily_health_scan_triggered"
- Call `self._tam_agent.execute({"type": "health_scan"}, context={})` for a batch scan of all accounts
- Log results (success count, escalation count)
- Rate-limit escalation alerts: max 5 per scan, bundle remaining into summary

`async def _monthly_health_checkins(self)`:
- Log "tam_monthly_checkins_triggered"
- Query all accounts via notion_tam
- For each account, call `self._tam_agent.execute({"type": "health_checkin", "account_id": acct_id}, context={})`
- Individual failures don't block other accounts (same pattern as PMScheduler)
- Log results

`stop(self)`: Same as PMScheduler.

Include `__all__ = ["TAMScheduler"]`.
  </action>
  <verify>
Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "
from src.app.agents.technical_account_manager.notion_tam import (
    NotionTAMAdapter,
    render_relationship_profile_blocks,
    render_health_dashboard_blocks,
    render_communication_log_blocks,
)
from src.app.agents.technical_account_manager.schemas import (
    RelationshipProfile, HealthScoreResult, CommunicationRecord,
    StakeholderProfile, IntegrationStatus,
)

# Test profile renderer
profile = RelationshipProfile(
    account_id='acc-1',
    account_name='Acme Corp',
    stakeholders=[StakeholderProfile(name='Jane', role='CTO', technical_maturity='high')],
    integrations=[IntegrationStatus(integration_name='REST API', is_active=True)],
)
blocks = render_relationship_profile_blocks(profile)
assert len(blocks) > 0, 'No blocks rendered for profile'

# Test health dashboard renderer
health = HealthScoreResult(account_id='acc-1', score=75, rag_status='Green')
h_blocks = render_health_dashboard_blocks(health)
assert len(h_blocks) > 0, 'No blocks for health dashboard'

# Test communication log renderer
record = CommunicationRecord(date='2026-02-24', communication_type='health_checkin', subject='Monthly Check-in')
c_blocks = render_communication_log_blocks([record])
assert len(c_blocks) > 0, 'No blocks for communication log'

print('All NotionTAM renderers produce valid blocks')
"` -- must succeed.

Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "
from src.app.agents.technical_account_manager.scheduler import TAMScheduler
import inspect
assert hasattr(TAMScheduler, 'start')
assert hasattr(TAMScheduler, 'stop')
print('TAMScheduler imports OK')
"` -- must succeed.

Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "
from src.app.agents.technical_account_manager.notion_tam import NotionTAMAdapter
import inspect
methods = [m for m in dir(NotionTAMAdapter) if not m.startswith('_')]
assert 'create_relationship_profile' in methods
assert 'update_health_score' in methods
assert 'query_all_accounts' in methods
print(f'NotionTAMAdapter has methods: {methods}')
"` -- must succeed.

Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -m pytest tests/ -x -q --timeout=30 2>&1 | tail -5` -- existing tests still pass.
  </verify>
  <done>
NotionTAMAdapter with 5 retry-wrapped methods, 3 module-level block renderers. TicketClient abstracts Notion DB queries. TAMScheduler clones PMScheduler for daily scan + monthly check-ins. GmailService.create_draft enables draft-only communications.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.app.agents.technical_account_manager.health_scorer import HealthScorer; s = HealthScorer(); print(s.compute_score(0,0,3,None))"` -- returns (100, 'Green')
2. `python -c "from src.app.agents.technical_account_manager.ticket_client import TicketClient"` -- imports succeed
3. `python -c "from src.app.agents.technical_account_manager.notion_tam import NotionTAMAdapter, render_relationship_profile_blocks"` -- imports succeed
4. `python -c "from src.app.agents.technical_account_manager.scheduler import TAMScheduler"` -- imports succeed
5. `python -c "from src.app.services.gsuite.gmail import GmailService; assert hasattr(GmailService, 'create_draft')"` -- new method exists
6. Existing tests still pass
</verification>

<success_criteria>
- HealthScorer computes deterministic scores with configurable thresholds, no LLM
- TicketClient reads from Notion DB with retry, returns TicketSummary models
- NotionTAMAdapter creates/updates relationship profiles as sub-pages
- TAMScheduler runs daily health scan and monthly check-ins via APScheduler
- GmailService.create_draft added without modifying existing methods
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-technical-account-manager-agent/13-03-SUMMARY.md`
</output>
