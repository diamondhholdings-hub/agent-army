---
phase: 13-technical-account-manager-agent
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/app/agents/technical_account_manager/agent.py
  - src/app/agents/technical_account_manager/capabilities.py
  - src/app/agents/technical_account_manager/__init__.py
autonomous: true

must_haves:
  truths:
    - "TAM agent routes tasks to 7 specialized handlers by task_type"
    - "Each handler follows fail-open pattern returning error dict on failure"
    - "Health scan handler computes score via pure Python HealthScorer (no LLM)"
    - "Escalation outreach handler fires all 4 notification channels and auto-generates draft"
    - "TAM never calls send_email -- always create_draft for all communications including escalation alerts"
    - "Co-dev opportunity handler dispatches to Sales Agent via event bus"
    - "Unknown task type raises ValueError (matching PM agent pattern)"
  artifacts:
    - path: "src/app/agents/technical_account_manager/agent.py"
      provides: "TAMAgent(BaseAgent) with 7 capability handlers"
      exports: ["TAMAgent"]
      min_lines: 250
    - path: "src/app/agents/technical_account_manager/capabilities.py"
      provides: "TAM_CAPABILITIES list + create_tam_registration factory"
      exports: ["TAM_CAPABILITIES", "create_tam_registration"]
    - path: "src/app/agents/technical_account_manager/__init__.py"
      provides: "Full package exports including agent + capabilities"
      exports: ["TAMAgent", "TAM_CAPABILITIES", "create_tam_registration"]
  key_links:
    - from: "src/app/agents/technical_account_manager/agent.py"
      to: "src/app/agents/technical_account_manager/prompts.py"
      via: "import and call 5 communication prompt builders"
      pattern: "build_escalation_outreach_prompt|build_release_notes_prompt"
    - from: "src/app/agents/technical_account_manager/agent.py"
      to: "src/app/agents/technical_account_manager/schemas.py"
      via: "parse LLM output and construct result models"
      pattern: "HealthScoreResult|TAMResult|RelationshipProfile"
    - from: "src/app/agents/technical_account_manager/agent.py"
      to: "src/app/agents/base"
      via: "BaseAgent subclass"
      pattern: "class TAMAgent\\(BaseAgent\\)"
    - from: "src/app/agents/technical_account_manager/agent.py"
      to: "src/app/services/gsuite/gmail.py"
      via: "create_draft for all communications (NEVER send_email)"
      pattern: "create_draft"
---

<objective>
Implement the TAMAgent core: 7 capability handlers (health_scan, escalation_outreach, release_notes, roadmap_preview, health_checkin, customer_success_review, update_relationship_profile), the capabilities declaration, and full package init.

Purpose: This is the agent brain -- the handlers that compute health scores, generate communications, manage escalations across 4 channels, and maintain relationship profiles.
Output: agent.py (TAMAgent with 7 handlers), capabilities.py (5 capabilities + registration factory), __init__.py (full exports)
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-technical-account-manager-agent/13-CONTEXT.md
@.planning/phases/13-technical-account-manager-agent/13-RESEARCH.md

# Pattern references -- clone these structures exactly
@src/app/agents/project_manager/agent.py
@src/app/agents/business_analyst/agent.py
@src/app/agents/base.py

# Dependencies from plan 01
@src/app/agents/technical_account_manager/schemas.py
@src/app/agents/technical_account_manager/prompts.py

# Services the TAM agent uses
@src/app/services/gsuite/gmail.py
@src/app/services/gsuite/chat.py
@src/app/services/gsuite/models.py
@src/app/events/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TAMAgent with 7 capability handlers</name>
  <files>src/app/agents/technical_account_manager/agent.py</files>
  <action>
Create `agent.py` following the ProjectManagerAgent pattern (closest analog: scheduled scans, Notion writes, email dispatch, multi-handler routing).

**Class: TAMAgent(BaseAgent)**

Constructor takes:
- `registration: AgentRegistration`
- `llm_service: object` (LLMService or compatible)
- `notion_tam: object | None = None` (NotionTAMAdapter, configured separately)
- `gmail_service: object | None = None` (GmailService for create_draft)
- `chat_service: object | None = None` (ChatService for chat alerts)
- `event_bus: object | None = None` (TenantEventBus)
- `ticket_client: object | None = None` (TicketClient for ticket data)
- `health_scorer: object | None = None` (HealthScorer for score computation)
Call `super().__init__(registration)`. Store all services as private attributes. Create `_log` bound logger with agent_id and agent_name.

**Task Router -- `async def execute(self, task: dict[str, Any], context: dict[str, Any]) -> dict[str, Any]`:**
Route by `task["type"]`:
```python
handlers = {
    "health_scan": self._handle_health_scan,
    "escalation_outreach": self._handle_escalation_outreach,
    "release_notes": self._handle_release_notes,
    "roadmap_preview": self._handle_roadmap_preview,
    "health_checkin": self._handle_health_checkin,
    "customer_success_review": self._handle_customer_success_review,
    "update_relationship_profile": self._handle_update_relationship_profile,
}
```
Unknown type raises `ValueError(f"Unknown task type: {task_type!r}. Supported: {', '.join(handlers.keys())}")` -- matching PM agent pattern.

**Handler 1: `_handle_health_scan`**
This is the CORE handler. Computes health score for one or all accounts.
- If `task.get("account_id")` is provided, scan single account. Otherwise, scan all accounts via `self._notion_tam.query_all_accounts()`.
- For each account:
  1. Get open tickets via `self._ticket_client.get_open_tickets(account_id)` and `get_p1_p2_tickets(account_id)`. If ticket_client is None, use empty lists and log warning.
  2. Get heartbeat data from account metadata (hours_since_heartbeat from Notion properties).
  3. Call `self._health_scorer.compute_score(p1_p2_count, oldest_age_days, total_open, hours_since_heartbeat)` to get (score, rag_status). If health_scorer is None, return error dict.
  4. Construct `HealthScoreResult` with current + previous score/RAG from account metadata.
  5. If `health_score_result.should_escalate` is True, trigger escalation (call `_dispatch_escalation_notifications`).
  6. Update Notion account page via `self._notion_tam.update_health_score(account_page_id, score, rag)`.
- Rate-limit: max 5 escalation alerts per scan run. If more accounts need escalation, log a summary warning.
- Return `TAMResult(task_type="health_scan", health_scores=[...], confidence="high").model_dump()`
- Fail-open: on any exception, log and return error dict `{"task_type": "health_scan", "error": str(e), "confidence": "low", "partial": True}`

**Handler 2: `_handle_escalation_outreach`**
- Get relationship profile from Notion for the account
- Get open tickets for the account
- Get health score for the account
- Call `build_escalation_outreach_prompt(health_score_dict, profile_dict, tickets_list)`
- Single LLM call with `TAM_SYSTEM_PROMPT` as system, prompt as user. Temperature 0.3.
- Parse JSON response to extract subject, body_html, key_issues
- CRITICAL: Create Gmail DRAFT (not send): `await self._gmail_service.create_draft(EmailMessage(to=rep_email, subject=subject, body_html=body_html))`. If gmail_service is None, log warning and skip.
- Dispatch all 4 notification channels via `_dispatch_escalation_notifications()`
- Return TAMResult with communication_content, draft_id, escalation_result
- Fail-open pattern

**Handler 3: `_handle_release_notes`**
- Extract `release_info` from task
- Get relationship profile for the account
- Call `build_release_notes_prompt(release_info, profile_dict)`
- LLM call, temperature 0.4 (slightly creative)
- Parse response, create Gmail DRAFT with tailored release notes
- Return TAMResult with communication_content, communication_type="release_notes", draft_id
- Fail-open pattern

**Handler 4: `_handle_roadmap_preview`**
- Extract roadmap items from task metadata
- Get relationship profile
- Call `build_roadmap_preview_prompt(roadmap_items, profile_dict)`
- LLM call, temperature 0.4
- Parse response, extract co-dev opportunities
- Create Gmail DRAFT
- If co-dev opportunities found, dispatch to Sales Agent via event bus (lazy import pattern):
  ```python
  if co_dev_opportunities:
      try:
          from src.app.events.schemas import AgentEvent, EventType, EventPriority
          event = AgentEvent(
              event_type=EventType.CONTEXT_UPDATED,
              tenant_id=context.get("tenant_id", ""),
              source_agent_id="technical_account_manager",
              call_chain=["technical_account_manager"],
              priority=EventPriority.NORMAL,
              data={
                  "alert_type": "co_dev_opportunity",
                  "account_id": task.get("account_id", ""),
                  "opportunities": co_dev_opportunities,
              },
          )
          if self._event_bus:
              await self._event_bus.publish("opportunities", event)
      except Exception as opp_err:
          self._log.warning("tam_co_dev_dispatch_failed", error=str(opp_err))
  ```
- Return TAMResult
- Fail-open pattern

**Handler 5: `_handle_health_checkin`**
- Get relationship profile and recent communications
- Get current health score
- Call `build_health_checkin_prompt(health_dict, profile_dict, recent_comms)`
- LLM call, temperature 0.4
- Create Gmail DRAFT
- Log communication to Notion relationship profile
- Return TAMResult
- Fail-open pattern

**Handler 6: `_handle_customer_success_review`**
- Get comprehensive data: health score, full profile, tickets
- Call `build_customer_success_review_prompt(health_dict, profile_dict, tickets)`
- LLM call, temperature 0.3 (structured review)
- Create Gmail DRAFT
- Return TAMResult
- Fail-open pattern

**Handler 7: `_handle_update_relationship_profile`**
- Extract `profile_updates` dict from task
- Get existing profile from Notion
- Merge updates into profile
- Write updated profile to Notion via `self._notion_tam.create_relationship_profile()` or `update_relationship_profile()`
- Return TAMResult with updated relationship_profile
- Fail-open pattern

**Private helper: `_dispatch_escalation_notifications`**
Fires all 4 channels as documented in RESEARCH.md Pattern 5. Each channel is independently try/except'd so one failure doesn't block others:
1. Notion: update account page with health score + RAG status
2. Event bus: publish AgentEvent with event_type=AGENT_HEALTH to notify Sales Agent
3. Email alert draft: `await self._gmail_service.create_draft(alert_email)` -- CRITICAL: the escalation alert email is ALSO created as a draft (not sent directly). TAM NEVER calls send_email. The alert draft says "check your drafts for outreach." Rep reviews and sends both the alert and outreach drafts.
4. Chat alert: `await self._chat_service.send_message(chat_msg)` -- include link/note about the draft
Returns `EscalationNotificationResult` with per-channel success booleans.

**Private helper: `_extract_json_from_response(self, text: str) -> str`**
Same JSON extraction pattern as BA agent: strip markdown code fences, find JSON start.

**LLM call pattern** (same as BA/PM):
```python
response = await self._llm_service.completion(
    messages=[
        {"role": "system", "content": TAM_SYSTEM_PROMPT},
        {"role": "user", "content": prompt},
    ],
    temperature=0.3,
)
raw_text = response.content if hasattr(response, 'content') else str(response)
```
NOTE: Use `.completion()` matching all other agents, NOT `.generate()`.

Use `from __future__ import annotations`, `import json`, `import re`, `from typing import Any`, `import structlog`. Import all needed schemas and prompt builders from plan 01.
  </action>
  <verify>
Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "
from src.app.agents.technical_account_manager.agent import TAMAgent
from src.app.agents.base import AgentRegistration, BaseAgent
print('TAMAgent imports OK')
assert issubclass(TAMAgent, BaseAgent), 'Not a BaseAgent subclass'
print('BaseAgent subclass verified')
"` -- must succeed.

Run: `cd "/Users/RAZER/Documents/projects/sales army" && grep -n 'create_draft' src/app/agents/technical_account_manager/agent.py` -- must find create_draft calls (NOT send_email for any purpose).

Run: `cd "/Users/RAZER/Documents/projects/sales army" && grep -n '_dispatch_escalation_notifications' src/app/agents/technical_account_manager/agent.py` -- must find the 4-channel dispatch helper.

Run: `cd "/Users/RAZER/Documents/projects/sales army" && grep -cn 'send_email' src/app/agents/technical_account_manager/agent.py` -- must find exactly 0 occurrences. TAM NEVER calls send_email.
  </verify>
  <done>
TAMAgent class exists as BaseAgent subclass with 7 handler methods, task router, JSON extraction helper, and 4-channel escalation dispatch. All communication handlers create Gmail drafts (never send). Escalation alert email is also created as a draft (never sent). Health scan uses pure Python HealthScorer. Escalation dispatch fires all 4 channels independently. Zero send_email calls in the entire file.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create capabilities declaration and full package init</name>
  <files>
    src/app/agents/technical_account_manager/capabilities.py
    src/app/agents/technical_account_manager/__init__.py
  </files>
  <action>
**capabilities.py** -- Follow BA capabilities.py pattern exactly:

Define `TAM_CAPABILITIES: list[AgentCapability]` with 5 entries:
1. `health_monitoring` -- "Monitor technical health per account from tickets, CRM, and heartbeat signals. Computes 0-100 health score with Red/Amber/Green status."
   - output_schema: `HealthScoreResult`
2. `escalation_risk_scoring` -- "Predict escalation risk and trigger proactive outreach across 4 channels (Notion, event bus, email, chat) when health deteriorates."
   - output_schema: `EscalationNotificationResult`
3. `technical_communication` -- "Generate account-tailored technical communications: escalation outreach, release notes, roadmap previews, health check-ins, and Customer Success Reviews. All created as Gmail drafts for rep review."
   - output_schema: `TAMResult`
4. `relationship_profiling` -- "Track technical relationship status per account: stakeholder maturity, integration depth, feature adoption, communication history, and customer environment."
   - output_schema: `RelationshipProfile`
5. `opportunity_surfacing` -- "Identify co-development and integration opportunities by aligning customer technical roadmap with product roadmap. Dispatches to Sales Agent via event bus."
   - output_schema: `CoDevOpportunity`

Define `create_tam_registration() -> AgentRegistration`:
- agent_id: "technical_account_manager"
- name: "Technical Account Manager"
- description: "Technical account management agent that monitors health metrics, predicts escalation risk, generates technical advocacy communications, tracks technical relationships, and surfaces co-dev opportunities"
- capabilities: TAM_CAPABILITIES
- backup_agent_id: None
- tags: ["tam", "health", "escalation", "technical", "account_management"]
- max_concurrent_tasks: 3

**__init__.py** -- Expand to include full exports (agent + capabilities + schemas):
```python
"""Technical Account Manager Agent for health monitoring and escalation prediction.

Exports:
    TAMAgent: Core TAM agent class.
    TAM_CAPABILITIES: List of 5 typed capabilities.
    create_tam_registration: Factory for AgentRegistration.
    [all schema exports from plan 01]
"""
from src.app.agents.technical_account_manager.agent import TAMAgent
from src.app.agents.technical_account_manager.capabilities import (
    TAM_CAPABILITIES,
    create_tam_registration,
)
from src.app.agents.technical_account_manager.schemas import (
    TAMHandoffRequest,
    TAMHandoffResponse,
    TAMResult,
    TAMTask,
    TicketSummary,
    HealthScoreResult,
    StakeholderProfile,
    IntegrationStatus,
    FeatureAdoption,
    RelationshipProfile,
    CommunicationRecord,
    CoDevOpportunity,
    EscalationNotificationResult,
)

__all__ = [
    "TAM_CAPABILITIES",
    "TAMAgent",
    "TAMHandoffRequest",
    "TAMHandoffResponse",
    "TAMResult",
    "TAMTask",
    "TicketSummary",
    "HealthScoreResult",
    "StakeholderProfile",
    "IntegrationStatus",
    "FeatureAdoption",
    "RelationshipProfile",
    "CommunicationRecord",
    "CoDevOpportunity",
    "EscalationNotificationResult",
    "create_tam_registration",
]
```
  </action>
  <verify>
Run: `cd "/Users/RAZER/Documents/projects/sales army" && python -c "
from src.app.agents.technical_account_manager import (
    TAMAgent,
    TAM_CAPABILITIES,
    create_tam_registration,
    TAMTask,
    TAMResult,
    HealthScoreResult,
    RelationshipProfile,
)
reg = create_tam_registration()
assert reg.agent_id == 'technical_account_manager'
assert len(TAM_CAPABILITIES) == 5
print(f'TAM registration: {reg.agent_id}, {len(TAM_CAPABILITIES)} capabilities')
print('Full package init OK')
"` -- must succeed.
  </verify>
  <done>
TAM_CAPABILITIES declares 5 capabilities. create_tam_registration produces AgentRegistration with agent_id="technical_account_manager". __init__.py exports all schemas, agent class, capabilities, and registration factory.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.app.agents.technical_account_manager import TAMAgent, create_tam_registration; r = create_tam_registration(); print(r.agent_id, len(r.capabilities))"` -- prints "technical_account_manager 5"
2. `python -c "from src.app.agents.technical_account_manager.agent import TAMAgent; print(TAMAgent.__mro__)"` -- shows BaseAgent in MRO
3. `grep -n 'create_draft' src/app/agents/technical_account_manager/agent.py` -- draft creation present
4. `grep -cn 'send_email' src/app/agents/technical_account_manager/agent.py` -- returns 0 (zero occurrences)
5. `grep -n '_dispatch_escalation_notifications' src/app/agents/technical_account_manager/agent.py` -- 4-channel dispatch present
6. Existing tests still pass: `cd "/Users/RAZER/Documents/projects/sales army" && python -m pytest tests/ -x -q --timeout=30 2>&1 | tail -5`
</verification>

<success_criteria>
- TAMAgent extends BaseAgent with 7 handler methods
- Task router dispatches by task["type"] to correct handler
- All handlers follow fail-open pattern (return error dict, never raise except unknown type)
- Health scan uses pure Python HealthScorer (no LLM for scoring)
- All communications create Gmail DRAFT (never send_email -- zero occurrences in agent.py)
- Escalation alert email is also a draft (not sent directly)
- Escalation fires all 4 notification channels independently
- Co-dev opportunities dispatch to Sales Agent via event bus
- Capabilities declared for all 5 areas
- Package init exports everything
- Existing tests unbroken
</success_criteria>

<output>
After completion, create `.planning/phases/13-technical-account-manager-agent/13-02-SUMMARY.md`
</output>
