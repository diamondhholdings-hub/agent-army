---
phase: 13-technical-account-manager-agent
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/agents/technical_account_manager/notion_tam.py
  - tests/test_technical_account_manager.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "NotionTAMAdapter.get_relationship_profile(account_id) returns a RelationshipProfile dict by finding the sub-page and parsing its blocks"
    - "NotionTAMAdapter.get_account(account_id) returns a single account dict with same structure as query_all_accounts items"
    - "NotionTAMAdapter.log_communication(account_id, comm_record) appends communication blocks to the relationship profile sub-page"
    - "NotionTAMAdapter.update_relationship_profile(page_id, profile_dict) replaces the sub-page content with updated profile blocks"
    - "All 4 new methods are async and retry-wrapped with tenacity (stop_after_attempt(3), wait_exponential)"
    - "All 7 agent handlers work end-to-end with NotionTAMAdapter without AttributeError"
  artifacts:
    - path: "src/app/agents/technical_account_manager/notion_tam.py"
      provides: "4 new methods completing the CRUD interface"
      contains: "get_relationship_profile"
    - path: "tests/test_technical_account_manager.py"
      provides: "Tests covering all 4 new NotionTAMAdapter methods"
      contains: "test_get_relationship_profile"
  key_links:
    - from: "src/app/agents/technical_account_manager/agent.py"
      to: "NotionTAMAdapter.get_relationship_profile()"
      via: "self._notion_tam.get_relationship_profile(account_id)"
      pattern: "get_relationship_profile"
    - from: "src/app/agents/technical_account_manager/agent.py"
      to: "NotionTAMAdapter.get_account()"
      via: "self._notion_tam.get_account(account_id)"
      pattern: "get_account"
    - from: "src/app/agents/technical_account_manager/agent.py"
      to: "NotionTAMAdapter.log_communication()"
      via: "self._notion_tam.log_communication(account_id, comm_record)"
      pattern: "log_communication"
    - from: "src/app/agents/technical_account_manager/agent.py"
      to: "NotionTAMAdapter.update_relationship_profile()"
      via: "self._notion_tam.update_relationship_profile(page_id, profile_dict)"
      pattern: "update_relationship_profile"
---

<objective>
Add the 4 missing CRUD methods to NotionTAMAdapter that agent.py already calls but that do not exist, closing the blocker gap where 6 of 7 TAM handlers silently fail on Notion operations.

Purpose: NotionTAMAdapter currently has 5 methods but agent.py calls 4 additional methods (get_relationship_profile, get_account, log_communication, update_relationship_profile) across 6 handlers. The fail-open try/except prevents crashes but all relationship profile operations return empty dicts, health_checkin never logs to Notion, and update_relationship_profile silently fails. This plan closes Gap 1 from 13-VERIFICATION.md.

Output: Complete NotionTAMAdapter with all 9 methods, plus test coverage for the 4 new methods.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-technical-account-manager-agent/13-VERIFICATION.md
@.planning/phases/13-technical-account-manager-agent/13-03-SUMMARY.md
@src/app/agents/technical_account_manager/notion_tam.py
@src/app/agents/technical_account_manager/agent.py
@src/app/agents/technical_account_manager/schemas.py
@tests/test_technical_account_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 4 missing methods to NotionTAMAdapter</name>
  <files>src/app/agents/technical_account_manager/notion_tam.py</files>
  <action>
Add these 4 methods to the NotionTAMAdapter class in notion_tam.py, following the EXACT same pattern as existing methods (async, tenacity @retry decorator with stop_after_attempt(3), wait_exponential(multiplier=1, min=1, max=10), retry_if_exception_type(Exception), structlog logging).

Insert the new methods AFTER get_relationship_profile_page() and BEFORE the closing of the class (before `__all__`).

**Method 1: get_relationship_profile(account_id: str) -> dict**

This method is called by agent.py at lines 349, 492, 596, 737, 863, 994 as `await self._notion_tam.get_relationship_profile(account_id)`. The caller expects a dict (not a RelationshipProfile model) because it passes the result directly to prompt builders as `relationship_profile=profile_dict`.

Implementation:
1. Call `self.get_relationship_profile_page(account_id)` to find the sub-page ID
2. If no sub-page found, return empty dict `{}`
3. If sub-page found, call `self._client.blocks.children.list(block_id=profile_page_id)` to get all blocks
4. Parse the blocks into a dict structure:
   - Walk blocks looking for heading_3 sections to identify section boundaries
   - For each section (Stakeholder Map, Integration Depth, Feature Adoption, Customer Environment, Co-Development Opportunities, Communication History), parse bulleted_list_item blocks into lists
   - For "Health Dashboard" section, parse paragraph blocks for score/status
5. Return dict with keys: `account_id`, `account_name` (from page title), `stakeholders` (list of dicts), `integrations` (list of dicts), `feature_adoption` (list of dicts), `customer_environment` (list of strings), `communication_history` (list of dicts), `co_dev_opportunities` (list of dicts), `health_score` (int or None), `health_rag` (str or None), `profile_page_id` (the sub-page ID)
6. Use structlog: `logger.info("notion_tam.relationship_profile_fetched", account_id=account_id, profile_page_id=profile_page_id)`

IMPORTANT: The parsing does NOT need to be perfect round-trip reconstruction. The dict is passed to LLM prompt builders which need general context, not exact field reconstruction. A pragmatic approach is fine -- extract what's easily parseable, leave complex fields as simplified text.

Simplified parsing approach for blocks:
- For each bulleted_list_item, extract the plain_text from rich_text[0]["plain_text"]
- For stakeholders: split on ": " and " | " to get name, role, maturity
- For integrations: split on ": " to get name and status
- For feature_adoption: split on ": " to get feature name and status
- For customer_environment: take raw text as string items
- For communication_history: split on " | " to get date, type, subject
- For co_dev_opportunities: split on ": " to get name and description
- For health dashboard paragraphs: regex match score from "Current Score: (\d+)/100" and status from "Status: (\w+)"

```python
@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=1, max=10),
    retry=retry_if_exception_type(Exception),
)
async def get_relationship_profile(
    self,
    account_id: str,
) -> dict:
```

**Method 2: get_account(account_id: str) -> dict**

This method is called by agent.py at line 167 as `await self._notion_tam.get_account(account_id)`. The caller expects a single account dict with the same structure as items returned by `query_all_accounts()`: keys `id`, `name`, `health_score`, `health_rag`, `last_heartbeat`, `hours_since_heartbeat`.

Implementation:
1. Call `self._client.pages.retrieve(page_id=account_id)` to get the account page
2. Parse properties using the EXACT same logic as query_all_accounts (Name from title, Health Score from number, Health Status from select, Last Heartbeat from date with hours_since_heartbeat computed)
3. Return dict with keys: `id`, `name`, `health_score`, `health_rag`, `last_heartbeat`, `hours_since_heartbeat`
4. Also include `account_id` key (same as `id`) for compatibility with agent.py line 192 which reads `account.get("account_id", "")`
5. structlog: `logger.info("notion_tam.account_fetched", account_id=account_id)`

```python
@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=1, max=10),
    retry=retry_if_exception_type(Exception),
)
async def get_account(
    self,
    account_id: str,
) -> dict:
```

**Method 3: log_communication(account_id: str, comm_record: dict | CommunicationRecord) -> None**

This method is called by agent.py at line 817 as `await self._notion_tam.log_communication(account_id, comm_record)`. The caller passes a plain dict (not CommunicationRecord) with keys: date, communication_type, subject, outcome.

Implementation:
1. Accept both dict and CommunicationRecord (check with isinstance; if dict, convert to CommunicationRecord)
2. Find the relationship profile sub-page: `await self.get_relationship_profile_page(account_id)`
3. If no sub-page found, log warning and return (no-op, not an error)
4. Call `self.append_communication_log(profile_page_id, record)` -- reuse the existing method
5. structlog: `logger.info("notion_tam.communication_logged", account_id=account_id, communication_type=...)`

```python
@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=1, max=10),
    retry=retry_if_exception_type(Exception),
)
async def log_communication(
    self,
    account_id: str,
    comm_record: dict | CommunicationRecord,
) -> None:
```

**Method 4: update_relationship_profile(page_id: str, profile_dict: dict) -> None**

This method is called by agent.py at line 1011 as `await self._notion_tam.update_relationship_profile(existing_profile["profile_page_id"], merged_profile)`. The caller passes a page_id (the sub-page ID) and a merged dict with the full profile data.

Implementation:
1. Delete all existing blocks from the sub-page (clear content):
   - `await self._client.blocks.children.list(block_id=page_id)` to get all block IDs
   - For each block: `await self._client.blocks.delete(block_id=block["id"])`
2. Build the profile from the dict:
   - If profile_dict has enough fields to construct a RelationshipProfile model, do so and use `render_relationship_profile_blocks()` to generate blocks
   - Otherwise, create basic blocks from the dict keys/values
3. Append new blocks to the page in 100-block batches (same pattern as create_relationship_profile)
4. structlog: `logger.info("notion_tam.relationship_profile_updated", page_id=page_id)`

For constructing RelationshipProfile from dict: use `RelationshipProfile(**{k: v for k, v in profile_dict.items() if k in RelationshipProfile.model_fields})` inside a try/except. On parse failure, fall back to rendering the dict as paragraph blocks.

```python
@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=1, max=10),
    retry=retry_if_exception_type(Exception),
)
async def update_relationship_profile(
    self,
    page_id: str,
    profile_dict: dict,
) -> None:
```

Also add `import re` at the top of the file (needed for get_relationship_profile parsing).
  </action>
  <verify>
Run: `python -c "from src.app.agents.technical_account_manager.notion_tam import NotionTAMAdapter; methods = ['get_relationship_profile', 'get_account', 'log_communication', 'update_relationship_profile']; missing = [m for m in methods if not hasattr(NotionTAMAdapter, m)]; print(f'Missing: {missing}' if missing else 'All 4 methods exist')"` -- should print "All 4 methods exist"

Run: `grep -c "async def" src/app/agents/technical_account_manager/notion_tam.py` -- should be 9 (5 existing + 4 new)

Run: `grep "@retry" src/app/agents/technical_account_manager/notion_tam.py | wc -l` -- should be 9 (all methods retry-wrapped)
  </verify>
  <done>NotionTAMAdapter has all 9 async retry-wrapped methods: create_relationship_profile, update_health_score, append_communication_log, query_all_accounts, get_relationship_profile_page, get_relationship_profile, get_account, log_communication, update_relationship_profile</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for the 4 new NotionTAMAdapter methods</name>
  <files>tests/test_technical_account_manager.py</files>
  <action>
Add a new test class `TestNotionTAMAdapterMethods` to the END of `tests/test_technical_account_manager.py` (before any final block or at the very bottom). Mock the Notion AsyncClient with AsyncMock.

**Test setup (class-level or fixture):**
- Create a mock AsyncClient with AsyncMock for pages.retrieve, pages.create, pages.update, blocks.children.list, blocks.children.append, blocks.delete
- Instantiate NotionTAMAdapter(client=mock_client, accounts_database_id="test-db-id")

**Test 1: test_get_relationship_profile_returns_dict**
- Mock `blocks.children.list` to return child_page block with title "Technical Relationship Profile - Acme" (to find sub-page)
- Mock a second `blocks.children.list` call (for the sub-page content) to return heading_3 + bulleted_list_item blocks for at least the Stakeholder Map section
- Call `await adapter.get_relationship_profile("acct-123")`
- Assert result is a dict with `profile_page_id` key set to the sub-page ID
- Assert result has `account_id` key

**Test 2: test_get_relationship_profile_returns_empty_when_no_subpage**
- Mock `blocks.children.list` to return empty results (no child_page blocks)
- Call `await adapter.get_relationship_profile("acct-missing")`
- Assert result == {}

**Test 3: test_get_account_returns_single_account_dict**
- Mock `pages.retrieve` to return a Notion page object with properties: Name (title), Health Score (number: 75), Health Status (select: "Amber"), Last Heartbeat (date with start)
- Call `await adapter.get_account("page-id-123")`
- Assert result has keys: id, account_id, name, health_score, health_rag
- Assert result["health_score"] == 75
- Assert result["health_rag"] == "Amber"
- Assert result["account_id"] == "page-id-123"

**Test 4: test_log_communication_finds_subpage_and_appends**
- Mock `blocks.children.list` to return child_page block (finds sub-page)
- Mock `blocks.children.append` to succeed
- Create a dict comm_record: {"date": "2026-02-24", "communication_type": "health_checkin", "subject": "Check-in", "outcome": ""}
- Call `await adapter.log_communication("acct-123", comm_record)`
- Assert `blocks.children.append` was called (verify the mock was invoked)

**Test 5: test_log_communication_noop_when_no_subpage**
- Mock `blocks.children.list` to return empty results (no sub-page)
- Call `await adapter.log_communication("acct-missing", {"date": "2026-02-24", "communication_type": "health_checkin", "subject": "Test", "outcome": ""})`
- Assert `blocks.children.append` was NOT called

**Test 6: test_update_relationship_profile_clears_and_rebuilds**
- Mock `blocks.children.list` to return 2 existing blocks with IDs
- Mock `blocks.delete` to succeed
- Mock `blocks.children.append` to succeed
- Create profile_dict with account_id, account_name, and stakeholders list
- Call `await adapter.update_relationship_profile("profile-page-123", profile_dict)`
- Assert `blocks.delete` was called for each existing block
- Assert `blocks.children.append` was called with new content

**Test 7: test_all_agent_handlers_no_attribute_error**
This is the most critical integration test. Create a TAMAgent with a mock NotionTAMAdapter that has ALL 9 methods as AsyncMock. Then call each of the 6 handlers that use notion_tam methods and verify none raise AttributeError.

- Create mock_notion_tam = AsyncMock()
- Set mock_notion_tam.get_relationship_profile = AsyncMock(return_value={"account_id": "acct-1", "stakeholders": []})
- Set mock_notion_tam.get_account = AsyncMock(return_value={"id": "acct-1", "account_id": "acct-1", "name": "Test", "health_score": 80, "health_rag": "Green"})
- Set mock_notion_tam.log_communication = AsyncMock(return_value=None)
- Set mock_notion_tam.update_relationship_profile = AsyncMock(return_value=None)
- Set mock_notion_tam.query_all_accounts = AsyncMock(return_value=[])
- Set mock_notion_tam.create_relationship_profile = AsyncMock(return_value="page-123")
- Set mock_notion_tam.update_health_score = AsyncMock(return_value=None)
- Set mock_notion_tam.get_relationship_profile_page = AsyncMock(return_value="profile-page-123")
- Set mock_notion_tam.append_communication_log = AsyncMock(return_value=None)
- Create TAMAgent with this mock + mock LLM + real HealthScorer + mock TicketClient + mock Gmail
- Mock LLM to return valid JSON for each handler type
- Call each handler task type: health_scan (single account), escalation_outreach, release_notes, roadmap_preview, health_checkin, customer_success_review, update_relationship_profile
- For each: assert the result does NOT contain `"error"` key with value mentioning "AttributeError"
- For each: assert `mock_notion_tam.get_relationship_profile` was called (for the 6 handlers that use it)
  </action>
  <verify>
Run: `python -m pytest tests/test_technical_account_manager.py -v -k "TestNotionTAMAdapterMethods" --timeout=30` -- all 7 new tests pass

Run: `python -m pytest tests/test_technical_account_manager.py -v --timeout=30` -- full TAM test suite still passes (existing + new tests)

Run: `python -m pytest tests/ -x -q --timeout=30` -- full test suite passes (no regressions)
  </verify>
  <done>7 new tests covering all 4 missing methods exist and pass, including the critical integration test proving all 7 agent handlers work without AttributeError when calling NotionTAMAdapter methods</done>
</task>

</tasks>

<verification>
1. NotionTAMAdapter now has 9 methods (5 original + 4 new): confirmed by grep for "async def" in notion_tam.py
2. All 4 new methods have @retry decorator: confirmed by grep count for "@retry"
3. agent.py calls get_relationship_profile, get_account, log_communication, update_relationship_profile -- all now exist on NotionTAMAdapter
4. All existing tests still pass: `python -m pytest tests/ -x -q --timeout=30`
5. New tests pass: `python -m pytest tests/test_technical_account_manager.py -v -k "TestNotionTAMAdapterMethods"`
6. Gap 1 from 13-VERIFICATION.md is closed: NotionTAMAdapter provides full CRUD for relationship profiles
</verification>

<success_criteria>
- NotionTAMAdapter has get_relationship_profile, get_account, log_communication, update_relationship_profile methods
- All 4 methods are async and retry-wrapped with tenacity
- 7 new tests pass (6 method-level + 1 integration proving all handlers work)
- Full test suite passes with no regressions
- Gap 1 from VERIFICATION.md is resolved
</success_criteria>

<output>
After completion, create `.planning/phases/13-technical-account-manager-agent/13-06-SUMMARY.md`
</output>
