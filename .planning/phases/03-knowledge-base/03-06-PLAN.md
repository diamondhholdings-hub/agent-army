---
phase: 03-knowledge-base
plan: 06
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/knowledge/conversations/__init__.py
  - src/knowledge/conversations/store.py
  - src/knowledge/conversations/session.py
  - tests/knowledge/test_conversations.py
autonomous: true

must_haves:
  truths:
    - "Conversation messages persist across sessions and channels"
    - "Conversation history is retrievable by session_id, channel, or semantic search"
    - "Cross-session context is available (query finds relevant messages from past sessions)"
    - "Conversation storage is tenant-scoped (tenant A messages invisible to tenant B)"
  artifacts:
    - path: "src/knowledge/conversations/store.py"
      provides: "Conversation storage and retrieval using Qdrant conversations collection"
      exports: ["ConversationStore"]
    - path: "src/knowledge/conversations/session.py"
      provides: "Session management for tracking conversation context across interactions"
      exports: ["ConversationSession", "SessionManager"]
  key_links:
    - from: "src/knowledge/conversations/store.py"
      to: "src/knowledge/qdrant_client.py"
      via: "uses QdrantKnowledgeStore for vector storage in conversations collection"
      pattern: "QdrantKnowledgeStore|QdrantClient"
    - from: "src/knowledge/conversations/store.py"
      to: "src/knowledge/embeddings.py"
      via: "embeds messages for semantic search over conversation history"
      pattern: "EmbeddingService"
    - from: "src/knowledge/conversations/session.py"
      to: "src/knowledge/conversations/store.py"
      via: "SessionManager uses ConversationStore to persist and retrieve"
      pattern: "ConversationStore"
---

<objective>
Build conversation history storage and retrieval system that persists messages across sessions and channels, enabling agents to access prior conversation context.

Purpose: Sales agents need memory. A conversation from last week about pricing should be retrievable when the same prospect asks a follow-up question today, even if they switch from chat to email. This plan creates the persistent memory layer using the Qdrant conversations collection.

Output: ConversationStore for message persistence and retrieval. SessionManager for tracking conversation context across sessions and channels. Semantic search over conversation history.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-knowledge-base/03-01-SUMMARY.md

Depends on Plan 01 for QdrantKnowledgeStore (conversations collection), EmbeddingService, and ConversationMessage model.

Key research findings:
- Separate conversations collection in Qdrant (set up by Plan 01)
- Payload indexes: tenant_id (is_tenant), session_id (keyword), channel (keyword), timestamp (integer for range queries)
- Cross-session retrieval: semantic search across all sessions for a tenant
- Channel tracking: web, email, slack, teams, etc.
- Message roles: user, assistant, system

Locked decisions:
- Conversation history persists across sessions and channels
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ConversationStore for message persistence and retrieval</name>
  <files>
    src/knowledge/conversations/__init__.py
    src/knowledge/conversations/store.py
  </files>
  <action>
    src/knowledge/conversations/store.py - ConversationStore class:
    - __init__(qdrant_client: QdrantClient, embedder: EmbeddingService, collection_name: str = "conversations"):
      Store reference to Qdrant client and embedder. Use the conversations collection created by Plan 01.

    - async add_message(message: ConversationMessage) -> str:
      * Embed message content (dense + sparse)
      * Store in conversations collection with payload: tenant_id, session_id, channel, role, content, timestamp, metadata
      * Return message ID

    - async add_messages(messages: list[ConversationMessage]) -> list[str]:
      * Batch version of add_message for efficiency
      * Embed all messages in batch
      * Upsert batch to Qdrant

    - async get_session_history(tenant_id: str, session_id: str, limit: int = 50) -> list[ConversationMessage]:
      * Retrieve all messages for a session, ordered by timestamp
      * Filter by tenant_id (mandatory) and session_id
      * Return as ConversationMessage objects

    - async get_channel_history(tenant_id: str, channel: str, limit: int = 50) -> list[ConversationMessage]:
      * Retrieve recent messages for a channel across all sessions
      * Useful for seeing all interactions on a specific channel

    - async search_conversations(tenant_id: str, query: str, top_k: int = 10, session_id: str | None = None, channel: str | None = None, time_range: tuple[datetime, datetime] | None = None) -> list[ConversationMessage]:
      * Semantic search over conversation history
      * Mandatory tenant_id filter
      * Optional filters: session_id, channel, time_range
      * Embed query, hybrid search (dense + sparse), return relevant messages
      * This is the key feature: "What did we discuss about pricing last week?"

    - async get_recent_context(tenant_id: str, limit: int = 10) -> list[ConversationMessage]:
      * Get the most recent messages across all sessions for a tenant
      * Ordered by timestamp descending
      * Useful for building agent context window

    - async delete_session(tenant_id: str, session_id: str) -> int:
      * Delete all messages for a session (with tenant guard)
      * Return number of messages deleted

    src/knowledge/conversations/__init__.py:
    - Re-export ConversationStore, ConversationSession, SessionManager
  </action>
  <verify>
    Run: `python -c "from src.knowledge.conversations import ConversationStore; print('Import OK')"`
    Verify no import errors.
  </verify>
  <done>
    ConversationStore provides message persistence (add), session retrieval (get_session_history), channel retrieval, semantic search over history, and recent context fetching. All operations tenant-scoped.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SessionManager and test conversation persistence</name>
  <files>
    src/knowledge/conversations/session.py
    tests/knowledge/test_conversations.py
  </files>
  <action>
    src/knowledge/conversations/session.py:

    ConversationSession(BaseModel):
    - session_id: str (uuid4)
    - tenant_id: str
    - channel: str
    - started_at: datetime
    - last_activity: datetime
    - message_count: int = 0
    - metadata: dict = {} (e.g., prospect_name, deal_stage, product_discussed)

    SessionManager class:
    - __init__(store: ConversationStore):
      Manages session lifecycle and context assembly.

    - async create_session(tenant_id: str, channel: str, metadata: dict | None = None) -> ConversationSession:
      * Create new session with UUID, set started_at and last_activity to now()
      * Return session object

    - async add_message_to_session(session: ConversationSession, role: str, content: str, metadata: dict | None = None) -> ConversationMessage:
      * Create ConversationMessage with session's tenant_id, session_id, channel
      * Persist via ConversationStore.add_message()
      * Update session.last_activity and message_count
      * Return the persisted message

    - async get_context_for_session(session: ConversationSession, include_cross_session: bool = True, max_messages: int = 20) -> list[ConversationMessage]:
      * Get current session messages (ordered by timestamp)
      * If include_cross_session: Also search for semantically relevant messages from OTHER sessions for this tenant. Use the last few messages from current session as search query. Limit cross-session to max 5 additional messages.
      * Merge and deduplicate, ordered by relevance/timestamp
      * This enables "the agent remembers what was discussed before"

    - async summarize_session(session: ConversationSession) -> str:
      * Get all messages for session
      * Return a structured summary (not AI-generated -- just structured extraction):
        "Session {id} on {channel} ({message_count} messages, {duration})"
        "Topics discussed: {extracted from message content keywords}"
      * This is a simple extraction, not LLM-powered (LLM summarization would be in RAG layer)

    tests/knowledge/test_conversations.py:
    - All tests use mock EmbeddingService + tmp_path Qdrant local
    - test_add_and_retrieve_messages: Add 5 messages to session, retrieve session history, verify order and content
    - test_cross_session_search: Create 2 sessions for same tenant. In session 1 discuss "pricing for enterprise tier". In session 2, search "pricing" -- verify session 1 messages found.
    - test_tenant_isolation: Create sessions for tenant A and B. Verify tenant A cannot search tenant B messages.
    - test_channel_history: Add messages across 2 channels (web, email). Retrieve channel-specific history. Verify correct filtering.
    - test_session_manager_create_and_add: Use SessionManager to create session, add messages, verify message_count updates.
    - test_cross_session_context: Use get_context_for_session with include_cross_session=True. Verify relevant messages from prior sessions are included.
    - test_time_range_search: Add messages at different timestamps. Search with time_range filter. Verify only messages in range returned.
    - test_delete_session: Add messages, delete session, verify messages gone.
  </action>
  <verify>
    Run: `pytest tests/knowledge/test_conversations.py -v`
    All tests pass. Specifically:
    - Message persistence and retrieval works
    - Cross-session search finds relevant prior conversation content
    - Tenant isolation prevents cross-tenant access
    - Channel filtering returns correct messages
    - Session lifecycle (create, add, get context, delete) works end-to-end
  </verify>
  <done>
    SessionManager handles conversation lifecycle with cross-session context assembly. ConversationStore persists messages with semantic search over history. Agents can retrieve relevant prior conversation context regardless of session or channel. Tenant isolation verified.
  </done>
</task>

</tasks>

<verification>
- `pytest tests/knowledge/test_conversations.py -v` all pass
- Messages persist and retrieve correctly
- Cross-session semantic search finds relevant prior conversations
- Tenant isolation prevents cross-tenant message access
- Channel-specific history retrieval works
- Session lifecycle management (create, add, context, delete) complete
</verification>

<success_criteria>
- Conversation messages persist in Qdrant conversations collection
- Session history retrievable by session_id
- Cross-session context: semantic search finds relevant past messages from any session
- Channel history: filter messages by channel (web, email, slack)
- Time-range queries work for recency filtering
- Tenant isolation: verified that tenant boundaries are enforced
- SessionManager assembles context from current + prior sessions for agent use
</success_criteria>

<output>
After completion, create `.planning/phases/03-knowledge-base/03-06-SUMMARY.md`
</output>
