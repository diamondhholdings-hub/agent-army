"""ElevenLabs streaming TTS with Flash v2.5.

Provides ElevenLabsTTS for text-to-speech synthesis with minimum latency
(~75ms TTFB per RESEARCH.md). Uses the Flash v2.5 model for real-time
meeting responses and short utterance synthesis (greetings, confirmations).

Output format: MP3 at 22050Hz/32kbps for Recall.ai output_audio compatibility.
Streaming latency optimization set to maximum (level 4).
"""

from __future__ import annotations

from collections.abc import AsyncIterator
from typing import Any

import structlog

logger = structlog.get_logger(__name__)

# Lazy import to avoid hard dependency at module level
_elevenlabs_imported = False
_AsyncElevenLabs = None


def _ensure_elevenlabs() -> None:
    """Lazy import of elevenlabs SDK."""
    global _elevenlabs_imported, _AsyncElevenLabs
    if _elevenlabs_imported:
        return
    try:
        from elevenlabs.client import AsyncElevenLabs
        _AsyncElevenLabs = AsyncElevenLabs
        _elevenlabs_imported = True
    except ImportError:
        raise ImportError(
            "elevenlabs is required for ElevenLabsTTS. "
            "Install with: pip install elevenlabs>=1.15.0"
        )


class ElevenLabsTTS:
    """Streaming TTS with ElevenLabs Flash v2.5.

    Provides both streaming synthesis (for real-time pipeline) and
    full synthesis (for short utterances like greetings).

    Args:
        api_key: ElevenLabs API key.
        voice_id: ElevenLabs voice identifier.
    """

    # Flash v2.5: ~75ms TTFB per RESEARCH.md
    MODEL_ID = "eleven_flash_v2_5"

    # MP3 for Recall.ai output_audio compatibility
    OUTPUT_FORMAT = "mp3_22050_32"

    # Maximum streaming latency optimization per ElevenLabs docs
    OPTIMIZE_STREAMING_LATENCY = 4

    def __init__(self, api_key: str, voice_id: str) -> None:
        _ensure_elevenlabs()
        self._client = _AsyncElevenLabs(api_key=api_key)
        self._voice_id = voice_id

    async def synthesize_stream(self, text: str) -> AsyncIterator[bytes]:
        """Stream audio bytes from text.

        Yields MP3 audio chunks as they are generated by ElevenLabs.
        Use for real-time pipeline where low latency is critical.

        Args:
            text: Text to synthesize.

        Yields:
            MP3 audio chunks as bytes.
        """
        logger.debug("tts.synthesize_stream", text_length=len(text))

        audio_stream = await self._client.text_to_speech.convert(
            voice_id=self._voice_id,
            text=text,
            model_id=self.MODEL_ID,
            output_format=self.OUTPUT_FORMAT,
            optimize_streaming_latency=self.OPTIMIZE_STREAMING_LATENCY,
        )

        return audio_stream

    async def synthesize_full(self, text: str) -> bytes:
        """Synthesize text to a single audio buffer.

        Convenience method that collects all chunks into a single bytes
        buffer. Used for short utterances (greetings, confirmations)
        where streaming is unnecessary.

        Args:
            text: Text to synthesize.

        Returns:
            Complete MP3 audio as bytes.
        """
        logger.debug("tts.synthesize_full", text_length=len(text))

        audio_stream = await self._client.text_to_speech.convert(
            voice_id=self._voice_id,
            text=text,
            model_id=self.MODEL_ID,
            output_format=self.OUTPUT_FORMAT,
            optimize_streaming_latency=self.OPTIMIZE_STREAMING_LATENCY,
        )

        # Collect all chunks into a buffer
        chunks: list[bytes] = []
        async for chunk in audio_stream:
            if isinstance(chunk, bytes):
                chunks.append(chunk)

        audio_bytes = b"".join(chunks)
        logger.info(
            "tts.synthesized",
            text_length=len(text),
            audio_bytes=len(audio_bytes),
        )
        return audio_bytes
